<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tests Unitaires Gwent - Suite Exhaustive</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
            margin: 0;
        }
        .container { max-width: 1600px; margin: 0 auto; }
        h1 { color: #ffcc00; text-align: center; margin-bottom: 30px; font-size: 28px; }
        
        .test-suite {
            background: #2c2c2c;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 5px solid #2196f3;
        }
        .test-suite h2 { color: #2196f3; margin-top: 0; font-size: 20px; }
        
        .test-case {
            background: #1a1a1a;
            padding: 12px;
            margin: 8px 0;
            border-radius: 5px;
            border-left: 3px solid #666;
            font-size: 13px;
        }
        .test-case.pass { border-left-color: #4caf50; background: #1a2e1a; }
        .test-case.fail { border-left-color: #f44336; background: #2e1a1a; }
        
        .test-name { font-weight: bold; margin-bottom: 8px; }
        .test-result {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
            margin-right: 10px;
        }
        .test-result.pass { background: #4caf50; color: white; }
        .test-result.fail { background: #f44336; color: white; }
        
        .test-error {
            color: #ff8a80;
            margin-top: 5px;
            font-style: italic;
            font-size: 12px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .summary {
            background: #2c2c2c;
            padding: 25px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 30px;
            border: 2px solid #ffcc00;
        }
        .summary h2 { color: #ffcc00; margin: 0 0 20px 0; }
        
        .stats {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
        }
        .stat {
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 18px;
            min-width: 150px;
        }
        .stat-pass { background: #4caf50; }
        .stat-fail { background: #f44336; }
        .stat-total { background: #2196f3; }
        .stat-value { font-size: 32px; font-weight: bold; margin-top: 10px; }
        
        .run-button {
            display: block;
            margin: 30px auto;
            padding: 15px 50px;
            font-size: 20px;
            background: #ffcc00;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            color: #000;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(255,204,0,0.3);
            transition: all 0.3s;
        }
        .run-button:hover { 
            background: #ffd966; 
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255,204,0,0.5);
        }
        
        .progress {
            width: 100%;
            height: 30px;
            background: #1a1a1a;
            border-radius: 5px;
            overflow: hidden;
            margin: 20px 0;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
        }
        
        .suite-stats {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            font-size: 13px;
            color: #aaa;
        }
        
        .filter-buttons {
            text-align: center;
            margin: 20px 0;
        }
        .filter-btn {
            padding: 8px 20px;
            margin: 0 5px;
            background: #444;
            border: 2px solid #666;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        .filter-btn.active { border-color: #ffcc00; background: #555; }
        .filter-btn:hover { background: #555; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ GWENT - Suite de Tests Unitaires Exhaustive</h1>
        
        <button class="run-button" onclick="runAllTests()">‚ñ∂Ô∏è Lancer tous les tests</button>
        
        <div class="progress" id="progress-container" style="display: none;">
            <div class="progress-bar" id="progress-bar">0%</div>
        </div>
        
        <div class="summary" id="summary" style="display: none;">
            <h2>üìä R√©sum√© des Tests</h2>
            <div class="stats">
                <div class="stat stat-total">
                    <div>Total</div>
                    <div class="stat-value" id="total-tests">0</div>
                </div>
                <div class="stat stat-pass">
                    <div>‚úì R√©ussis</div>
                    <div class="stat-value" id="passed-tests">0</div>
                </div>
                <div class="stat stat-fail">
                    <div>‚úó √âchou√©s</div>
                    <div class="stat-value" id="failed-tests">0</div>
                </div>
            </div>
        </div>
        
        <div class="filter-buttons" id="filter-buttons" style="display: none;">
            <button class="filter-btn active" onclick="filterTests('all')">Tous</button>
            <button class="filter-btn" onclick="filterTests('pass')">R√©ussis</button>
            <button class="filter-btn" onclick="filterTests('fail')">√âchou√©s</button>
        </div>
        
        <div id="test-results"></div>
    </div>

    <!-- Charger le moteur de jeu -->
    <script src="gwent-engine.js"></script>

    <script>
        // =====================================================================
        // FRAMEWORK DE TESTS
        // =====================================================================

        class TestSuite {
            constructor(name) {
                this.name = name;
                this.tests = [];
                this.passed = 0;
                this.failed = 0;
            }

            test(name, fn) {
                this.tests.push({ name, fn });
            }

            async run() {
                const results = [];
                for (const test of this.tests) {
                    try {
                        await test.fn();
                        this.passed++;
                        results.push({ name: test.name, status: 'pass', error: null });
                    } catch (error) {
                        this.failed++;
                        results.push({ name: test.name, status: 'fail', error: error.message });
                    }
                }
                return results;
            }
        }

        function assert(condition, message) {
            if (!condition) throw new Error(message || 'Assertion √©chou√©e');
        }

        function assertEquals(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(`${message || 'Valeurs diff√©rentes'}\n  Attendu: ${expected}\n  Obtenu: ${actual}`);
            }
        }

        function assertArrayEquals(actual, expected, message) {
            if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                throw new Error(`${message || 'Tableaux diff√©rents'}\n  Attendu: ${JSON.stringify(expected)}\n  Obtenu: ${JSON.stringify(actual)}`);
            }
        }

        function assertGreaterThan(actual, expected, message) {
            if (actual <= expected) {
                throw new Error(`${message || 'Pas sup√©rieur'}\n  Attendu > ${expected}\n  Obtenu: ${actual}`);
            }
        }

        function assertContains(array, item, message) {
            if (!array.includes(item)) {
                throw new Error(`${message || 'Element non trouv√©'}\n  Cherch√©: ${item}\n  Dans: ${JSON.stringify(array)}`);
            }
        }

        // =====================================================================
        // D√âFINITION DES TESTS
        // =====================================================================

        function defineAllTests() {
            const suites = [];

            // ============ SUITE 1: CALCUL DE SCORE DE BASE ============
            const scoreTests = new TestSuite("üìä Calcul de Score de Base");
            
            scoreTests.test("Carte simple sans effet", () => {
                const state = gameState;
                state.playerA.ranged.cards = ['Archer'];
                const score = calculateRowScore('A', 'ranged');
                assertEquals(score, 3, "Archer = 3 points");
            });

            scoreTests.test("H√©ros immunis√© √† la m√©t√©o", () => {
                gameState.weather.frost = true;
                gameState.playerA.melee.cards = ['Geralt de Riv'];
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 15, "H√©ros non affect√© par m√©t√©o");
                gameState.weather.frost = false;
            });

            scoreTests.test("Cartes multiples sans lien", () => {
                gameState.playerA.ranged.cards = ['Archer', 'Archer'];
                const score = calculateRowScore('A', 'ranged');
                assertEquals(score, 6, "2 Archers = 6 points");
            });

            scoreTests.test("Score total toutes rang√©es", () => {
                gameState.playerA.melee.cards = ['Geralt de Riv'];
                gameState.playerA.ranged.cards = ['Archer'];
                gameState.playerA.siege.cards = ['Catapulte'];
                const total = calculateTotalScore('A');
                assertEquals(total, 26, "15+3+8=26");
            });

            scoreTests.test("Scores ind√©pendants par joueur", () => {
                gameState.playerA.melee.cards = ['Geralt de Riv'];
                gameState.playerB.ranged.cards = ['Archer'];
                const scoreA = calculateTotalScore('A');
                const scoreB = calculateTotalScore('B');
                assertEquals(scoreA, 15, "Score A");
                assertEquals(scoreB, 3, "Score B");
            });

            suites.push(scoreTests);

            // ============ SUITE 2: LIEN RAPPROCH√â ============
            const bondTests = new TestSuite("üîó Lien Rapproch√© (Tight Bond)");
            
            bondTests.test("Une seule carte Lien", () => {
                gameState.playerA.melee.cards = ['Fantassin'];
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 1, "1 seule carte = force normale");
            });

            bondTests.test("Deux cartes Lien identiques", () => {
                gameState.playerA.melee.cards = ['Fantassin', 'Fantassin'];
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 4, "(1*2)*2=4");
            });

            bondTests.test("Trois cartes Lien identiques", () => {
                gameState.playerA.melee.cards = ['Fantassin', 'Fantassin', 'Fantassin'];
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 6, "(1*2)*3=6");
            });

            bondTests.test("Cinq cartes Lien identiques", () => {
                gameState.playerA.melee.cards = ['Fantassin', 'Fantassin', 'Fantassin', 'Fantassin', 'Fantassin'];
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 10, "(1*2)*5=10");
            });

            bondTests.test("Deux paires diff√©rentes de Lien", () => {
                gameState.playerA.melee.cards = ['Fantassin', 'Fantassin', 'Brigade Nauzicaa', 'Brigade Nauzicaa'];
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 24, "(1*2)*2 + (5*2)*2 = 4+20=24");
            });

            bondTests.test("Lien + carte normale", () => {
                gameState.playerA.melee.cards = ['Fantassin', 'Fantassin', 'Chevalier'];
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 8, "(1*2)*2 + 4 = 8");
            });

            suites.push(bondTests);

            // ============ SUITE 3: CORNE DE COMMANDANT ============
            const hornTests = new TestSuite("üìØ Corne de Commandant");
            
            hornTests.test("Corne double carte simple", () => {
                gameState.playerA.ranged.cards = ['Archer'];
                gameState.playerA.ranged.horn = true;
                const score = calculateRowScore('A', 'ranged');
                assertEquals(score, 6, "3*2=6");
                gameState.playerA.ranged.horn = false;
            });

            hornTests.test("Corne avec H√©ros", () => {
                gameState.playerA.melee.cards = ['Geralt de Riv'];
                gameState.playerA.melee.horn = true;
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 30, "15*2=30");
                gameState.playerA.melee.horn = false;
            });

            hornTests.test("Corne avec Lien Rapproch√©", () => {
                gameState.playerA.melee.cards = ['Fantassin', 'Fantassin'];
                gameState.playerA.melee.horn = true;
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 8, "((1*2)*2)*2=8");
                gameState.playerA.melee.horn = false;
            });

            hornTests.test("Corne avec 3 cartes diff√©rentes", () => {
                gameState.playerA.ranged.cards = ['Archer', 'Sorcier Kaedwen', 'Havekar'];
                gameState.playerA.ranged.horn = true;
                const score = calculateRowScore('A', 'ranged');
                assertEquals(score, 22, "(3+5+3)*2=22");
                gameState.playerA.ranged.horn = false;
            });

            hornTests.test("Corne n'affecte qu'une seule rang√©e", () => {
                gameState.playerA.ranged.cards = ['Archer'];
                gameState.playerA.melee.cards = ['Geralt de Riv'];
                gameState.playerA.ranged.horn = true;
                const scoreRanged = calculateRowScore('A', 'ranged');
                const scoreMelee = calculateRowScore('A', 'melee');
                assertEquals(scoreRanged, 6, "Rang√©e avec corne");
                assertEquals(scoreMelee, 15, "Rang√©e sans corne");
                gameState.playerA.ranged.horn = false;
            });

            suites.push(hornTests);

            // ============ SUITE 4: M√âT√âO ============
            const weatherTests = new TestSuite("üå¶Ô∏è Effets M√©t√©o");
            
            weatherTests.test("Froid r√©duit M√™l√©e √† 1", () => {
                gameState.weather.frost = true;
                gameState.playerA.melee.cards = ['Chevalier'];
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 1, "4 ‚Üí 1");
                gameState.weather.frost = false;
            });

            weatherTests.test("Brouillard r√©duit Distance √† 1", () => {
                gameState.weather.fog = true;
                gameState.playerA.ranged.cards = ['Sorcier Kaedwen'];
                const score = calculateRowScore('A', 'ranged');
                assertEquals(score, 1, "5 ‚Üí 1");
                gameState.weather.fog = false;
            });

            weatherTests.test("Pluie r√©duit Si√®ge √† 1", () => {
                gameState.weather.rain = true;
                gameState.playerA.siege.cards = ['Catapulte'];
                const score = calculateRowScore('A', 'siege');
                assertEquals(score, 1, "8 ‚Üí 1");
                gameState.weather.rain = false;
            });

            weatherTests.test("M√©t√©o √©pargne H√©ros", () => {
                gameState.weather.frost = true;
                gameState.playerA.melee.cards = ['Geralt de Riv'];
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 15, "H√©ros immunis√©");
                gameState.weather.frost = false;
            });

            weatherTests.test("M√©t√©o avec Lien Rapproch√©", () => {
                gameState.weather.frost = true;
                gameState.playerA.melee.cards = ['Fantassin', 'Fantassin'];
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 4, "(1*2)*2=4");
                gameState.weather.frost = false;
            });

            weatherTests.test("M√©t√©o affecte les 2 joueurs", () => {
                gameState.weather.frost = true;
                gameState.playerA.melee.cards = ['Chevalier'];
                gameState.playerB.melee.cards = ['Chevalier'];
                const scoreA = calculateRowScore('A', 'melee');
                const scoreB = calculateRowScore('B', 'melee');
                assertEquals(scoreA, 1, "A affect√©");
                assertEquals(scoreB, 1, "B affect√©");
                gameState.weather.frost = false;
            });

            weatherTests.test("Temps D√©gag√© annule toutes m√©t√©os", () => {
                gameState.weather.frost = true;
                gameState.weather.fog = true;
                gameState.weather.rain = true;
                handleClearWeather();
                assertEquals(gameState.weather.frost, false, "Froid annul√©");
                assertEquals(gameState.weather.fog, false, "Brouillard annul√©");
                assertEquals(gameState.weather.rain, false, "Pluie annul√©e");
            });

            weatherTests.test("M√©t√©o n'affecte pas autres rang√©es", () => {
                gameState.weather.frost = true;
                gameState.playerA.ranged.cards = ['Archer'];
                const score = calculateRowScore('A', 'ranged');
                assertEquals(score, 3, "Distance non affect√©e");
                gameState.weather.frost = false;
            });

            suites.push(weatherTests);

            // ============ SUITE 5: INCIN√âRATION ============
            const scorchTests = new TestSuite("üî• Incin√©ration (Scorch)");
            
            scorchTests.test("D√©truit la plus forte non-H√©ros", () => {
                gameState.playerA.melee.cards = ['Geralt de Riv'];
                gameState.playerB.siege.cards = ['Catapulte'];
                const destroyed = handleScorch();
                assertEquals(destroyed, 1, "1 carte d√©truite");
                assertEquals(gameState.playerB.siege.cards.length, 0, "Catapulte d√©truite");
                assertEquals(gameState.playerA.melee.cards.length, 1, "H√©ros intact");
            });

            scorchTests.test("√âpargne tous les H√©ros", () => {
                gameState.playerA.melee.cards = ['Geralt de Riv', 'Ciri'];
                gameState.playerB.ranged.cards = ['Tibor'];
                const destroyed = handleScorch();
                assertEquals(destroyed, 0, "Aucun H√©ros d√©truit");
            });

            scorchTests.test("D√©truit plusieurs cartes √©gales", () => {
                gameState.playerA.siege.cards = ['Catapulte'];
                gameState.playerB.siege.cards = ['Catapulte'];
                const destroyed = handleScorch();
                assertEquals(destroyed, 2, "2 cartes d√©truites");
            });

            scorchTests.test("Cartes vont au cimeti√®re", () => {
                gameState.playerA.siege.cards = ['Catapulte'];
                gameState.playerA.graveyard = [];
                handleScorch();
                assertEquals(gameState.playerA.graveyard.length, 1, "1 au cimeti√®re");
                assertContains(gameState.playerA.graveyard, 'Catapulte', "Bonne carte");
            });

            scorchTests.test("Incin√©ration avec Lien Rapproch√©", () => {
                gameState.playerA.melee.cards = ['Brigade Nauzicaa', 'Brigade Nauzicaa'];
                gameState.playerB.ranged.cards = ['Archer'];
                const destroyed = handleScorch();
                assertGreaterThan(destroyed, 0, "Des cartes d√©truites");
            });

            suites.push(scorchTests);

            // ============ SUITE 6: GESTION DES MANCHES ============
            const roundTests = new TestSuite("üéØ Gestion des Manches");
            
            roundTests.test("√âtat initial du jeu", () => {
                assertEquals(gameState.currentRound, 1, "Manche 1");
                assertEquals(gameState.roundsWon.A, 0, "A: 0 victoire");
                assertEquals(gameState.roundsWon.B, 0, "B: 0 victoire");
            });

            roundTests.test("Vainqueur d√©termin√© par score", () => {
                gameState.playerA.melee.cards = ['Geralt de Riv'];
                gameState.playerB.ranged.cards = ['Archer'];
                const scoreA = calculateTotalScore('A');
                const scoreB = calculateTotalScore('B');
                assert(scoreA > scoreB, "A a plus de points");
            });

            roundTests.test("Compteur de tours s'incr√©mente", () => {
                const before = gameState.turnCount;
                gameState.turnCount++;
                assertEquals(gameState.turnCount, before + 1, "Tour incr√©ment√©");
                gameState.turnCount = 0;
            });

            roundTests.test("Indicateurs de passe", () => {
                gameState.playerA.passed = false;
                gameState.playerB.passed = false;
                assertEquals(gameState.playerA.passed, false, "A n'a pas pass√©");
                assertEquals(gameState.playerB.passed, false, "B n'a pas pass√©");
            });

            roundTests.test("D√©tection fin de manche", () => {
                gameState.playerA.passed = true;
                gameState.playerB.passed = true;
                const isOver = gameState.playerA.passed && gameState.playerB.passed;
                assertEquals(isOver, true, "Fin d√©tect√©e");
                gameState.playerA.passed = false;
                gameState.playerB.passed = false;
            });

            suites.push(roundTests);

            // ============ SUITE 7: MAIN ET DECK ============
            const deckTests = new TestSuite("üé∞ Gestion Main et Deck");
            
            deckTests.test("Main initiale vide", () => {
                gameState.playerA.hand = [];
                assertEquals(gameState.playerA.hand.length, 0, "Main vide");
            });

            deckTests.test("Pioche depuis le deck", () => {
                gameState.playerA.deck = ['Archer', 'Geralt de Riv'];
                gameState.playerA.hand = [];
                const card = gameState.playerA.deck.pop();
                gameState.playerA.hand.push(card);
                assertEquals(gameState.playerA.hand.length, 1, "1 carte en main");
                assertEquals(gameState.playerA.deck.length, 1, "Deck r√©duit");
            });

            deckTests.test("Deck vide ne permet pas pioche", () => {
                gameState.playerA.deck = [];
                const before = gameState.playerA.hand.length;
                if (gameState.playerA.deck.length > 0) {
                    gameState.playerA.hand.push(gameState.playerA.deck.pop());
                }
                assertEquals(gameState.playerA.hand.length, before, "Main inchang√©e");
            });

            deckTests.test("Cimeti√®re re√ßoit cartes d√©truites", () => {
                gameState.playerA.graveyard = [];
                gameState.playerA.graveyard.push('Archer');
                assertEquals(gameState.playerA.graveyard.length, 1, "1 au cimeti√®re");
            });

            deckTests.test("Carte retir√©e de main apr√®s jeu", () => {
                gameState.playerA.hand = ['Archer', 'Geralt de Riv'];
                const card = 'Archer';
                const idx = gameState.playerA.hand.indexOf(card);
                gameState.playerA.hand.splice(idx, 1);
                assertEquals(gameState.playerA.hand.length, 1, "Main r√©duite");
                assert(!gameState.playerA.hand.includes('Archer'), "Archer retir√©");
            });

            suites.push(deckTests);

            // ============ SUITE 8: CAPACIT√âS SP√âCIALES ============
            const capacityTests = new TestSuite("‚ö° Capacit√©s Sp√©ciales");
            
            capacityTests.test("Espion plac√© chez adversaire", () => {
                gameState.playerB.melee.cards = [];
                handleSpy('A', 'Dijkstra', CARD_DATABASE['Dijkstra']);
                assertEquals(gameState.playerB.melee.cards.length, 1, "Chez B");
                assertContains(gameState.playerB.melee.cards, 'Dijkstra', "Bonne carte");
            });

            capacityTests.test("Espion fait piocher 2 cartes", () => {
                gameState.playerA.hand = [];
                gameState.playerA.deck = ['Archer', 'Geralt de Riv', 'Ciri'];
                handleSpy('A', 'Dijkstra', CARD_DATABASE['Dijkstra']);
                assertEquals(gameState.playerA.hand.length, 2, "2 pioch√©es");
            });

            capacityTests.test("M√©decin ressuscite du cimeti√®re", () => {
                gameState.playerA.graveyard = ['Archer'];
                gameState.playerA.melee.cards = [];
                handleMedic('A', 'Medic Temeria', CARD_DATABASE['Medic Temeria']);
                assert(gameState.playerA.melee.cards.length > 1, "Cartes plac√©es");
            });

            capacityTests.test("Leurre r√©cup√®re carte", () => {
                gameState.playerA.ranged.cards = ['Archer'];
                gameState.playerA.hand = [];
                handleDecoy('A');
                assertEquals(gameState.playerA.hand.length, 1, "En main");
            });

            capacityTests.test("Corne active sur rang√©e", () => {
                gameState.playerA.melee.horn = false;
                handleHorn('A', 'melee');
                assertEquals(gameState.playerA.melee.horn, true, "Corne activ√©e");
                gameState.playerA.melee.horn = false;
            });

            suites.push(capacityTests);

            // ============ SUITE 9: SC√âNARIOS COMPLEXES ============
            const complexTests = new TestSuite("üé≠ Sc√©narios Complexes");
            
            complexTests.test("M√©t√©o + Lien + Corne combin√©s", () => {
                gameState.weather.frost = true;
                gameState.playerA.melee.cards = ['Fantassin', 'Fantassin'];
                gameState.playerA.melee.horn = true;
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 8, "((1*2)*2)*2=8");
                gameState.weather.frost = false;
                gameState.playerA.melee.horn = false;
            });

            complexTests.test("H√©ros + non-H√©ros avec m√©t√©o + corne", () => {
                gameState.weather.frost = true;
                gameState.playerA.melee.cards = ['Geralt de Riv', 'Chevalier'];
                gameState.playerA.melee.horn = true;
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 32, "(15+1)*2=32");
                gameState.weather.frost = false;
                gameState.playerA.melee.horn = false;
            });

            complexTests.test("3 rang√©es avec effets diff√©rents", () => {
                gameState.weather.frost = true;
                gameState.playerA.melee.cards = ['Fantassin', 'Fantassin'];
                gameState.playerA.ranged.cards = ['Archer'];
                gameState.playerA.ranged.horn = true;
                gameState.playerA.siege.cards = ['Catapulte'];
                
                const melee = calculateRowScore('A', 'melee');
                const ranged = calculateRowScore('A', 'ranged');
                const siege = calculateRowScore('A', 'siege');
                const total = calculateTotalScore('A');
                
                assertEquals(melee, 4, "M√™l√©e avec m√©t√©o");
                assertEquals(ranged, 6, "Distance avec corne");
                assertEquals(siege, 8, "Si√®ge normal");
                assertEquals(total, 18, "Total combin√©");
                
                gameState.weather.frost = false;
                gameState.playerA.ranged.horn = false;
            });

            complexTests.test("Toutes m√©t√©os actives simultan√©ment", () => {
                gameState.weather.frost = true;
                gameState.weather.fog = true;
                gameState.weather.rain = true;
                
                gameState.playerA.melee.cards = ['Chevalier'];
                gameState.playerA.ranged.cards = ['Archer'];
                gameState.playerA.siege.cards = ['Catapulte'];
                
                const total = calculateTotalScore('A');
                assertEquals(total, 3, "Toutes √† 1 = 3");
                
                gameState.weather = { frost: false, fog: false, rain: false };
            });

            complexTests.test("10 cartes avec Lien sur une rang√©e", () => {
                gameState.playerA.melee.cards = Array(10).fill('Fantassin');
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 20, "(1*2)*10=20");
            });

            suites.push(complexTests);

            // ============ SUITE 10: VALIDATION DES DONN√âES ============
            const validationTests = new TestSuite("‚úÖ Validation Donn√©es");
            
            validationTests.test("Toutes cartes ont une force", () => {
                Object.keys(CARD_DATABASE).forEach(name => {
                    assert(CARD_DATABASE[name].force !== undefined, `${name} a force`);
                });
            });

            validationTests.test("Toutes cartes ont rang√©e valide", () => {
                const validRows = ['melee', 'ranged', 'siege', 'special', 'weather', 'agile'];
                Object.keys(CARD_DATABASE).forEach(name => {
                    assert(validRows.includes(CARD_DATABASE[name].row), `${name} rang√©e valide`);
                });
            });

            validationTests.test("Toutes cartes ont capacit√©", () => {
                Object.keys(CARD_DATABASE).forEach(name => {
                    assert(CARD_DATABASE[name].capacity !== undefined, `${name} a capacit√©`);
                });
            });

            validationTests.test("H√©ros correctement marqu√©s", () => {
                const heroes = ['Geralt de Riv', 'Ciri', 'Yennefer', 'Triss'];
                heroes.forEach(name => {
                    assertEquals(CARD_DATABASE[name].isHero, true, `${name} est H√©ros`);
                });
            });

            validationTests.test("Factions d√©finies pour leaders", () => {
                const factions = ['RN', 'NG', 'Monstres', 'Scoia', 'Skellige'];
                factions.forEach(faction => {
                    assert(LEADERS[faction] !== undefined, `${faction} a leaders`);
                    assert(LEADERS[faction].length > 0, `${faction} a au moins 1 leader`);
                });
            });

            suites.push(validationTests);

            // ============ SUITE 11: SYST√àME DE TOUR ET PASSE ============
            const turnTests = new TestSuite("üîÑ Syst√®me de Tour et Passe");
            
            turnTests.test("Joueur actif initial", () => {
                assert(['A', 'B'].includes(gameState.activePlayer), "Joueur valide");
            });

            turnTests.test("Un joueur passe", () => {
                gameState.playerA.passed = false;
                gameState.playerA.passed = true;
                assertEquals(gameState.playerA.passed, true, "Pass√©");
            });

            turnTests.test("Les deux passent = fin d√©tect√©e", () => {
                gameState.playerA.passed = true;
                gameState.playerB.passed = true;
                const end = gameState.playerA.passed && gameState.playerB.passed;
                assertEquals(end, true, "Fin manche");
                gameState.playerA.passed = false;
                gameState.playerB.passed = false;
            });

            turnTests.test("Alternance joueur actif", () => {
                gameState.activePlayer = 'A';
                const next = gameState.activePlayer === 'A' ? 'B' : 'A';
                assertEquals(next, 'B', "Alternance A‚ÜíB");
            });

            turnTests.test("IA passe si main vide", () => {
                const aiHand = [];
                const shouldPass = aiHand.length === 0;
                assertEquals(shouldPass, true, "Main vide ‚Üí passe");
            });

            turnTests.test("IA passe si avance >10 points", () => {
                gameState.playerA.melee.cards = ['Archer'];
                gameState.playerB.melee.cards = ['Geralt de Riv', 'Ciri'];
                const scoreA = calculateTotalScore('A');
                const scoreB = calculateTotalScore('B');
                const shouldPass = scoreB > scoreA + 10;
                assertEquals(shouldPass, true, "30 vs 3 ‚Üí passe");
            });

            turnTests.test("IA continue si scores proches", () => {
                gameState.playerA.melee.cards = ['Geralt de Riv'];
                gameState.playerB.melee.cards = ['Ciri'];
                const scoreA = calculateTotalScore('A');
                const scoreB = calculateTotalScore('B');
                const shouldPass = scoreB > scoreA + 10;
                assertEquals(shouldPass, false, "15 vs 15 ‚Üí continue");
            });

            suites.push(turnTests);

            // ============ SUITE 12: BONUS DE FACTION ============
            const factionTests = new TestSuite("üè∞ Bonus de Faction");
            
            factionTests.test("Nilfgaard gagne en √©galit√©", () => {
                gameState.playerA.faction = 'NG';
                gameState.playerB.faction = 'RN';
                gameState.playerA.melee.cards = ['Archer'];
                gameState.playerB.melee.cards = ['Archer'];
                const scoreA = calculateTotalScore('A');
                const scoreB = calculateTotalScore('B');
                assertEquals(scoreA, scoreB, "√âgalit√©");
                // NG devrait gagner
            });

            factionTests.test("Royaumes du Nord pioche si victoire", () => {
                gameState.playerA.faction = 'RN';
                gameState.playerA.deck = ['Archer', 'Geralt de Riv'];
                const deckSize = gameState.playerA.deck.length;
                // Simuler victoire
                if (gameState.playerA.deck.length > 0) {
                    gameState.playerA.hand.push(gameState.playerA.deck.pop());
                }
                assertEquals(gameState.playerA.deck.length, deckSize - 1, "1 carte pioch√©e");
            });

            factionTests.test("Monstres conserve carte", () => {
                gameState.playerA.faction = 'Monstres';
                gameState.playerA.melee.cards = ['Archer', 'Geralt de Riv'];
                const allCards = [...gameState.playerA.melee.cards];
                const nonHeroes = allCards.filter(name => !CARD_DATABASE[name].isHero);
                assert(nonHeroes.length > 0, "Non-H√©ros disponibles");
            });

            factionTests.test("Scoia'tael choisit d√©but", () => {
                gameState.playerA.faction = 'Scoia';
                // Devrait pouvoir choisir activePlayer
                assert(['RN', 'NG', 'Monstres', 'Scoia', 'Skellige'].includes(gameState.playerA.faction), "Faction valide");
            });

            factionTests.test("Skellige ressuscite en manche 3", () => {
                gameState.currentRound = 3;
                gameState.playerA.faction = 'Skellige';
                gameState.playerA.graveyard = ['Archer', 'Chevalier', 'Fantassin'];
                const graveyardSize = gameState.playerA.graveyard.length;
                assert(graveyardSize >= 2, "Assez de cartes pour ressusciter");
            });

            suites.push(factionTests);

            // ============ SUITE 13: CAS LIMITES ============
            const edgeCaseTests = new TestSuite("‚ö†Ô∏è Cas Limites");
            
            edgeCaseTests.test("Plateau vide = 0 points", () => {
                gameState.playerA.melee.cards = [];
                gameState.playerA.ranged.cards = [];
                gameState.playerA.siege.cards = [];
                const score = calculateTotalScore('A');
                assertEquals(score, 0, "Plateau vide");
            });

            edgeCaseTests.test("Cimeti√®re avec 50+ cartes", () => {
                gameState.playerA.graveyard = Array(60).fill('Archer');
                assertEquals(gameState.playerA.graveyard.length, 60, "60 cartes");
            });

            edgeCaseTests.test("100 cartes identiques avec Lien", () => {
                gameState.playerA.melee.cards = Array(100).fill('Fantassin');
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 200, "(1*2)*100=200");
            });

            edgeCaseTests.test("Incin√©ration sur plateau vide", () => {
                gameState.playerA.melee.cards = [];
                gameState.playerB.melee.cards = [];
                const destroyed = handleScorch();
                assertEquals(destroyed, 0, "Rien √† d√©truire");
            });

            edgeCaseTests.test("Incin√©ration avec seulement H√©ros", () => {
                gameState.playerA.melee.cards = ['Geralt de Riv', 'Ciri'];
                gameState.playerB.ranged.cards = ['Yennefer'];
                const destroyed = handleScorch();
                assertEquals(destroyed, 0, "H√©ros √©pargn√©s");
            });

            edgeCaseTests.test("Score ne peut √™tre n√©gatif", () => {
                gameState.playerA.melee.cards = [];
                const score = calculateTotalScore('A');
                assert(score >= 0, "Score >= 0");
            });

            edgeCaseTests.test("Force 0 reste 0 avec corne", () => {
                gameState.playerA.melee.cards = [];
                gameState.playerA.melee.horn = true;
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 0, "0*2=0");
                gameState.playerA.melee.horn = false;
            });

            suites.push(edgeCaseTests);

            // ============ SUITE 14: COH√âRENCE DES R√àGLES ============
            const ruleTests = new TestSuite("üìú Coh√©rence des R√®gles");
            
            ruleTests.test("Froid affecte bien M√™l√©e", () => {
                gameState.weather.frost = true;
                gameState.playerA.melee.cards = ['Chevalier'];
                const force = calculateCardForce('A', 'melee', 'Chevalier');
                assertEquals(force, 1, "Froid ‚Üí M√™l√©e");
                gameState.weather.frost = false;
            });

            ruleTests.test("Brouillard affecte bien Distance", () => {
                gameState.weather.fog = true;
                gameState.playerA.ranged.cards = ['Archer'];
                const force = calculateCardForce('A', 'ranged', 'Archer');
                assertEquals(force, 1, "Brouillard ‚Üí Distance");
                gameState.weather.fog = false;
            });

            ruleTests.test("Pluie affecte bien Si√®ge", () => {
                gameState.weather.rain = true;
                gameState.playerA.siege.cards = ['Catapulte'];
                const force = calculateCardForce('A', 'siege', 'Catapulte');
                assertEquals(force, 1, "Pluie ‚Üí Si√®ge");
                gameState.weather.rain = false;
            });

            ruleTests.test("M√©t√©o n'affecte pas mauvaise rang√©e", () => {
                gameState.weather.frost = true;
                gameState.playerA.ranged.cards = ['Archer'];
                const force = calculateCardForce('A', 'ranged', 'Archer');
                assertEquals(force, 3, "Froid n'affecte pas Distance");
                gameState.weather.frost = false;
            });

            ruleTests.test("Ordre: M√©t√©o ‚Üí Lien ‚Üí Corne", () => {
                gameState.weather.frost = true;
                gameState.playerA.melee.cards = ['Fantassin', 'Fantassin'];
                gameState.playerA.melee.horn = true;
                
                // 1. M√©t√©o: 1
                // 2. Lien: 1*2 = 2 par carte
                // 3. Total: 2*2 = 4
                // 4. Corne: 4*2 = 8
                const score = calculateRowScore('A', 'melee');
                assertEquals(score, 8, "Ordre correct");
                
                gameState.weather.frost = false;
                gameState.playerA.melee.horn = false;
            });

            ruleTests.test("Lien n√©cessite 2+ cartes", () => {
                gameState.playerA.melee.cards = ['Fantassin'];
                const copies = gameState.playerA.melee.cards.filter(c => c === 'Fantassin');
                const hasBonus = copies.length > 1;
                assertEquals(hasBonus, false, "1 carte = pas de bonus");
            });

            suites.push(ruleTests);

            // ============ SUITE 15: TESTS D'INT√âGRATION ============
            const integrationTests = new TestSuite("üîó Tests d'Int√©gration");
            
            integrationTests.test("Partie compl√®te: √©tat initial", () => {
                assertEquals(gameState.currentRound, 1, "Manche 1");
                assertEquals(gameState.roundsWon.A, 0, "0-0");
                assertEquals(gameState.roundsWon.B, 0, "0-0");
            });

            integrationTests.test("√âtat coh√©rent apr√®s nettoyage", () => {
                gameState.playerA.melee.cards = ['Archer'];
                const before = [...gameState.playerA.melee.cards];
                
                // Simuler nettoyage
                gameState.playerA.melee.cards.forEach(card => {
                    gameState.playerA.graveyard.push(card);
                });
                gameState.playerA.melee.cards = [];
                
                assertEquals(gameState.playerA.melee.cards.length, 0, "Rang√©e vid√©e");
                assert(gameState.playerA.graveyard.length > 0, "Au cimeti√®re");
            });

            integrationTests.test("Cornes retir√©es entre manches", () => {
                gameState.playerA.melee.horn = true;
                gameState.playerA.ranged.horn = true;
                
                ['melee', 'ranged', 'siege'].forEach(row => {
                    gameState.playerA[row].horn = false;
                });
                
                assertEquals(gameState.playerA.melee.horn, false, "Corne retir√©e");
            });

            integrationTests.test("Victoire en 2 manches", () => {
                gameState.roundsWon.A = 2;
                const isGameOver = gameState.roundsWon.A >= 2;
                assertEquals(isGameOver, true, "Victoire 2 manches");
            });

            integrationTests.test("Compteurs ne d√©bordent pas", () => {
                gameState.turnCount = 999;
                gameState.turnCount++;
                assertEquals(gameState.turnCount, 1000, "Compteur OK");
                gameState.turnCount = 0;
            });

            suites.push(integrationTests);

            // ============ SUITE 16: TESTS DE R√âGRESSION ============
            const regressionTests = new TestSuite("üîÑ Tests de R√©gression");
            
            regressionTests.test("Cartes ne disparaissent pas", () => {
                gameState.playerA.melee.cards = ['Archer', 'Geralt de Riv'];
                const cardCount = gameState.playerA.melee.cards.length;
                
                // Simuler d√©placement
                gameState.playerA.melee.cards.forEach(card => {
                    gameState.playerA.graveyard.push(card);
                });
                gameState.playerA.melee.cards = [];
                
                assertEquals(gameState.playerA.graveyard.length, cardCount, "Cartes conserv√©es");
            });

            regressionTests.test("√âtat inchang√© apr√®s passe", () => {
                const handBefore = [...gameState.playerA.hand];
                gameState.playerA.passed = true;
                assertArrayEquals(gameState.playerA.hand, handBefore, "Main inchang√©e");
                gameState.playerA.passed = false;
            });

            regressionTests.test("M√©t√©o coh√©rente apr√®s Clear", () => {
                gameState.weather.frost = true;
                gameState.weather.fog = true;
                handleClearWeather();
                
                assertEquals(gameState.weather.frost, false, "Froid annul√©");
                assertEquals(gameState.weather.fog, false, "Brouillard annul√©");
                assertEquals(gameState.weather.rain, false, "Pluie annul√©e");
            });

            regressionTests.test("Corne n'affecte pas autres joueurs", () => {
                gameState.playerA.melee.horn = true;
                gameState.playerB.melee.horn = false;
                
                gameState.playerA.melee.cards = ['Archer'];
                gameState.playerB.melee.cards = ['Archer'];
                
                const scoreA = calculateRowScore('A', 'melee');
                const scoreB = calculateRowScore('B', 'melee');
                
                assertEquals(scoreA, 6, "A avec corne");
                assertEquals(scoreB, 3, "B sans corne");
                
                gameState.playerA.melee.horn = false;
            });

            suites.push(regressionTests);

            return suites;
        }

        // =====================================================================
        // NETTOYAGE DE L'√âTAT ENTRE TESTS
        // =====================================================================

        function resetGameState() {
            gameState.playerA.melee.cards = [];
            gameState.playerA.ranged.cards = [];
            gameState.playerA.siege.cards = [];
            gameState.playerA.melee.horn = false;
            gameState.playerA.ranged.horn = false;
            gameState.playerA.siege.horn = false;
            gameState.playerA.hand = [];
            gameState.playerA.deck = [];
            gameState.playerA.graveyard = [];
            gameState.playerA.passed = false;
            
            gameState.playerB.melee.cards = [];
            gameState.playerB.ranged.cards = [];
            gameState.playerB.siege.cards = [];
            gameState.playerB.melee.horn = false;
            gameState.playerB.ranged.horn = false;
            gameState.playerB.siege.horn = false;
            gameState.playerB.hand = [];
            gameState.playerB.deck = [];
            gameState.playerB.graveyard = [];
            gameState.playerB.passed = false;
            
            gameState.weather = { frost: false, fog: false, rain: false };
            gameState.currentRound = 1;
            gameState.turnCount = 0;
            gameState.roundsWon = { A: 0, B: 0 };
        }

        // =====================================================================
        // EX√âCUTION DES TESTS
        // =====================================================================

        let currentFilter = 'all';

        async function runAllTests() {
            const resultsContainer = document.getElementById('test-results');
            const summaryDiv = document.getElementById('summary');
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const filterButtons = document.getElementById('filter-buttons');
            
            resultsContainer.innerHTML = '';
            progressContainer.style.display = 'block';
            filterButtons.style.display = 'none';
            
            let totalTests = 0;
            let totalPassed = 0;
            let totalFailed = 0;
            
            const allSuites = defineAllTests();
            const totalSuites = allSuites.length;
            
            for (let i = 0; i < allSuites.length; i++) {
                const suite = allSuites[i];
                
                // Mettre √† jour la progression
                const progress = Math.round(((i + 1) / totalSuites) * 100);
                progressBar.style.width = progress + '%';
                progressBar.textContent = progress + '%';
                
                const suiteDiv = document.createElement('div');
                suiteDiv.className = 'test-suite';
                
                const suiteTitle = document.createElement('h2');
                suiteTitle.textContent = suite.name;
                suiteDiv.appendChild(suiteTitle);
                
                const results = await suite.run();
                
                results.forEach(result => {
                    totalTests++;
                    if (result.status === 'pass') totalPassed++;
                    else totalFailed++;
                    
                    const testDiv = document.createElement('div');
                    testDiv.className = `test-case ${result.status}`;
                    testDiv.setAttribute('data-status', result.status);
                    
                    const testName = document.createElement('div');
                    testName.className = 'test-name';
                    testName.innerHTML = `
                        <span class="test-result ${result.status}">
                            ${result.status === 'pass' ? '‚úì PASS' : '‚úó FAIL'}
                        </span>
                        ${result.name}
                    `;
                    testDiv.appendChild(testName);
                    
                    if (result.error) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'test-error';
                        errorDiv.textContent = result.error;
                        testDiv.appendChild(errorDiv);
                    }
                    
                    suiteDiv.appendChild(testDiv);
                    
                    // Nettoyer l'√©tat entre chaque test
                    resetGameState();
                });
                
                const suiteStats = document.createElement('div');
                suiteStats.className = 'suite-stats';
                const passRate = Math.round((suite.passed / suite.tests.length) * 100);
                suiteStats.innerHTML = `
                    <strong>Suite:</strong> ${suite.passed} ‚úì / ${suite.failed} ‚úó sur ${suite.tests.length} tests
                    <span style="margin-left: 20px; color: ${passRate === 100 ? '#4caf50' : '#ff9800'};">
                        Taux de r√©ussite: ${passRate}%
                    </span>
                `;
                suiteDiv.appendChild(suiteStats);
                
                resultsContainer.appendChild(suiteDiv);
                
                // Petite pause pour √©viter de bloquer le navigateur
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            // Masquer la barre de progression
            progressContainer.style.display = 'none';
            
            // Afficher le r√©sum√©
            summaryDiv.style.display = 'block';
            filterButtons.style.display = 'block';
            document.getElementById('total-tests').textContent = totalTests;
            document.getElementById('passed-tests').textContent = totalPassed;
            document.getElementById('failed-tests').textContent = totalFailed;
            
            // Scroll vers le r√©sum√©
            summaryDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // Message console
            const passRate = Math.round((totalPassed / totalTests) * 100);
            console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë     R√âSULTATS DES TESTS GWENT         ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Total:    ${totalTests.toString().padStart(3)} tests                 ‚ïë
‚ïë R√©ussis:  ${totalPassed.toString().padStart(3)} tests (${passRate}%)        ‚ïë
‚ïë √âchou√©s:  ${totalFailed.toString().padStart(3)} tests                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
            `);
            
            if (totalFailed === 0) {
                console.log('‚úÖ TOUS LES TESTS SONT PASS√âS !');
            } else {
                console.warn(`‚ö†Ô∏è ${totalFailed} test(s) ont √©chou√©. V√©rifiez les d√©tails ci-dessus.`);
            }
        }

        function filterTests(filter) {
            currentFilter = filter;
            
            // Mettre √† jour les boutons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Filtrer les tests
            document.querySelectorAll('.test-case').forEach(testCase => {
                const status = testCase.getAttribute('data-status');
                
                if (filter === 'all') {
                    testCase.style.display = 'block';
                } else if (filter === status) {
                    testCase.style.display = 'block';
                } else {
                    testCase.style.display = 'none';
                }
            });
        }

        // =====================================================================
        // INITIALISATION
        // =====================================================================

        window.addEventListener('DOMContentLoaded', () => {
            if (typeof CARD_DATABASE === 'undefined' || typeof gameState === 'undefined') {
                alert('‚ùå ERREUR: Le fichier gwent-engine.js n\'est pas charg√© correctement.\n\nAssurez-vous que le fichier est dans le m√™me r√©pertoire.');
                document.querySelector('.run-button').disabled = true;
            } else {
                console.log('‚úÖ Moteur Gwent charg√© avec succ√®s');
                console.log('üì¶ Cartes disponibles:', Object.keys(CARD_DATABASE).length);
                console.log('üéÆ Cliquez sur "Lancer tous les tests" pour commencer');
            }
        });
    </script>
</body>
</html>