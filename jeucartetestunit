<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tests Unitaires Gwent</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            color: #ffcc00;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-suite {
            background: #2c2c2c;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 5px solid #2196f3;
        }
        .test-suite h2 {
            color: #2196f3;
            margin-top: 0;
        }
        .test-case {
            background: #1a1a1a;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 3px solid #666;
        }
        .test-case.pass {
            border-left-color: #4caf50;
        }
        .test-case.fail {
            border-left-color: #f44336;
        }
        .test-name {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .test-result {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }
        .test-result.pass {
            background: #4caf50;
            color: white;
        }
        .test-result.fail {
            background: #f44336;
            color: white;
        }
        .test-details {
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
        }
        .test-error {
            color: #ff8a80;
            margin-top: 5px;
            font-style: italic;
        }
        .summary {
            background: #2c2c2c;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 30px;
        }
        .summary h2 {
            color: #ffcc00;
            margin: 0 0 15px 0;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
        }
        .stat {
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
        }
        .stat-pass {
            background: #4caf50;
        }
        .stat-fail {
            background: #f44336;
        }
        .stat-total {
            background: #2196f3;
        }
        .run-button {
            display: block;
            margin: 30px auto;
            padding: 15px 40px;
            font-size: 18px;
            background: #ffcc00;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            color: #000;
            font-weight: bold;
        }
        .run-button:hover {
            background: #ffd966;
        }
        .code-block {
            background: #0d0d0d;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 11px;
            margin-top: 5px;
        }
        .assertion {
            color: #64b5f6;
        }
        .expected {
            color: #81c784;
        }
        .actual {
            color: #e57373;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ GWENT - Suite de Tests Unitaires Compl√®te</h1>
        
        <button class="run-button" onclick="runAllTests()">‚ñ∂Ô∏è Lancer tous les tests</button>
        
        <div class="summary" id="summary" style="display: none;">
            <h2>üìä R√©sum√© des Tests</h2>
            <div class="stats">
                <div class="stat stat-total">
                    <div>Total</div>
                    <div id="total-tests" style="font-size: 24px; font-weight: bold;">0</div>
                </div>
                <div class="stat stat-pass">
                    <div>‚úì R√©ussis</div>
                    <div id="passed-tests" style="font-size: 24px; font-weight: bold;">0</div>
                </div>
                <div class="stat stat-fail">
                    <div>‚úó √âchou√©s</div>
                    <div id="failed-tests" style="font-size: 24px; font-weight: bold;">0</div>
                </div>
            </div>
        </div>
        
        <div id="test-results"></div>
    </div>

    <script>
        // =====================================================================
        // MOTEUR DE JEU SIMPLIFI√â POUR LES TESTS
        // =====================================================================
        
        const CARD_DATABASE = {
            "Geralt": { faction: "Neutre", force: 15, row: "melee", capacity: "Hero", isHero: true },
            "Ciri": { faction: "Neutre", force: 15, row: "melee", capacity: "Hero", isHero: true },
            "Yennefer": { faction: "Neutre", force: 7, row: "ranged", capacity: "Heal", isHero: true },
            "Triss": { faction: "Neutre", force: 7, row: "melee", capacity: "Rally", isHero: true },
            "Vesemir": { faction: "Neutre", force: 6, row: "melee", capacity: "Rally", isHero: false },
            "Zoltan": { faction: "Neutre", force: 5, row: "melee", capacity: "Rally", isHero: false },
            "Scorch": { faction: "Neutre", force: 0, row: "special", capacity: "Scorch", isHero: false },
            "Decoy": { faction: "Neutre", force: 0, row: "special", capacity: "Decoy", isHero: false },
            "Horn": { faction: "Neutre", force: 0, row: "special", capacity: "Horn", isHero: false },
            "Frost": { faction: "Neutre", force: 0, row: "weather", capacity: "Frost", isHero: false },
            "Fog": { faction: "Neutre", force: 0, row: "weather", capacity: "Fog", isHero: false },
            "Rain": { faction: "Neutre", force: 0, row: "weather", capacity: "Rain", isHero: false },
            "Clear": { faction: "Neutre", force: 0, row: "weather", capacity: "Clear", isHero: false },
            "Fantassin": { faction: "RN", force: 1, row: "melee", capacity: "TightBond", isHero: false },
            "Archer": { faction: "RN", force: 3, row: "ranged", capacity: "None", isHero: false },
            "Catapulte": { faction: "RN", force: 8, row: "siege", capacity: "TightBond", isHero: false },
            "Dijkstra": { faction: "RN", force: 4, row: "melee", capacity: "Spy", isHero: false },
            "Medic RN": { faction: "RN", force: 5, row: "melee", capacity: "Medic", isHero: false },
            "Brigade": { faction: "NG", force: 5, row: "melee", capacity: "TightBond", isHero: false },
            "Vattier": { faction: "NG", force: 4, row: "melee", capacity: "Spy", isHero: false },
            "Nekker": { faction: "Monstres", force: 2, row: "melee", capacity: "Muster", isHero: false },
            "Ghoul": { faction: "Monstres", force: 1, row: "melee", capacity: "Medic", isHero: false },
            "Elfe Tireur": { faction: "Scoia", force: 2, row: "agile", capacity: "Agile", isHero: false },
            "Berserker": { faction: "Skellige", force: 4, row: "melee", capacity: "Berserk", isHero: false },
        };

        function createGameState() {
            return {
                currentRound: 1,
                turnCount: 0,
                roundsWon: { A: 0, B: 0 },
                playerA: {
                    faction: 'RN',
                    hand: [],
                    deck: [],
                    graveyard: [],
                    passed: false,
                    melee: { cards: [], horn: false },
                    ranged: { cards: [], horn: false },
                    siege: { cards: [], horn: false }
                },
                playerB: {
                    faction: 'NG',
                    hand: [],
                    deck: [],
                    graveyard: [],
                    passed: false,
                    melee: { cards: [], horn: false },
                    ranged: { cards: [], horn: false },
                    siege: { cards: [], horn: false }
                },
                weather: { frost: false, fog: false, rain: false },
                activePlayer: 'A'
            };
        }

        function calculateCardForce(gameState, player, row, cardName) {
            const card = CARD_DATABASE[cardName];
            if (card.isHero) return card.force;
            
            let force = card.force;
            if (row === 'melee' && gameState.weather.frost) force = 1;
            if (row === 'ranged' && gameState.weather.fog) force = 1;
            if (row === 'siege' && gameState.weather.rain) force = 1;
            
            return force;
        }

        function calculateRowScore(gameState, player, row) {
            const p = gameState[`player${player}`];
            const rowData = p[row];
            let score = 0;
            const processed = new Set();
            
            rowData.cards.forEach(cardName => {
                if (processed.has(cardName)) return;
                
                const card = CARD_DATABASE[cardName];
                const baseForce = calculateCardForce(gameState, player, row, cardName);
                
                if (card.capacity === 'TightBond') {
                    const copies = rowData.cards.filter(c => c === cardName);
                    if (copies.length > 1) {
                        score += baseForce * 2 * copies.length;
                        copies.forEach(c => processed.add(c));
                    } else {
                        score += baseForce;
                        processed.add(cardName);
                    }
                } else {
                    score += baseForce;
                    processed.add(cardName);
                }
            });
            
            if (rowData.horn) score *= 2;
            return score;
        }

        function calculateTotalScore(gameState, player) {
            return calculateRowScore(gameState, player, 'melee') + 
                   calculateRowScore(gameState, player, 'ranged') + 
                   calculateRowScore(gameState, player, 'siege');
        }

        function handleScorch(gameState) {
            let maxForce = 0;
            const allCards = [];
            
            ['A', 'B'].forEach(pl => {
                ['melee', 'ranged', 'siege'].forEach(row => {
                    gameState[`player${pl}`][row].cards.forEach(name => {
                        const card = CARD_DATABASE[name];
                        if (!card.isHero) {
                            const force = calculateCardForce(gameState, pl, row, name);
                            allCards.push({ player: pl, row, name, force });
                            if (force > maxForce) maxForce = force;
                        }
                    });
                });
            });
            
            const toDestroy = allCards.filter(c => c.force === maxForce);
            toDestroy.forEach(({ player, row, name }) => {
                const p = gameState[`player${player}`];
                p[row].cards = p[row].cards.filter(c => c !== name);
                p.graveyard.push(name);
            });
            
            return toDestroy.length;
        }

        function placeCard(gameState, player, cardName, row) {
            const card = CARD_DATABASE[cardName];
            const p = gameState[`player${player}`];
            const rowKey = row || card.row;
            
            if (p[rowKey]) {
                p[rowKey].cards.push(cardName);
            }
        }

        // =====================================================================
        // FRAMEWORK DE TESTS
        // =====================================================================

        class TestSuite {
            constructor(name) {
                this.name = name;
                this.tests = [];
                this.passed = 0;
                this.failed = 0;
            }

            test(name, fn) {
                this.tests.push({ name, fn });
            }

            async run() {
                const results = [];
                
                for (const test of this.tests) {
                    try {
                        await test.fn();
                        this.passed++;
                        results.push({
                            name: test.name,
                            status: 'pass',
                            error: null
                        });
                    } catch (error) {
                        this.failed++;
                        results.push({
                            name: test.name,
                            status: 'fail',
                            error: error.message
                        });
                    }
                }
                
                return results;
            }
        }

        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        function assertEquals(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(
                    `${message || 'Values not equal'}\nExpected: ${expected}\nActual: ${actual}`
                );
            }
        }

        function assertArrayEquals(actual, expected, message) {
            if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                throw new Error(
                    `${message || 'Arrays not equal'}\nExpected: ${JSON.stringify(expected)}\nActual: ${JSON.stringify(actual)}`
                );
            }
        }

        function assertGreaterThan(actual, expected, message) {
            if (actual <= expected) {
                throw new Error(
                    `${message || 'Value not greater'}\nExpected > ${expected}\nActual: ${actual}`
                );
            }
        }

        // =====================================================================
        // SUITE 1: CALCUL DE SCORE DE BASE
        // =====================================================================

        const scoreTests = new TestSuite("üìä Calcul de Score de Base");

        scoreTests.test("Carte simple sans effet", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Archer', 'ranged');
            const score = calculateRowScore(state, 'A', 'ranged');
            assertEquals(score, 3, "Score d'une carte simple");
        });

        scoreTests.test("Carte H√©ros immunis√©e √† la m√©t√©o", () => {
            const state = createGameState();
            state.weather.frost = true;
            placeCard(state, 'A', 'Geralt', 'melee');
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 15, "H√©ros non affect√© par m√©t√©o");
        });

        scoreTests.test("Multiple cartes sans effet", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Archer', 'ranged');
            placeCard(state, 'A', 'Archer', 'ranged');
            const score = calculateRowScore(state, 'A', 'ranged');
            assertEquals(score, 6, "Score de 2 cartes identiques sans lien");
        });

        scoreTests.test("Score total sur toutes les rang√©es", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Geralt', 'melee');
            placeCard(state, 'A', 'Archer', 'ranged');
            placeCard(state, 'A', 'Catapulte', 'siege');
            const total = calculateTotalScore(state, 'A');
            assertEquals(total, 26, "Score total (15+3+8)");
        });

        scoreTests.test("Score de plusieurs joueurs ind√©pendants", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Geralt', 'melee');
            placeCard(state, 'B', 'Archer', 'ranged');
            const scoreA = calculateTotalScore(state, 'A');
            const scoreB = calculateTotalScore(state, 'B');
            assertEquals(scoreA, 15, "Score joueur A");
            assertEquals(scoreB, 3, "Score joueur B");
        });

        // =====================================================================
        // SUITE 2: LIEN RAPPROCH√â (TIGHT BOND)
        // =====================================================================

        const tightBondTests = new TestSuite("üîó Lien Rapproch√© (Tight Bond)");

        tightBondTests.test("Une seule carte Lien Rapproch√©", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Fantassin', 'melee');
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 1, "Une seule carte = force normale");
        });

        tightBondTests.test("Deux cartes Lien Rapproch√© identiques", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Fantassin', 'melee');
            placeCard(state, 'A', 'Fantassin', 'melee');
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 4, "2 cartes force 1 ‚Üí (1*2)*2 = 4");
        });

        tightBondTests.test("Trois cartes Lien Rapproch√© identiques", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Fantassin', 'melee');
            placeCard(state, 'A', 'Fantassin', 'melee');
            placeCard(state, 'A', 'Fantassin', 'melee');
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 6, "3 cartes force 1 ‚Üí (1*2)*3 = 6");
        });

        tightBondTests.test("Deux paires diff√©rentes de Lien Rapproch√©", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Fantassin', 'melee');
            placeCard(state, 'A', 'Fantassin', 'melee');
            placeCard(state, 'A', 'Brigade', 'melee');
            placeCard(state, 'A', 'Brigade', 'melee');
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 24, "(1*2)*2 + (5*2)*2 = 4 + 20 = 24");
        });

        tightBondTests.test("Lien Rapproch√© avec carte normale", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Fantassin', 'melee');
            placeCard(state, 'A', 'Fantassin', 'melee');
            placeCard(state, 'A', 'Archer', 'melee');
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 7, "(1*2)*2 + 3 = 7");
        });

        // =====================================================================
        // SUITE 3: CORNE DE COMMANDANT
        // =====================================================================

        const hornTests = new TestSuite("üìØ Corne de Commandant");

        hornTests.test("Corne double une carte simple", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Archer', 'ranged');
            state.playerA.ranged.horn = true;
            const score = calculateRowScore(state, 'A', 'ranged');
            assertEquals(score, 6, "3 * 2 = 6");
        });

        hornTests.test("Corne avec H√©ros (devrait doubler)", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Geralt', 'melee');
            state.playerA.melee.horn = true;
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 30, "15 * 2 = 30");
        });

        hornTests.test("Corne avec Lien Rapproch√©", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Fantassin', 'melee');
            placeCard(state, 'A', 'Fantassin', 'melee');
            state.playerA.melee.horn = true;
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 8, "((1*2)*2) * 2 = 8");
        });

        hornTests.test("Corne avec plusieurs cartes", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Archer', 'ranged');
            placeCard(state, 'A', 'Archer', 'ranged');
            placeCard(state, 'A', 'Archer', 'ranged');
            state.playerA.ranged.horn = true;
            const score = calculateRowScore(state, 'A', 'ranged');
            assertEquals(score, 18, "(3+3+3) * 2 = 18");
        });

        hornTests.test("Corne n'affecte qu'une seule rang√©e", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Archer', 'ranged');
            placeCard(state, 'A', 'Geralt', 'melee');
            state.playerA.ranged.horn = true;
            const scoreRanged = calculateRowScore(state, 'A', 'ranged');
            const scoreMelee = calculateRowScore(state, 'A', 'melee');
            assertEquals(scoreRanged, 6, "Rang√©e avec corne");
            assertEquals(scoreMelee, 15, "Rang√©e sans corne");
        });

        // =====================================================================
        // SUITE 4: M√âT√âO
        // =====================================================================

        const weatherTests = new TestSuite("üå¶Ô∏è Effets M√©t√©o");

        weatherTests.test("Froid Mordant r√©duit M√™l√©e √† 1", () => {
            const state = createGameState();
            state.weather.frost = true;
            placeCard(state, 'A', 'Archer', 'melee');
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 1, "Force r√©duite √† 1 par le froid");
        });

        weatherTests.test("Brouillard r√©duit Distance √† 1", () => {
            const state = createGameState();
            state.weather.fog = true;
            placeCard(state, 'A', 'Archer', 'ranged');
            const score = calculateRowScore(state, 'A', 'ranged');
            assertEquals(score, 1, "Force r√©duite √† 1 par le brouillard");
        });

        weatherTests.test("Pluie r√©duit Si√®ge √† 1", () => {
            const state = createGameState();
            state.weather.rain = true;
            placeCard(state, 'A', 'Catapulte', 'siege');
            const score = calculateRowScore(state, 'A', 'siege');
            assertEquals(score, 1, "Force r√©duite √† 1 par la pluie");
        });

        weatherTests.test("M√©t√©o n'affecte pas les H√©ros", () => {
            const state = createGameState();
            state.weather.frost = true;
            placeCard(state, 'A', 'Geralt', 'melee');
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 15, "H√©ros immunis√© √† la m√©t√©o");
        });

        weatherTests.test("M√©t√©o avec Lien Rapproch√©", () => {
            const state = createGameState();
            state.weather.frost = true;
            placeCard(state, 'A', 'Fantassin', 'melee');
            placeCard(state, 'A', 'Fantassin', 'melee');
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 4, "M√©t√©o puis Lien: (1*2)*2 = 4");
        });

        weatherTests.test("M√©t√©o affecte les deux joueurs", () => {
            const state = createGameState();
            state.weather.frost = true;
            placeCard(state, 'A', 'Archer', 'melee');
            placeCard(state, 'B', 'Archer', 'melee');
            const scoreA = calculateRowScore(state, 'A', 'melee');
            const scoreB = calculateRowScore(state, 'B', 'melee');
            assertEquals(scoreA, 1, "Joueur A affect√©");
            assertEquals(scoreB, 1, "Joueur B affect√©");
        });

        weatherTests.test("Temps D√©gag√© annule toutes les m√©t√©os", () => {
            const state = createGameState();
            state.weather.frost = true;
            state.weather.fog = true;
            state.weather.rain = true;
            state.weather = { frost: false, fog: false, rain: false };
            placeCard(state, 'A', 'Archer', 'melee');
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 3, "Force normale apr√®s Temps D√©gag√©");
        });

        // =====================================================================
        // SUITE 5: INCIN√âRATION (SCORCH)
        // =====================================================================

        const scorchTests = new TestSuite("üî• Incin√©ration");

        scorchTests.test("Incin√©ration d√©truit la carte la plus forte", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Geralt', 'melee');
            placeCard(state, 'A', 'Archer', 'ranged');
            placeCard(state, 'B', 'Catapulte', 'siege');
            const destroyed = handleScorch(state);
            assertEquals(destroyed, 1, "1 carte d√©truite");
            assertEquals(state.playerA.melee.cards.length, 1, "Geralt non d√©truit (H√©ros)");
            assertEquals(state.playerB.siege.cards.length, 0, "Catapulte d√©truite (8 force)");
        });

        scorchTests.test("Incin√©ration ne touche pas les H√©ros", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Geralt', 'melee');
            placeCard(state, 'B', 'Archer', 'ranged');
            const destroyed = handleScorch(state);
            assertEquals(destroyed, 1, "Seule la carte non-H√©ros d√©truite");
            assertEquals(state.playerA.melee.cards.length, 1, "Geralt intact");
            assertEquals(state.playerB.ranged.cards.length, 0, "Archer d√©truit");
        });

        scorchTests.test("Incin√©ration d√©truit plusieurs cartes √©gales", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Catapulte', 'siege');
            placeCard(state, 'B', 'Catapulte', 'siege');
            const destroyed = handleScorch(state);
            assertEquals(destroyed, 2, "2 cartes d√©truites");
            assertEquals(state.playerA.siege.cards.length, 0, "Catapulte A d√©truite");
            assertEquals(state.playerB.siege.cards.length, 0, "Catapulte B d√©truite");
        });

        scorchTests.test("Cartes d√©truites vont au cimeti√®re", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Catapulte', 'siege');
            handleScorch(state);
            assertEquals(state.playerA.graveyard.length, 1, "1 carte au cimeti√®re");
            assertEquals(state.playerA.graveyard[0], 'Catapulte', "Bonne carte au cimeti√®re");
        });

        // =====================================================================
        // SUITE 6: GESTION DES MANCHES
        // =====================================================================

        const roundTests = new TestSuite("üéØ Gestion des Manches");

        roundTests.test("√âtat initial du jeu", () => {
            const state = createGameState();
            assertEquals(state.currentRound, 1, "Commence √† la manche 1");
            assertEquals(state.roundsWon.A, 0, "Joueur A: 0 victoire");
            assertEquals(state.roundsWon.B, 0, "Joueur B: 0 victoire");
        });

        roundTests.test("D√©termination du vainqueur par score", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Geralt', 'melee');
            placeCard(state, 'B', 'Archer', 'ranged');
            const scoreA = calculateTotalScore(state, 'A');
            const scoreB = calculateTotalScore(state, 'B');
            assert(scoreA > scoreB, "Joueur A devrait gagner");
        });

        roundTests.test("Bonus Nilfgaard: gagne en cas d'√©galit√©", () => {
            const state = createGameState();
            state.playerA.faction = 'RN';
            state.playerB.faction = 'NG';
            placeCard(state, 'A', 'Archer', 'ranged');
            placeCard(state, 'B', 'Archer', 'ranged');
            const scoreA = calculateTotalScore(state, 'A');
            const scoreB = calculateTotalScore(state, 'B');
            assertEquals(scoreA, scoreB, "Scores √©gaux");
            // NG devrait gagner (√† impl√©menter dans la logique de fin de manche)
        });

        roundTests.test("Cartes d√©plac√©es au cimeti√®re apr√®s manche", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Archer', 'ranged');
            placeCard(state, 'A', 'Geralt', 'melee');
            
            // Simuler fin de manche
            ['melee', 'ranged', 'siege'].forEach(row => {
                state.playerA[row].cards.forEach(card => {
                    state.playerA.graveyard.push(card);
                });
                state.playerA[row].cards = [];
            });
            
            assertEquals(state.playerA.graveyard.length, 2, "2 cartes au cimeti√®re");
            assertEquals(state.playerA.melee.cards.length, 0, "M√™l√©e vid√©e");
            assertEquals(state.playerA.ranged.cards.length, 0, "Distance vid√©e");
        });

        roundTests.test("Cornes retir√©es entre les manches", () => {
            const state = createGameState();
            state.playerA.melee.horn = true;
            state.playerA.ranged.horn = true;
            
            // Simuler nettoyage de manche
            ['melee', 'ranged', 'siege'].forEach(row => {
                state.playerA[row].horn = false;
            });
            
            assertEquals(state.playerA.melee.horn, false, "Corne M√™l√©e retir√©e");
            assertEquals(state.playerA.ranged.horn, false, "Corne Distance retir√©e");
        });

        // =====================================================================
        // SUITE 7: DISTRIBUTION INITIALE ET MULLIGAN
        // =====================================================================

        const initialTests = new TestSuite("üé¥ Distribution Initiale et Mulligan");

        initialTests.test("Chaque joueur re√ßoit 10 cartes", () => {
            const state = createGameState();
            const cards = ['Archer', 'Geralt', 'Ciri', 'Vesemir', 'Zoltan', 'Fantassin', 'Catapulte', 'Horn', 'Frost', 'Scorch'];
            state.playerA.hand = [...cards];
            state.playerB.hand = [...cards];
            
            assertEquals(state.playerA.hand.length, 10, "Joueur A: 10 cartes");
            assertEquals(state.playerB.hand.length, 10, "Joueur B: 10 cartes");
        });

        initialTests.test("Mulligan: √©changer maximum 2 cartes", () => {
            const state = createGameState();
            state.playerA.hand = ['Archer', 'Geralt', 'Ciri', 'Vesemir'];
            state.playerA.deck = ['Zoltan', 'Fantassin', 'Catapulte'];
            
            // Simuler mulligan de 2 cartes
            const toExchange = ['Archer', 'Vesemir'];
            toExchange.forEach(card => {
                const idx = state.playerA.hand.indexOf(card);
                state.playerA.hand.splice(idx, 1);
                state.playerA.deck.push(card);
            });
            
            // Piocher 2 nouvelles
            for (let i = 0; i < 2; i++) {
                state.playerA.hand.push(state.playerA.deck.pop());
            }
            
            assertEquals(state.playerA.hand.length, 4, "Toujours 4 cartes apr√®s mulligan");
            assert(state.playerA.hand.includes('Geralt'), "Geralt conserv√©");
            assert(state.playerA.hand.includes('Ciri'), "Ciri conserv√©e");
        });

        initialTests.test("Mulligan: peut √©changer 0 carte", () => {
            const state = createGameState();
            state.playerA.hand = ['Archer', 'Geralt', 'Ciri'];
            const originalHand = [...state.playerA.hand];
            
            // Pas d'√©change
            assertArrayEquals(state.playerA.hand, originalHand, "Main inchang√©e");
        });

        initialTests.test("Bonus Scoia'tael: choisit qui commence", () => {
            const state = createGameState();
            state.playerA.faction = 'Scoia';
            // Le joueur Scoia'tael devrait pouvoir choisir
            state.activePlayer = 'A'; // Choix du joueur
            assertEquals(state.activePlayer, 'A', "Scoia'tael commence");
        });

        // =====================================================================
        // SUITE 8: CAPACIT√âS SP√âCIALES
        // =====================================================================

        const capacityTests = new TestSuite("‚ö° Capacit√©s Sp√©ciales");

        capacityTests.test("Espion: plac√© chez l'adversaire", () => {
            const state = createGameState();
            // Simuler Espion
            placeCard(state, 'B', 'Dijkstra', 'melee'); // Plac√© chez B au lieu de A
            assertEquals(state.playerB.melee.cards.length, 1, "Espion chez adversaire");
            assertEquals(state.playerB.melee.cards[0], 'Dijkstra', "Bonne carte plac√©e");
        });

        capacityTests.test("Espion: fait piocher 2 cartes", () => {
            const state = createGameState();
            state.playerA.deck = ['Archer', 'Geralt', 'Ciri'];
            state.playerA.hand = [];
            
            // Simuler pioche de 2 cartes
            for (let i = 0; i < 2; i++) {
                if (state.playerA.deck.length > 0) {
                    state.playerA.hand.push(state.playerA.deck.pop());
                }
            }
            
            assertEquals(state.playerA.hand.length, 2, "2 cartes pioch√©es");
            assertEquals(state.playerA.deck.length, 1, "1 carte restante dans deck");
        });

        capacityTests.test("M√©decin: ressuscite une carte du cimeti√®re", () => {
            const state = createGameState();
            state.playerA.graveyard = ['Archer', 'Fantassin'];
            
            // Simuler M√©decin
            const resurrected = state.playerA.graveyard[0];
            state.playerA.graveyard.shift();
            placeCard(state, 'A', resurrected, 'ranged');
            
            assertEquals(state.playerA.graveyard.length, 1, "1 carte reste au cimeti√®re");
            assertEquals(state.playerA.ranged.cards.length, 1, "Carte ressuscit√©e");
            assertEquals(state.playerA.ranged.cards[0], 'Archer', "Bonne carte ressuscit√©e");
        });

        capacityTests.test("M√©decin: ne ressuscite pas les H√©ros", () => {
            const state = createGameState();
            state.playerA.graveyard = ['Geralt', 'Archer'];
            
            // Filtrer les non-H√©ros
            const nonHeroes = state.playerA.graveyard.filter(name => !CARD_DATABASE[name].isHero);
            
            assertEquals(nonHeroes.length, 1, "Seul Archer peut √™tre ressuscit√©");
            assertEquals(nonHeroes[0], 'Archer', "Archer disponible");
        });

        capacityTests.test("Ralliement: pioche et joue une unit√©", () => {
            const state = createGameState();
            state.playerA.deck = ['Archer', 'Horn', 'Frost'];
            
            // Filtrer les unit√©s
            const units = state.playerA.deck.filter(name => {
                const c = CARD_DATABASE[name];
                return c.row !== 'special' && c.row !== 'weather';
            });
            
            assertEquals(units.length, 1, "1 unit√© trouv√©e");
            assertEquals(units[0], 'Archer', "Archer est une unit√©");
        });

        capacityTests.test("Nu√©e: invoque toutes les copies du deck", () => {
            const state = createGameState();
            state.playerA.deck = ['Nekker', 'Nekker', 'Archer', 'Nekker'];
            
            const cardName = 'Nekker';
            const copies = state.playerA.deck.filter(name => name === cardName);
            
            assertEquals(copies.length, 3, "3 copies de Nekker dans le deck");
        });

        capacityTests.test("Agilit√©: peut √™tre plac√© en M√™l√©e ou Distance", () => {
            const state = createGameState();
            const card = CARD_DATABASE['Elfe Tireur'];
            assertEquals(card.row, 'agile', "Carte agile");
            
            // Peut √™tre plac√© dans melee ou ranged
            placeCard(state, 'A', 'Elfe Tireur', 'melee');
            assertEquals(state.playerA.melee.cards.length, 1, "Plac√© en M√™l√©e");
        });

        // =====================================================================
        // SUITE 9: BONUS DE FACTION
        // =====================================================================

        const factionTests = new TestSuite("üè∞ Bonus de Faction");

        factionTests.test("Royaumes du Nord: pioche 1 carte si victoire", () => {
            const state = createGameState();
            state.playerA.faction = 'RN';
            state.playerA.deck = ['Archer', 'Geralt'];
            const deckSizeBefore = state.playerA.deck.length;
            
            // Simuler victoire
            if (state.playerA.deck.length > 0) {
                state.playerA.hand.push(state.playerA.deck.pop());
            }
            
            assertEquals(state.playerA.hand.length, 1, "1 carte pioch√©e");
            assertEquals(state.playerA.deck.length, deckSizeBefore - 1, "Deck r√©duit de 1");
        });

        factionTests.test("Monstres: conserve 1 carte apr√®s victoire", () => {
            const state = createGameState();
            state.playerA.faction = 'Monstres';
            placeCard(state, 'A', 'Archer', 'ranged');
            placeCard(state, 'A', 'Geralt', 'melee');
            
            const allCards = [...state.playerA.melee.cards, ...state.playerA.ranged.cards];
            const nonHeroes = allCards.filter(name => !CARD_DATABASE[name].isHero);
            
            assert(nonHeroes.length > 0, "Au moins 1 non-H√©ros disponible");
            assertEquals(nonHeroes[0], 'Archer', "Archer peut √™tre conserv√©");
        });

        factionTests.test("Skellige: ressuscite 2 cartes en manche 3", () => {
            const state = createGameState();
            state.playerA.faction = 'Skellige';
            state.currentRound = 3;
            state.playerA.graveyard = ['Archer', 'Fantassin', 'Catapulte'];
            
            // Simuler r√©surrection
            for (let i = 0; i < 2; i++) {
                if (state.playerA.graveyard.length > 0) {
                    const card = state.playerA.graveyard.pop();
                    placeCard(state, 'A', card, CARD_DATABASE[card].row);
                }
            }
            
            assertEquals(state.playerA.graveyard.length, 1, "1 carte reste au cimeti√®re");
            assertGreaterThan(state.playerA.melee.cards.length + state.playerA.ranged.cards.length + state.playerA.siege.cards.length, 0, "Cartes ressuscit√©es sur plateau");
        });

        // =====================================================================
        // SUITE 10: SYST√àME DE TOUR ET PASSE
        // =====================================================================

        const turnTests = new TestSuite("üîÑ Syst√®me de Tour et Passe");

        turnTests.test("√âtat initial: personne n'a pass√©", () => {
            const state = createGameState();
            assertEquals(state.playerA.passed, false, "Joueur A n'a pas pass√©");
            assertEquals(state.playerB.passed, false, "Joueur B n'a pas pass√©");
        });

        turnTests.test("Un joueur passe son tour", () => {
            const state = createGameState();
            state.playerA.passed = true;
            assertEquals(state.playerA.passed, true, "Joueur A a pass√©");
            assertEquals(state.playerB.passed, false, "Joueur B peut encore jouer");
        });

        turnTests.test("Les deux joueurs passent: fin de manche", () => {
            const state = createGameState();
            state.playerA.passed = true;
            state.playerB.passed = true;
            assert(state.playerA.passed && state.playerB.passed, "Fin de manche d√©tect√©e");
        });

        turnTests.test("Joueur avec main vide devrait passer", () => {
            const state = createGameState();
            state.playerA.hand = [];
            assertEquals(state.playerA.hand.length, 0, "Main vide");
            // L'IA devrait automatiquement passer
        });

        turnTests.test("IA passe si en avance significative", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Archer', 'ranged'); // 3 points
            placeCard(state, 'B', 'Geralt', 'melee'); // 15 points
            placeCard(state, 'B', 'Ciri', 'melee'); // 15 points
            
            const scoreA = calculateTotalScore(state, 'A');
            const scoreB = calculateTotalScore(state, 'B');
            
            assert(scoreB > scoreA + 10, "B en avance de plus de 10 points");
            // L'IA devrait passer
        });

        turnTests.test("Alternance de joueur actif", () => {
            const state = createGameState();
            assertEquals(state.activePlayer, 'A', "D√©but: Joueur A");
            
            state.activePlayer = 'B';
            assertEquals(state.activePlayer, 'B', "Tour suivant: Joueur B");
            
            state.activePlayer = 'A';
            assertEquals(state.activePlayer, 'A', "Retour √† Joueur A");
        });

        turnTests.test("Compteur de tours s'incr√©mente", () => {
            const state = createGameState();
            assertEquals(state.turnCount, 0, "D√©but: 0 tours");
            
            state.turnCount++;
            assertEquals(state.turnCount, 1, "Apr√®s 1 tour");
            
            state.turnCount++;
            assertEquals(state.turnCount, 2, "Apr√®s 2 tours");
        });

        // =====================================================================
        // SUITE 11: DECK ET MAIN
        // =====================================================================

        const deckTests = new TestSuite("üé∞ Gestion Deck et Main");

        deckTests.test("Carte retir√©e de la main quand jou√©e", () => {
            const state = createGameState();
            state.playerA.hand = ['Archer', 'Geralt', 'Ciri'];
            
            const cardToPlay = 'Archer';
            const idx = state.playerA.hand.indexOf(cardToPlay);
            state.playerA.hand.splice(idx, 1);
            
            assertEquals(state.playerA.hand.length, 2, "Main r√©duite √† 2 cartes");
            assert(!state.playerA.hand.includes('Archer'), "Archer retir√©");
        });

        deckTests.test("Pioche depuis le deck", () => {
            const state = createGameState();
            state.playerA.deck = ['Archer', 'Geralt', 'Ciri'];
            state.playerA.hand = [];
            
            const drawn = state.playerA.deck.pop();
            state.playerA.hand.push(drawn);
            
            assertEquals(state.playerA.deck.length, 2, "Deck r√©duit");
            assertEquals(state.playerA.hand.length, 1, "Main augment√©e");
            assertEquals(state.playerA.hand[0], 'Ciri', "Bonne carte pioch√©e");
        });

        deckTests.test("Impossible de piocher d'un deck vide", () => {
            const state = createGameState();
            state.playerA.deck = [];
            
            if (state.playerA.deck.length > 0) {
                state.playerA.hand.push(state.playerA.deck.pop());
            }
            
            assertEquals(state.playerA.hand.length, 0, "Aucune carte pioch√©e");
        });

        deckTests.test("Cimeti√®re re√ßoit les cartes d√©truites", () => {
            const state = createGameState();
            state.playerA.graveyard = [];
            
            const destroyed = 'Archer';
            state.playerA.graveyard.push(destroyed);
            
            assertEquals(state.playerA.graveyard.length, 1, "1 carte au cimeti√®re");
            assertEquals(state.playerA.graveyard[0], 'Archer', "Bonne carte au cimeti√®re");
        });

        // =====================================================================
        // SUITE 12: SC√âNARIOS COMPLEXES
        // =====================================================================

        const complexTests = new TestSuite("üé≠ Sc√©narios Complexes");

        complexTests.test("M√©t√©o + Lien Rapproch√© + Corne", () => {
            const state = createGameState();
            state.weather.frost = true;
            placeCard(state, 'A', 'Fantassin', 'melee');
            placeCard(state, 'A', 'Fantassin', 'melee');
            state.playerA.melee.horn = true;
            
            // M√©t√©o r√©duit √† 1, Lien double, Corne double tout
            // ((1*2)*2) * 2 = 8
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 8, "M√©t√©o + Lien + Corne");
        });

        complexTests.test("H√©ros + non-H√©ros avec m√©t√©o et corne", () => {
            const state = createGameState();
            state.weather.frost = true;
            placeCard(state, 'A', 'Geralt', 'melee');
            placeCard(state, 'A', 'Archer', 'melee');
            state.playerA.melee.horn = true;
            
            // Geralt: 15 (immunis√©), Archer: 1 (m√©t√©o)
            // Total: 16, avec corne: 32
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 32, "H√©ros + non-H√©ros avec m√©t√©o et corne");
        });

        complexTests.test("Incin√©ration avec Lien Rapproch√©", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Brigade', 'melee');
            placeCard(state, 'A', 'Brigade', 'melee');
            placeCard(state, 'B', 'Archer', 'ranged');
            
            // Brigade en Lien: (5*2)*2 = 20 force totale
            handleScorch(state);
            
            // Les Brigades devraient √™tre d√©truites (force 10 chacune calcul√©e)
            assertEquals(state.playerA.melee.cards.length, 0, "Brigades d√©truites");
        });

        complexTests.test("Score sur 3 rang√©es avec effets vari√©s", () => {
            const state = createGameState();
            
            // M√™l√©e: m√©t√©o + lien
            state.weather.frost = true;
            placeCard(state, 'A', 'Fantassin', 'melee');
            placeCard(state, 'A', 'Fantassin', 'melee');
            
            // Distance: corne
            placeCard(state, 'A', 'Archer', 'ranged');
            state.playerA.ranged.horn = true;
            
            // Si√®ge: normal
            placeCard(state, 'A', 'Catapulte', 'siege');
            
            const melee = calculateRowScore(state, 'A', 'melee'); // 4
            const ranged = calculateRowScore(state, 'A', 'ranged'); // 6
            const siege = calculateRowScore(state, 'A', 'siege'); // 8
            const total = calculateTotalScore(state, 'A'); // 18
            
            assertEquals(melee, 4, "Score M√™l√©e");
            assertEquals(ranged, 6, "Score Distance");
            assertEquals(siege, 8, "Score Si√®ge");
            assertEquals(total, 18, "Score Total");
        });

        complexTests.test("Partie compl√®te avec 3 manches", () => {
            const state = createGameState();
            
            // Manche 1
            state.roundsWon.A = 1;
            assertEquals(state.currentRound, 1, "Manche 1");
            
            // Manche 2
            state.currentRound = 2;
            state.roundsWon.B = 1;
            assertEquals(state.roundsWon.A, 1, "A: 1 victoire");
            assertEquals(state.roundsWon.B, 1, "B: 1 victoire");
            
            // Manche 3 d√©cisive
            state.currentRound = 3;
            state.roundsWon.A = 2;
            assert(state.roundsWon.A === 2, "A gagne la partie");
        });

        // =====================================================================
        // SUITE 13: VALIDATION DES DONN√âES
        // =====================================================================

        const validationTests = new TestSuite("‚úÖ Validation des Donn√©es");

        validationTests.test("Toutes les cartes ont une force d√©finie", () => {
            Object.keys(CARD_DATABASE).forEach(cardName => {
                const card = CARD_DATABASE[cardName];
                assert(card.force !== undefined, `${cardName} a une force d√©finie`);
            });
        });

        validationTests.test("Toutes les cartes ont une rang√©e valide", () => {
            const validRows = ['melee', 'ranged', 'siege', 'special', 'weather', 'agile'];
            Object.keys(CARD_DATABASE).forEach(cardName => {
                const card = CARD_DATABASE[cardName];
                assert(validRows.includes(card.row), `${cardName} a une rang√©e valide: ${card.row}`);
            });
        });

        validationTests.test("Toutes les cartes ont une capacit√© d√©finie", () => {
            Object.keys(CARD_DATABASE).forEach(cardName => {
                const card = CARD_DATABASE[cardName];
                assert(card.capacity !== undefined, `${cardName} a une capacit√©`);
            });
        });

        validationTests.test("Les H√©ros sont marqu√©s correctement", () => {
            const heroes = ['Geralt', 'Ciri', 'Yennefer', 'Triss'];
            heroes.forEach(heroName => {
                const card = CARD_DATABASE[heroName];
                assertEquals(card.isHero, true, `${heroName} est un H√©ros`);
            });
        });

        // =====================================================================
        // EX√âCUTION DES TESTS
        // =====================================================================

        const allSuites = [
            scoreTests,
            tightBondTests,
            hornTests,
            weatherTests,
            scorchTests,
            roundTests,
            initialTests,
            capacityTests,
            factionTests,
            turnTests,
            deckTests,
            complexTests,
            validationTests
        ];

        async function runAllTests() {
            const resultsContainer = document.getElementById('test-results');
            const summaryDiv = document.getElementById('summary');
            resultsContainer.innerHTML = '';
            
            let totalTests = 0;
            let totalPassed = 0;
            let totalFailed = 0;
            
            for (const suite of allSuites) {
                const suiteDiv = document.createElement('div');
                suiteDiv.className = 'test-suite';
                
                const suiteTitle = document.createElement('h2');
                suiteTitle.textContent = suite.name;
                suiteDiv.appendChild(suiteTitle);
                
                const results = await suite.run();
                
                results.forEach(result => {
                    totalTests++;
                    if (result.status === 'pass') totalPassed++;
                    else totalFailed++;
                    
                    const testDiv = document.createElement('div');
                    testDiv.className = `test-case ${result.status}`;
                    
                    const testName = document.createElement('div');
                    testName.className = 'test-name';
                    testName.innerHTML = `
                        <span class="test-result ${result.status}">
                            ${result.status === 'pass' ? '‚úì PASS' : '‚úó FAIL'}
                        </span>
                        ${result.name}
                    `;
                    testDiv.appendChild(testName);
                    
                    if (result.error) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'test-error';
                        errorDiv.textContent = result.error;
                        testDiv.appendChild(errorDiv);
                    }
                    
                    suiteDiv.appendChild(testDiv);
                });
                
                const suiteStats = document.createElement('div');
                suiteStats.style.marginTop = '15px';
                suiteStats.style.color = '#aaa';
                suiteStats.style.fontSize = '14px';
                suiteStats.innerHTML = `
                    <strong>Suite:</strong> ${suite.passed} r√©ussi(s), ${suite.failed} √©chou√©(s) sur ${suite.tests.length} test(s)
                `;
                suiteDiv.appendChild(suiteStats);
                
                resultsContainer.appendChild(suiteDiv);
            }
            
            // Mettre √† jour le r√©sum√©
            summaryDiv.style.display = 'block';
            document.getElementById('total-tests').textContent = totalTests;
            document.getElementById('passed-tests').textContent = totalPassed;
            document.getElementById('failed-tests').textContent = totalFailed;
            
            // Scroll vers le haut
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // =====================================================================
        // SUITE 14: TESTS EDGE CASES ET LIMITES
        // =====================================================================

        const edgeCaseTests = new TestSuite("‚ö†Ô∏è Cas Limites et Edge Cases");

        edgeCaseTests.test("Plateau vide donne un score de 0", () => {
            const state = createGameState();
            const score = calculateTotalScore(state, 'A');
            assertEquals(score, 0, "Plateau vide = 0 points");
        });

        edgeCaseTests.test("Force √† 0 reste √† 0 m√™me avec corne", () => {
            const state = createGameState();
            // Note: Scorch a force 0 mais ne devrait pas √™tre sur le plateau
            // Testons avec une carte hypoth√©tique de force 0
            state.playerA.melee.cards = [];
            state.playerA.melee.horn = true;
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 0, "0 * 2 = 0");
        });

        edgeCaseTests.test("100 cartes identiques avec Lien Rapproch√©", () => {
            const state = createGameState();
            // Test de scalabilit√©
            for (let i = 0; i < 100; i++) {
                placeCard(state, 'A', 'Fantassin', 'melee');
            }
            const score = calculateRowScore(state, 'A', 'melee');
            // (1*2)*100 = 200
            assertEquals(score, 200, "Lien avec 100 cartes");
        });

        edgeCaseTests.test("Toutes les m√©t√©os actives en m√™me temps", () => {
            const state = createGameState();
            state.weather.frost = true;
            state.weather.fog = true;
            state.weather.rain = true;
            
            placeCard(state, 'A', 'Archer', 'melee');
            placeCard(state, 'A', 'Archer', 'ranged');
            placeCard(state, 'A', 'Catapulte', 'siege');
            
            const scoreMelee = calculateRowScore(state, 'A', 'melee');
            const scoreRanged = calculateRowScore(state, 'A', 'ranged');
            const scoreSiege = calculateRowScore(state, 'A', 'siege');
            
            assertEquals(scoreMelee, 1, "M√™l√©e r√©duite √† 1");
            assertEquals(scoreRanged, 1, "Distance r√©duite √† 1");
            assertEquals(scoreSiege, 1, "Si√®ge r√©duit √† 1");
            assertEquals(scoreMelee + scoreRanged + scoreSiege, 3, "Total: 3");
        });

        edgeCaseTests.test("Incin√©ration avec plateau vide", () => {
            const state = createGameState();
            const destroyed = handleScorch(state);
            assertEquals(destroyed, 0, "Rien √† d√©truire");
        });

        edgeCaseTests.test("Incin√©ration avec seulement des H√©ros", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Geralt', 'melee');
            placeCard(state, 'A', 'Ciri', 'melee');
            placeCard(state, 'B', 'Yennefer', 'ranged');
            
            const destroyed = handleScorch(state);
            assertEquals(destroyed, 0, "Aucun H√©ros d√©truit");
            assertEquals(state.playerA.melee.cards.length, 2, "H√©ros A intacts");
            assertEquals(state.playerB.ranged.cards.length, 1, "H√©ros B intact");
        });

        edgeCaseTests.test("Cimeti√®re avec 50+ cartes", () => {
            const state = createGameState();
            for (let i = 0; i < 60; i++) {
                state.playerA.graveyard.push('Archer');
            }
            assertEquals(state.playerA.graveyard.length, 60, "60 cartes au cimeti√®re");
        });

        edgeCaseTests.test("Pioche jusqu'√† √©puisement du deck", () => {
            const state = createGameState();
            state.playerA.deck = ['Archer', 'Geralt', 'Ciri'];
            state.playerA.hand = [];
            
            // Piocher tout le deck
            while (state.playerA.deck.length > 0) {
                state.playerA.hand.push(state.playerA.deck.pop());
            }
            
            assertEquals(state.playerA.deck.length, 0, "Deck vide");
            assertEquals(state.playerA.hand.length, 3, "Toutes les cartes en main");
        });

        // =====================================================================
        // SUITE 15: TESTS D'INT√âGRATION IA
        // =====================================================================

        const aiTests = new TestSuite("ü§ñ Tests IA et Logique de Jeu");

        aiTests.test("IA passe quand elle a une avance confortable", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Archer', 'ranged'); // 3
            placeCard(state, 'B', 'Geralt', 'melee'); // 15
            placeCard(state, 'B', 'Ciri', 'melee'); // 15
            
            const scoreA = calculateTotalScore(state, 'A');
            const scoreB = calculateTotalScore(state, 'B');
            
            const shouldAIPass = (scoreB > scoreA + 10);
            assertEquals(shouldAIPass, true, "IA devrait passer (30 vs 3)");
        });

        aiTests.test("IA joue quand scores sont proches", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Geralt', 'melee'); // 15
            placeCard(state, 'B', 'Ciri', 'melee'); // 15
            
            const scoreA = calculateTotalScore(state, 'A');
            const scoreB = calculateTotalScore(state, 'B');
            
            const shouldAIPass = (scoreB > scoreA + 10);
            assertEquals(shouldAIPass, false, "IA ne devrait pas passer (√©galit√©)");
        });

        aiTests.test("IA doit passer si main vide", () => {
            const state = createGameState();
            state.playerB.hand = [];
            
            assertEquals(state.playerB.hand.length, 0, "Main vide");
            // L'IA devrait automatiquement passer
        });

        aiTests.test("IA d√©tecte fin de manche (les 2 passent)", () => {
            const state = createGameState();
            state.playerA.passed = true;
            state.playerB.passed = true;
            
            const isRoundOver = state.playerA.passed && state.playerB.passed;
            assertEquals(isRoundOver, true, "Fin de manche d√©tect√©e");
        });

        aiTests.test("IA continue si adversaire seul a pass√©", () => {
            const state = createGameState();
            state.playerA.passed = true;
            state.playerB.passed = false;
            state.playerB.hand = ['Archer'];
            
            const canBPlay = !state.playerB.passed && state.playerB.hand.length > 0;
            assertEquals(canBPlay, true, "IA peut encore jouer");
        });

        aiTests.test("Partie se termine apr√®s 3 manches max", () => {
            const state = createGameState();
            state.currentRound = 3;
            state.roundsWon.A = 2;
            
            const isGameOver = state.roundsWon.A >= 2 || state.roundsWon.B >= 2;
            assertEquals(isGameOver, true, "Partie termin√©e");
        });

        aiTests.test("Victoire en 2 manches cons√©cutives", () => {
            const state = createGameState();
            state.roundsWon.A = 2;
            state.roundsWon.B = 0;
            
            assertEquals(state.roundsWon.A, 2, "A gagne 2-0");
        });

        aiTests.test("Victoire apr√®s manche d√©cisive (2-1)", () => {
            const state = createGameState();
            state.currentRound = 3;
            state.roundsWon.A = 1;
            state.roundsWon.B = 1;
            // La manche 3 est d√©cisive
            
            state.roundsWon.B = 2;
            assertEquals(state.roundsWon.B, 2, "B gagne 2-1");
        });

        // =====================================================================
        // SUITE 16: TESTS DE COH√âRENCE DES R√àGLES
        // =====================================================================

        const ruleTests = new TestSuite("üìú Coh√©rence des R√®gles");

        ruleTests.test("Main ne peut pas d√©passer limite raisonnable", () => {
            const state = createGameState();
            // Distribution initiale: 10 cartes
            // Espions peuvent ajouter des cartes
            // Mais il devrait y avoir une limite pratique
            
            state.playerA.hand = new Array(20).fill('Archer');
            assert(state.playerA.hand.length <= 30, "Main reste g√©rable");
        });

        ruleTests.test("Rang√©e m√©t√©o correcte: Froid = M√™l√©e", () => {
            const state = createGameState();
            state.weather.frost = true;
            
            placeCard(state, 'A', 'Archer', 'melee');
            const force = calculateCardForce(state, 'A', 'melee', 'Archer');
            
            assertEquals(force, 1, "Froid affecte M√™l√©e");
        });

        ruleTests.test("Rang√©e m√©t√©o correcte: Brouillard = Distance", () => {
            const state = createGameState();
            state.weather.fog = true;
            
            placeCard(state, 'A', 'Archer', 'ranged');
            const force = calculateCardForce(state, 'A', 'ranged', 'Archer');
            
            assertEquals(force, 1, "Brouillard affecte Distance");
        });

        ruleTests.test("Rang√©e m√©t√©o correcte: Pluie = Si√®ge", () => {
            const state = createGameState();
            state.weather.rain = true;
            
            placeCard(state, 'A', 'Catapulte', 'siege');
            const force = calculateCardForce(state, 'A', 'siege', 'Catapulte');
            
            assertEquals(force, 1, "Pluie affecte Si√®ge");
        });

        ruleTests.test("M√©t√©o n'affecte pas les autres rang√©es", () => {
            const state = createGameState();
            state.weather.frost = true;
            
            placeCard(state, 'A', 'Archer', 'ranged');
            const force = calculateCardForce(state, 'A', 'ranged', 'Archer');
            
            assertEquals(force, 3, "Distance non affect√©e par Froid");
        });

        ruleTests.test("Lien Rapproch√© n√©cessite 2+ cartes", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Fantassin', 'melee');
            
            const copies = state.playerA.melee.cards.filter(c => c === 'Fantassin');
            const hasBonus = copies.length > 1;
            
            assertEquals(hasBonus, false, "Pas de bonus avec 1 seule carte");
        });

        ruleTests.test("Ordre d'application: M√©t√©o ‚Üí Lien ‚Üí Corne", () => {
            const state = createGameState();
            state.weather.frost = true;
            placeCard(state, 'A', 'Fantassin', 'melee');
            placeCard(state, 'A', 'Fantassin', 'melee');
            state.playerA.melee.horn = true;
            
            // 1. M√©t√©o: force ‚Üí 1
            // 2. Lien: 1*2 = 2 par carte
            // 3. Total: 2*2 = 4
            // 4. Corne: 4*2 = 8
            
            const score = calculateRowScore(state, 'A', 'melee');
            assertEquals(score, 8, "Ordre correct d'application");
        });

        // =====================================================================
        // SUITE FINALE: TESTS DE R√âGRESSION
        // =====================================================================

        const regressionTests = new TestSuite("üîÑ Tests de R√©gression");

        regressionTests.test("Score ne peut pas √™tre n√©gatif", () => {
            const state = createGameState();
            const score = calculateTotalScore(state, 'A');
            assert(score >= 0, "Score toujours >= 0");
        });

        regressionTests.test("Cartes ne disparaissent pas entre les manches", () => {
            const state = createGameState();
            placeCard(state, 'A', 'Archer', 'ranged');
            placeCard(state, 'A', 'Geralt', 'melee');
            
            const cardsOnBoard = state.playerA.melee.cards.length + state.playerA.ranged.cards.length;
            
            // Simuler nettoyage
            ['melee', 'ranged', 'siege'].forEach(row => {
                state.playerA[row].cards.forEach(card => {
                    state.playerA.graveyard.push(card);
                });
                state.playerA[row].cards = [];
            });
            
            assertEquals(state.playerA.graveyard.length, cardsOnBoard, "Toutes les cartes comptabilis√©es");
        });

        regressionTests.test("√âtat du jeu reste coh√©rent apr√®s passe", () => {
            const state = createGameState();
            const beforeHand = [...state.playerA.hand];
            
            state.playerA.passed = true;
            
            assertArrayEquals(state.playerA.hand, beforeHand, "Main inchang√©e apr√®s passe");
        });

        regressionTests.test("Compteurs ne d√©bordent pas", () => {
            const state = createGameState();
            state.turnCount = 999;
            state.turnCount++;
            
            assert(state.turnCount === 1000, "Compteur fonctionne correctement");
        });

        // Ajouter toutes les nouvelles suites
        allSuites.push(edgeCaseTests, aiTests, ruleTests, regressionTests);

        // Auto-run au chargement
        window.addEventListener('DOMContentLoaded', () => {
            console.log('üß™ Suite de tests Gwent charg√©e - ' + allSuites.length + ' suites disponibles');
            console.log('Cliquez sur "Lancer tous les tests" pour commencer');
        });
    </script>
</body>
</html>