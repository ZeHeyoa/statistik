<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Trophy Ranking (Gold, Silver, Bronze)</title>

    <style>
        /* --- General Style --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5; 
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 3px 20px 10px 20px; 
            box-sizing: border-box;
            overflow-x: hidden;
            font-size: 0.8em; 
        }

        .main-content-wrapper {
            display: flex;
            gap: 15px; 
            width: 100%;
            align-items: flex-start;
            min-height: calc(100vh - 13px); 
            /* Rendre le wrapper cliquable pour la pause */
            cursor: pointer; 
        }

        /* --- Screens Styles --- */
        .overlay-screen {
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            /* Rendu opaque: Fond blanc-cass√© */
            background-color: #f0f2f5; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            z-index: 100; 
            /* *** AUCUN BACKDROP-FILTER OU FILTRE BLEU ICI *** */
            text-align: center; 
            padding: 20px; 
            box-sizing: border-box;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .screen-content {
            background-color: rgba(255,255,255,0.9); 
            padding: 15px 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
            max-width: 800px; 
            width: 100%;
            text-align: left;
            max-height: 90vh; 
            overflow-y: auto; 
        }

        .screen-title {
            color: #1e3a5f; 
            font-size: 1.5em; 
            margin-bottom: 25px;
            text-align: center;
        }

        .next-btn {
            background-color: #4e73df;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 20px;
            transition: background-color 0.3s;
        }
        .next-btn:hover {
            background-color: #224abe;
        }

        /* Style sp√©cifique pour l'√©cran de langue */
        #language-screen .screen-content {
            max-width: 400px;
            text-align: center;
        }
        #language-select {
            padding: 10px;
            font-size: 1.1em;
            border-radius: 5px;
            border: 1px solid #ccc;
            margin-top: 15px;
            width: 80%;
        }

        /* --- Filtering Styles --- */
        .filter-section {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        }

        .filter-section h3 {
            color: #1e3a5f;
            font-size: 1.1em;
            margin-top: 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            margin-bottom: 10px;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 8px;
        }

        .filter-item {
            display: flex;
            align-items: center;
            font-size: 0.9em;
        }

        .filter-item label {
            margin-left: 5px;
            cursor: pointer;
            width: 100%;
        }
        
        /* NOUVEAU: Style pour les points dans la section 2 */
        .competition-points-display {
            font-size: 0.85em;
            font-weight: bold;
            color: #007bff; /* Bleu pour attirer l'oeil */
            margin-left: 8px;
            display: none; /* Cach√© par d√©faut */
        }

        .edition-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }

        .edition-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            text-align: left;
        }

        .edition-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #4e73df;
        }

        .edition-group select,
        /* Style pour les inputs de points */
        .edition-group input[type="number"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f9f9f9;
            font-size: 1em;
        }

        /* --- Left Column: Competitions and Year --- */
        .competitions-column {
            width: 110px; 
            flex-shrink: 0;
            padding-top: 3px; 
            display: flex;
            flex-direction: column;
            min-height: calc(100vh - 13px - 3px); 
        }

        #year-display-in-column {
            font-size: 1.725em; 
            color: #1e3a5f;
            margin: 0 0 0 0; 
            font-weight: 800;
            text-align: center;
            line-height: 1; 
        }

        /* Style pour l'indicateur de pause */
        #pause-indicator {
            font-size: 0.8em;
            font-weight: bold;
            color: #ff0000;
            text-align: center;
            margin: 3px 0 5px 0;
            display: none; /* Cach√© par d√©faut */
        }

        .competitions-display {
            display: flex;
            flex-direction: column; 
            gap: 6px; 
            max-height: 100vh; 
            flex-grow: 1; 
            overflow: hidden; 
            align-items: flex-start;
            position: relative; 
        }

        #all-competitions-scroll-container {
            position: relative;
            top: 0; 
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        /* Container for competitions of a year */
        .year-group-container {
            position: relative; 
            width: 100%;
            margin-bottom: 6px; 
            flex-shrink: 0; 
        }

        /* --- Style : Year Separator --- */
        .year-separator {
            width: 100%;
            height: 20px; 
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 3px 0; 
            position: relative;
            flex-shrink: 0; 
        }

        .year-separator::before,
        .year-separator::after {
            content: '';
            flex-grow: 1;
            height: 1px;
            background-color: #ccc;
            margin: 0 5px;
        }

        .year-separator-text {
            font-size: 0.8em;
            font-weight: bold;
            color: #666;
            padding: 0 5px;
        }

        /* --- COMPETITION BOX STRUCTURE --- */
        .competition-box {
            position: relative; 
            width: 100%;
            height: 38px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
            border-radius: 3px; 
            overflow: hidden; 
            transition: transform 0.2s ease;
            display: flex; 
            margin-bottom: 6px; 
            flex-shrink: 0; 
        }

        .year-group-container .competition-box:last-child {
            margin-bottom: 0;
        }

        .competition-box:hover {
            transform: scale(1.03); 
            z-index: 5;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
        }

        /* --- Internal Columns --- */
        #flag-column {
            width: 35%; 
            flex-shrink: 0;
            background-color: #000; 
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            overflow: hidden;
        }

        #flag-column img {
            width: 100%;
            height: 100%;
            object-fit: cover; 
            padding: 0; 
        }

        #right-column {
            width: 65%; 
            flex-grow: 1;
            display: flex;
            flex-direction: column; 
            height: 100%;
        }

        #comp-info-case {
            height: 50%; 
            display: flex;
            flex-direction: column; /* MODIFI√â: Garder en colonne */
            align-items: center;
            justify-content: center;
            font-size: 0.7em; /* MODIFI√â: Augment√© */
            font-weight: bold;
            color: #fff;
            padding: 0 3px; /* MODIFI√â: Ajout de padding */
            text-align: center;
            line-height: 1; /* MODIFI√â: Rapprocher les lignes */
        }
        
        /* NOUVEAU: Pour forcer le nom de la comp sur 1 ligne */
        .comp-name-line {
            display: block;
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #winner-name-case {
            height: 50%; 
            background-color: #000; 
            color: #ccc; 
            font-size: 0.6em; 
            font-weight: 600; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0 1px; 
            text-align: center;
            line-height: 1.1; 
        }

        /* --- RANKING BASE STYLES --- */
        .no-competitions { font-size: 0.7em; margin-top: 5px; }
        .chart-container { 
            flex-grow: 1; 
            max-width: 600px; 
            flex-shrink: 0; 
            padding-top: 0;
            position: relative; 
        }
        
        #ranking-chart { 
            position: relative; 
            width: 100%; 
            z-index: 2; 
        }
        
        /* MODIFI√â: Conteneur pour les pastilles de bar√®me */
        #background-pills-container {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            z-index: 1; /* Derri√®re le classement */
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 5px; /* MODIFI√â */
            opacity: 0.2; /* MODIFI√â: Effet plus effac√© */
            pointer-events: none; /* Ne pas bloquer les clics */
            overflow: hidden;
            max-height: 100px; /* MODIFI√â: Plus de place */
            filter: blur(0.5px); /* MODIFI√â: Effet effac√© */
        }

        /* MODIFI√â: Style des pastilles */
        .point-pill {
            padding: 2px; /* MODIFI√â */
            border-radius: 50%; /* MODIFI√â: Circulaire */
            font-weight: bold;
            color: #fff;
            display: flex; /* MODIFI√â */
            align-items: center; /* MODIFI√â */
            justify-content: center; /* MODIFI√â */
            text-align: center; /* MODIFI√â */
            line-height: 1.1; /* MODIFI√â */
            box-sizing: border-box; /* MODIFI√â */
            flex-shrink: 0; /* MODIFI√â */
        }

        .country-row {
            position: absolute;
            width: 100%;
            height: 35px; 
            display: flex;
            align-items: center;
            margin-bottom: 5px; 
            opacity: 0; 
            visibility: hidden; 
            background-color: transparent; 
            border-radius: 0; 
            padding-right: 8px; 
        }

        .country-info { position: relative; width: 100%; display: flex; align-items: center; }

        /* Styles pour les pays */
        .country-name { 
            position: absolute; 
            top: 0px; 
            left: 40px; 
            font-size: 0.7em; 
            font-weight: bold; 
            color: #444; 
            white-space: nowrap; 
        }
        .flag { 
            width: 35px; 
            height: 35px; 
            border-radius: 50%; 
            border: 2px solid #fff; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
            margin-right: 1px; 
            flex-shrink: 0; 
            object-fit: cover; 
            background-color: #eee; 
        }
        .progress-container { 
            flex-grow: 1; 
            height: 6px; 
            background-color: transparent; 
            border-radius: 3px; 
            overflow: hidden; 
            margin-top: 15px; 
        }
        .progress-bar { 
            width: 0%; 
            height: 100%; 
            border-radius: 3px; 
        }
        .trophy-count { 
            font-size: 1.1em; 
            font-weight: bold; 
            color: #1e3a5f; 
            margin-left: 10px; 
            width: 40px; 
            text-align: center; 
            flex-shrink: 0; 
            transition: width 0.3s, font-size 0.3s; 
        }

        /* --- Region Specific Styles (Identique aux pays) --- */
        .country-row.is-region .country-info {
            background-color: transparent;
            border: none;
            box-shadow: none;
            height: 35px;
        }

        .country-row.is-region .country-name {
            position: absolute; 
            top: 0px;          
            left: 40px;        
            font-size: 0.7em;  
            color: #444;       
            font-weight: bold;
            white-space: nowrap;
        }

        .country-row.is-region .flag {
            width: 35px; 
            height: 35px; 
            border-radius: 50%; 
            border: 2px solid #fff; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.15); 
            flex-shrink: 0; 
        }

        /* Couleurs sp√©cifiques aux r√©gions */
        .country-row.is-region .flag[data-region-code="AN"] { background-color: #36454F; }
        .country-row.is-region .flag[data-region-code="AO"] { background-color: #FFA500; }
        .country-row.is-region .flag[data-region-code="AE"] { background-color: #008000; }
        .country-row.is-region .flag[data-region-code="AC"] { background-color: #FF0000; }
        .country-row.is-region .flag[data-region-code="AA"] { background-color: #0000FF; }

        .country-row.is-region .progress-container {
            flex-grow: 1;
            height: 6px; 
            background-color: transparent; 
            margin-top: 15px; 
            margin-left: 0; 
            margin-right: 0; 
            border-radius: 3px;
        }

        .country-row.is-region .trophy-count {
            color: #1e3a5f; 
            font-size: 1.1em;
            margin-left: 10px; 
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="language-screen" class="overlay-screen">
        <div class="screen-content">
            <h1 class="screen-title" data-lang-key="select_language_title">Select Language</h1>
            <p data-lang-key="select_language_instruction">Please choose your preferred language to continue.</p>
            <select id="language-select">
                <option value="fr">Fran√ßais</option>
                <option value="en" selected>English</option>
                <option value="es">Espa√±ol</option>
            </select>
            <button class="next-btn" data-lang-key="select_language_button" onclick="showIntroScreen()">Continue</button>
        </div>
    </div>

    <div id="start-screen" class="overlay-screen" style="visibility: hidden; opacity: 0; display: none;">
        <div class="intro-screen-content">
            <h1 data-lang-key="welcome_title">üèÜ CAF All-Time Trophy Ranking</h1>
            <p data-lang-key="welcome_instruction">Click to set up the region, competition, and year filters before launching the animation.</p>
            <button class="next-btn" data-lang-key="welcome_button" onclick="showFilterScreen()">Start Configuration</button>
        </div>
    </div>

    <div id="filter-screen" class="overlay-screen" style="visibility: hidden; opacity: 0; display: none;">
        <h1 class="screen-title" data-lang-key="filter_title">Filter CAF Trophies</h1>
        <div class="screen-content">

            <div class="filter-section">
                <h3 data-lang-key="filter_region_title">1. Filter by CAF Region</h3>
                <p style="font-size: 0.75em; color: #777; margin-bottom: 10px;" data-lang-key="filter_region_instruction">Select the regions whose countries will be included in the ranking.</p>
                <div class="filter-grid" id="region-filters">
                    </div>

                <hr style="margin: 15px 0;">

                <div class="filter-item" style="justify-content: center;">
                    <input type="checkbox" id="displayRegionRankCheckbox">
                    <label for="displayRegionRankCheckbox" style="font-weight: bold; color: #007bff;" data-lang-key="filter_region_rank_label">Display Region Ranking (Country Accumulation)</label>
                </div>
            </div>

            <div class="filter-section">
                <h3 data-lang-key="filter_competition_title">2. Filter by Competition</h3>
                <p style="font-size: 0.75em; color: #777; margin-bottom: 10px;" data-lang-key="filter_competition_instruction">Select the trophies that will be counted (Clubs and National Teams).</p>
                <div class="filter-grid" id="competition-filters">
                    </div>
            </div>

            <div class="filter-section">
                <h3 data-lang-key="filter_period_title">3. Filter by Period</h3>
                <div class="edition-controls">
                    <div class="edition-group">
                        <label for="startYearSelect" data-lang-key="filter_start_year_label">Start Year</label>
                        <select id="startYearSelect"></select>
                    </div>
                    <div class="edition-group">
                        <label for="endYearSelect" data-lang-key="filter_end_year_label">End Year</label>
                        <select id="endYearSelect"></select>
                    </div>
                </div>
            </div>
            
            <div style="text-align: center;">
                <button class="next-btn" data-lang-key="filter_start_button" onclick="launchRankingFromFilter()">Launch Ranking Animation</button>
            </div>
        </div>
    </div>

    <div class="main-content-wrapper" id="main-content-wrapper"> 

        <div class="competitions-column">
            <h2 id="year-display-in-column">1956</h2> 
            <p id="pause-indicator" data-lang-key="paused_label">PAUSE</p> 
            <div id="competitions-display" class="competitions-display">
                <p class="no-competitions" data-lang-key="loading_data">Loading data...</p>
            </div>
        </div>

        <div class="chart-container">
            <div id="background-pills-container"></div>
            
            <div id="ranking-chart">
                </div>
        </div>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- TRANSLATION DATA ---
            const translations = {
                'fr': {
                    // Language Screen
                    'select_language_title': 'S√©lectionner la Langue',
                    'select_language_instruction': 'Veuillez choisir votre langue pr√©f√©r√©e pour continuer.',
                    'select_language_button': 'Continuer',
                    // Intro Screen
                    'welcome_title': 'üèÜ Classement Historique des Troph√©es CAF',
                    'welcome_instruction': 'Cliquez pour configurer les filtres de r√©gion, de comp√©tition et d\'ann√©e avant de lancer l\'animation.',
                    'welcome_button': 'Commencer la configuration',
                    // Filter Screen
                    'filter_title': 'Filtrer les Troph√©es CAF',
                    'filter_region_title': '1. Filtrer par R√©gion CAF',
                    'filter_region_instruction': 'S√©lectionnez les r√©gions dont les pays seront inclus dans le classement.',
                    'filter_region_rank_label': 'Afficher le classement des r√©gions (Cumul des pays)',
                    'filter_competition_title': '2. Filtrer par Comp√©tition',
                    'filter_competition_instruction': 'S√©lectionnez les troph√©es qui seront comptabilis√©s (Clubs et S√©lections).',
                    'filter_period_title': '3. Filtrer par P√©riode',
                    'filter_start_year_label': 'Ann√©e de D√©part',
                    'filter_end_year_label': 'Ann√©e de Fin',
                    'filter_start_button': 'Lancer l\'Animation du Classement',
                    // Animation Text
                    'loading_data': 'Chargement des donn√©es...',
                    'no_events_filtered': 'Aucun √©v√©nement filtr√©.',
                    'no_competitions_filtered': 'Aucun √©v√©nement ne correspond aux filtres.',
                    'final_year': 'FINAL',
                    'paused_label': 'PAUSE'
                },
                'en': {
                    // Language Screen
                    'select_language_title': 'Select Language',
                    'select_language_instruction': 'Please choose your preferred language to continue.',
                    'select_language_button': 'Continue',
                    // Intro Screen
                    'welcome_title': 'üèÜ CAF All-Time Trophy Ranking',
                    'welcome_instruction': 'Click to set up the region, competition, and year filters before launching the animation.',
                    'welcome_button': 'Start Configuration',
                    // Filter Screen
                    'filter_title': 'Filter CAF Trophies',
                    'filter_region_title': '1. Filter by CAF Region',
                    'filter_region_instruction': 'Select the regions whose countries will be included in the ranking.',
                    'filter_region_rank_label': 'Display Region Ranking (Country Accumulation)',
                    'filter_competition_title': '2. Filter by Competition',
                    'filter_competition_instruction': 'Select the trophies that will be counted (Clubs and National Teams).',
                    'filter_period_title': '3. Filter by Period',
                    'filter_start_year_label': 'Start Year',
                    'filter_end_year_label': 'End Year',
                    'filter_start_button': 'Launch Ranking Animation',
                    // Animation Text
                    'loading_data': 'Loading data...',
                    'no_events_filtered': 'No filtered events.',
                    'no_competitions_filtered': 'No events match the filters.',
                    'final_year': 'FINAL',
                    'paused_label': 'PAUSE'
                },
                'es': {
                    // Language Screen
                    'select_language_title': 'Seleccionar Idioma',
                    'select_language_instruction': 'Por favor, elija su idioma preferido para continuar.',
                    'select_language_button': 'Continuar',
                    // Intro Screen
                    'welcome_title': 'üèÜ Clasificaci√≥n Hist√≥rica de Trofeos CAF',
                    'welcome_instruction': 'Haga clic para configurar los filtros de regi√≥n, competici√≥n y a√±o antes de iniciar la animaci√≥n.',
                    'welcome_button': 'Empezar la Configuraci√≥n',
                    // Filter Screen
                    'filter_title': 'Filtrar Trofeos CAF',
                    'filter_region_title': '1. Filtrar por Regi√≥n CAF',
                    'filter_region_instruction': 'Seleccione las regiones cuyos pa√≠ses ser√°n incluidos en la clasificaci√≥n.',
                    'filter_region_rank_label': 'Mostrar Clasificaci√≥n de Regiones (Acumulaci√≥n por Pa√≠s)',
                    'filter_competition_title': '2. Filtrar por Competici√≥n',
                    'filter_competition_instruction': 'Seleccione los trofeos que se contar√°n (Clubes y Selecciones Nacionales).',
                    'filter_period_title': '3. Filtrar por Per√≠odo',
                    'filter_start_year_label': 'A√±o de Inicio',
                    'filter_end_year_label': 'A√±o de Fin',
                    'filter_start_button': 'Lanzar Animaci√≥n de Clasificaci√≥n',
                    // Animation Text
                    'loading_data': 'Cargando datos...',
                    'no_events_filtered': 'Ning√∫n evento filtrado.',
                    'no_competitions_filtered': 'Ning√∫n evento coincide con los filtros.',
                    'final_year': 'FINAL',
                    'paused_label': 'PAUSA'
                }
            };

            let currentLang = 'fr'; // D√©faut Fran√ßais selon la demande initiale

            function setLanguage(lang) {
                currentLang = lang;
                document.querySelectorAll('[data-lang-key]').forEach(element => {
                    const key = element.getAttribute('data-lang-key');
                    if (translations[lang] && translations[lang][key]) {
                        // Pour les champs de formulaire (label, button)
                        if (element.tagName === 'BUTTON' || element.tagName === 'LABEL') {
                            element.textContent = translations[lang][key];
                        } else if (element.tagName === 'H1' || element.tagName === 'H3' || element.tagName === 'P') {
                            element.textContent = translations[lang][key];
                        } else if (element.tagName === 'LABEL' && element.htmlFor && element.htmlFor.includes('YearSelect')) {
                             element.textContent = translations[lang][key];
                        } else if (element.id === 'pause-indicator') { // utilisation de pause-indicator
                             element.textContent = translations[lang][key];
                        }
                    }
                });
                // Mettre √† jour les labels des filtres de r√©gion/comp√©tition si d√©j√† affich√©s
                if(regionFiltersDiv.children.length > 0) {
                     initFilterElements(false); 
                }

                // Mettre √† jour l'affichage "Aucun √©v√©nement filtr√©" si pr√©sent
                if(competitionsDisplayContainer.querySelector('.no-competitions')) {
                    competitionsDisplayContainer.querySelector('.no-competitions').textContent = translations[lang].loading_data;
                }

                document.title = translations[lang].welcome_title.replace('üèÜ ', '');
            }

            // --- CONFIGURATION ---
            const JSON_FILE_PATH = 'data_caf.json';
            const BASE_SECONDS_PER_YEAR = 1; 
            const SLOWDOWN_PER_COMPETITION = 0.5; 
            const COMPETITION_THRESHOLD = 2; 
            const ROW_HEIGHT = 38; 
            const COMP_BOX_HEIGHT = 38;
            const COMP_BOX_GAP = 6;
            const SEPARATOR_HEIGHT = 26; 

            // COMPETITION COLORS
            const COMPETITION_COLORS = [
                '#1e3a5f', '#991b1b', '#15803d', '#92400e', '#4c1d95'
            ];
            let competitionColorMap = {}; 
            let colorIndex = 0;

            // --- DOM ELEMENTS ---
            const chart = document.getElementById('ranking-chart');
            const yearDisplay = document.getElementById('year-display-in-column'); 
            const competitionsDisplayContainer = document.getElementById('competitions-display'); 
            const regionFiltersDiv = document.getElementById('region-filters');
            const competitionFiltersDiv = document.getElementById('competition-filters');
            const startYearSelect = document.getElementById('startYearSelect');
            const endYearSelect = document.getElementById('endYearSelect');
            const displayRegionRankCheckbox = document.getElementById('displayRegionRankCheckbox'); 
            const languageSelect = document.getElementById('language-select');
            const mainContentWrapper = document.getElementById('main-content-wrapper'); 
            const pauseIndicator = document.getElementById('pause-indicator'); 
            const backgroundPillsContainer = document.getElementById('background-pills-container'); // NOUVEAU

            let allCompetitionsContainer = null;

            // --- GLOBAL ANIMATION STATE ---
            let allCountries = {};
            let allRegions = {}; 
            let yearlyWins = {};
            let rawYearlyData = {}; 
            let sortedYears = [];
            let timer = null; 
            let yearIndex = 0; // Index de l'ann√©e en cours dans filteredYears
            let filteredYears = []; // Les ann√©es filtr√©es
            let isPaused = false; 

            // --- FILTER STATE ---
            let startYear = 1957;
            let endYear = 2025;
            let selectedRegions = new Set();
            let selectedCompetitions = new Set();
            let displayRegionRank = false; 


            // --- CAF REGION MAPPING ---
            const regions = {
                'Afrique du Nord': { countries: ['EGYPTE', 'MAROC', 'ALGERIE', 'TUNISIE', 'LIBYE'], flagCode: 'AN', isRegion: true, color: '#36454F', nameShort: 'NORD' }, 
                'Afrique de l\'Ouest': { countries: ['GHANA', 'COTE IVOIRE', 'NIGERIA', 'GAMBIE', 'GUINEE CONAKRY', 'MALI', 'SENEGAL', 'BURKINA FASO'], flagCode: 'AO', isRegion: true, color: '#FFA500', nameShort: 'OUEST' }, 
                'Afrique de l\'Est': { countries: ['ETHIOPIE', 'SOUDAN', 'KENYA'], flagCode: 'AE', isRegion: true, color: '#008000', nameShort: 'EST' }, 
                'Afrique Centrale': { countries: ['CAMEROUN', 'RD CONGO', 'CONGO BRAZA', 'GABON', 'GUINEE EQUATORIALE'], flagCode: 'AC', isRegion: true, color: '#FF0000', nameShort: 'CENTRALE' }, 
                'Afrique Australe': { countries: ['ZAMBIE', 'AFS', 'ANGOLA', 'MADAGASCAR'], flagCode: 'AA', isRegion: true, color: '#0000FF', nameShort: 'AUSTRALE' } 
            };

            // Initialiser allRegions
            for (const regionName in regions) {
                allRegions[regionName] = { 
                    key: regionName, 
                    name: regions[regionName].nameShort, 
                    code: regions[regionName].flagCode, 
                    color: regions[regionName].color,
                    totalTrophies: 0, 
                    element: null, 
                    hasAppeared: false,
                    isRegion: true, 
                    countries: regions[regionName].countries
                };
            }

            // --- COUNTRY MAPPING & TRANSLATION ---
            const countryNameMap = {
                'EGYPTE': { code: 'EG', region: 'Afrique du Nord', names: { fr: '√âGYPTE', en: 'EGYPT', es: 'EGIPTO' } }, 
                'ETHIOPIE': { code: 'ET', region: 'Afrique de l\'Est', names: { fr: '√âTHIOPIE', en: 'ETHIOPIA', es: 'ETIOP√çA' } },
                'GHANA': { code: 'GH', region: 'Afrique de l\'Ouest', names: { fr: 'GHANA', en: 'GHANA', es: 'GHANA' } }, 
                'CAMEROUN': { code: 'CM', region: 'Afrique Centrale', names: { fr: 'CAMEROUN', en: 'CAMEROON', es: 'CAMER√öN' } },
                'COTE IVOIRE': { code: 'CI', region: 'Afrique de l\'Ouest', names: { fr: 'C√îTE D\'IVOIRE', en: 'IVORY COAST', es: 'COSTA DE MARFIL' } }, 
                'RD CONGO': { code: 'CD', region: 'Afrique Centrale', names: { fr: 'RD CONGO', en: 'DR CONGO', es: 'RD CONGO' } },
                'SOUDAN': { code: 'SD', region: 'Afrique de l\'Est', names: { fr: 'SOUDAN', en: 'SUDAN', es: 'SUD√ÅN' } }, 
                'CONGO BRAZA': { code: 'CG', region: 'Afrique Centrale', names: { fr: 'CONGO', en: 'CONGO', es: 'CONGO' } },
                'GUINEE CONAKRY': { code: 'GN', region: 'Afrique de l\'Ouest', names: { fr: 'GUIN√âE', en: 'GUINEA', es: 'GUINEA' } }, 
                'MAROC': { code: 'MA', region: 'Afrique du Nord', names: { fr: 'MAROC', en: 'MOROCCO', es: 'MARRUECOS' } },
                'ALGERIE': { code: 'DZ', region: 'Afrique du Nord', names: { fr: 'ALG√âRIE', en: 'ALGERIA', es: 'ARGELIA' } }, 
                'NIGERIA': { code: 'NG', region: 'Afrique de l\'Ouest', names: { fr: 'NIGERIA', en: 'NIGERIA', es: 'NIGERIA' } },
                'KENYA': { code: 'KE', region: 'Afrique de l\'Est', names: { fr: 'KENYA', en: 'KENYA', es: 'KENIA' } }, 
                'TUNISIE': { code: 'TN', region: 'Afrique du Nord', names: { fr: 'TUNISIE', en: 'TUNISIA', es: 'T√öNEZ' } },
                'ZAMBIE': { code: 'ZM', region: 'Afrique Australe', names: { fr: 'ZAMBIE', en: 'ZAMBIA', es: 'ZAMBIA' } }, 
                'AFS': { code: 'ZA', region: 'Afrique Australe', names: { fr: 'AFS', en: 'S. AFRICA', es: 'SUD√ÅFRICA' } },
                'ANGOLA': { code: 'AO', region: 'Afrique Australe', names: { fr: 'ANGOLA', en: 'ANGOLA', es: 'ANGOLA' } }, 
                'GAMBIE': { code: 'GM', region: 'Afrique de l\'Ouest', names: { fr: 'GAMBIE', en: 'GAMBIA', es: 'GAMBIA' } },
                'GUINEE EQUATORIALE': { code: 'GQ', region: 'Afrique Centrale', names: { fr: 'GUIN√âE √âQUAT.', en: 'EQ. GUINEA', es: 'GUINEA EC.' } }, 
                'LIBYE': { code: 'LY', region: 'Afrique du Nord', names: { fr: 'LIBYE', en: 'LIBYA', es: 'LIBIA' } },
                'MALI': { code: 'ML', region: 'Afrique de l\'Ouest', names: { fr: 'MALI', en: 'MALI', es: 'MALI' } }, 
                'GABON': { code: 'GA', region: 'Afrique Centrale', names: { fr: 'GABON', en: 'GABON', es: 'GAB√ìN' } },
                'BURKINA FASO': { code: 'BF', region: 'Afrique de l\'Ouest', names: { fr: 'BURKINA FASO', en: 'BURKINA', es: 'BURKINA FASO' } }, 
                'MADAGASCAR': { code: 'MG', region: 'Afrique Australe', names: { fr: 'MADAGASCAR', en: 'MADAGASCAR', es: 'MADAGASCAR' } },
                'SENEGAL': { code: 'SN', region: 'Afrique de l\'Ouest', names: { fr: 'S√âN√âGAL', en: 'SENEGAL', es: 'SENEGAL' } }
            };

            function getTranslatedCountryName(key, lang) {
                const map = countryNameMap[key];
                return map && map.names[lang] ? map.names[lang] : key;
            }

            // Fonction pour obtenir le nom traduit du gagnant (Club ou Pays/S√©lection) pour l'affichage dans la colonne
            function getTranslatedWinnerDisplay(winnerString, countryKey, clubName, lang) {
                const translatedCountry = getTranslatedCountryName(countryKey, lang);

                if (winnerString.includes(' ') && clubName.toLowerCase() !== countryKey.toLowerCase()) {
                    // C'est un club. On affiche le nom du club.
                    return clubName;
                } else {
                    // C'est une s√©lection nationale ou le nom du club est le m√™me que le pays.
                    return translatedCountry;
                }
            }


            // --- COMPETITION MAPPING & TRANSLATION ---
            // Cl√©s canoniques utilis√©es dans le JSON et pour la pond√©ration
            const competitionNameMap = {
                'CAN H': { fr: 'CAN H', en: 'AFCON M', es: 'CNA M' },
                'CAN F': { fr: 'CAN F', en: 'AFCON W', es: 'CNA F' },
                'CAN U23 H': { fr: 'CAN U23 H', en: 'AFCON U23M', es: 'CNA U23M' },
                'CAN U20 H': { fr: 'CAN U20 H', en: 'AFCON U20M', es: 'CNA U20M' },
                'CAN U20 F': { fr: 'CAN U20 F', en: 'AFCON U20W', es: 'CNA U20F' },
                'CAN U17 H': { fr: 'CAN U17 H', en: 'AFCON U17M', es: 'CNA U17M' },
                'CAN U17 F': { fr: 'CAN U17 F', en: 'AFCON U17W', es: 'CNA U17F' },
                'CHAN H': { fr: 'CHAN', en: 'CHAN', es: 'CHAN' },
                'LDC H': { fr: 'LDC H', en: 'CL MEN', es: 'LDC M' },
                'LDC F': { fr: 'LDC F', en: 'CL WOMEN', es: 'LDC F' },
                'SUPER H': { fr: 'SUPERCOUPE', en: 'SUPER CUP', es: 'SUPERCOPA' }, // Cl√© modifi√©e pour correspondre au JSON
                'ANC. CAF H': { fr: 'ANC. CAF', en: 'CAF CUP', es: 'ANT. CAF' },
                'ANC. VAINQUEUR COUPE H': { fr: 'VAINQ. COUPE', en: 'CWC', es: 'Copa C.' },
                'CAF H': { fr: 'COUPE CAF', en: 'CAF CONF', es: 'Copa CAF' },
                'FUTSAL H': { fr: 'FUTSAL H', en: 'FUTSAL M', es: 'FUTSAL M' },
                'FUTSAL F': { fr: 'FUTSAL F', en: 'FUTSAL W', es: 'FUTSAL F' },
                'BEACH H': { fr: 'BEACH SOC', en: 'BEACH SOC', es: 'F√öTBOL PLAYA' }
            };

            // Mapping des cl√©s du JSON (parfois sales) vers les cl√©s canoniques de competitionNameMap
            const jsonKeyToCanonicalKey = {
                'CAN H': 'CAN H',
                'CAN\nF': 'CAN F',
                'CAN U23\nH': 'CAN U23 H',
                'CAN U20\nH': 'CAN U20 H',
                'CAN U20\nF': 'CAN U20 F',
                'CAN U17\nH': 'CAN U17 H',
                'CAN U17\nF': 'CAN U17 F',
                'CHAN\nH': 'CHAN H',
                'LDC H': 'LDC H',
                'LDC F': 'LDC F',
                'SUPER \nH': 'SUPER H',
                'SUPER H': 'SUPER H', // Pour 2025
                'ANC. CAF\nH': 'ANC. CAF H',
                'ANC. VAINQUEUR\nCOUPE\nH': 'ANC. VAINQUEUR COUPE H',
                'CAF  H': 'CAF H', // Notez le double espace
                'CAF H': 'CAF H', // Pour 2025
                'FOOTSAL\nH': 'FUTSAL H',
                'FOOTSAL\nF': 'FUTSAL F',
                'BEACH\n H': 'BEACH H'
            };


            function getTranslatedCompName(key, lang) {
                const canonicalKey = jsonKeyToCanonicalKey[key] || key;
                const map = competitionNameMap[canonicalKey];
                // Fallback si la cl√© canonique n'est pas dans la map (ex: cl√© JSON brute)
                if (map && map[lang]) return map[lang];
                if (competitionNameMap[key] && competitionNameMap[key][lang]) return competitionNameMap[key][lang];
                return key;
            }

            // --- WINNER INFO EXTRACTION ---
            function getWinnerInfo(winnerString) {
                if (!winnerString) return { countryKey: null, clubName: null, code: null, count: 0, displayCount: '', isClub: false };

                let count = 1;
                const countMatch = winnerString.match(/\(x(\d+)\)/i);
                if (countMatch) {
                    count = parseInt(countMatch[1]);
                }
                const displayCount = count > 1 ? ` (x${count})` : '';

                const cleanString = winnerString.toUpperCase().replace(/\(X\d+\)/, '').trim();
                const parts = cleanString.split(/[\s\n]+/).filter(p => p.length > 0); // G√®re les sauts de ligne

                let countryKeyClean = null;
                let clubName = winnerString.trim().split('\n')[0].trim();

                for (let i = parts.length - 1; i >= 0; i--) {
                    let potentialKey = parts[i];

                    // V√©rifier si le pays est en deux mots (ex: RD CONGO, COTE IVOIRE)
                    if (i > 0) {
                        const compoundKey = `${parts[i - 1]} ${parts[i]}`;
                        if (countryNameMap[compoundKey]) {
                            countryKeyClean = compoundKey;
                            clubName = parts.slice(0, i - 1).join(' ');
                            break;
                        }
                    }

                    // V√©rifier si le pays est en un mot (ex: EGYPTE, MAROC)
                    if (countryNameMap[potentialKey]) {
                        countryKeyClean = potentialKey;
                        clubName = parts.slice(0, i).join(' ');
                        break;
                    }
                }

                if (!countryKeyClean && countryNameMap[cleanString]) {
                    // Cas o√π le vainqueur est le nom du pays seul
                    countryKeyClean = cleanString;
                    clubName = cleanString;
                }

                // Fallback pour le nom du club s'il est vide, on utilise le pays (pour les s√©lections)
                if (clubName.trim() === '') {
                    clubName = countryKeyClean;
                }

                // D√©terminer si c'est un club
                const isClub = countryKeyClean && clubName.trim().toLowerCase() !== countryKeyClean.toLowerCase();

                const info = countryNameMap[countryKeyClean];

                return { 
                    countryKey: countryKeyClean, 
                    clubName: clubName.trim(), 
                    code: info ? info.code : null, 
                    count: count, 
                    displayCount: displayCount,
                    isClub: isClub
                };
            }
            // --- END WINNER INFO EXTRACTION ---

            function cleanCompetitionName(name) { return name.replace(/\n/g, ' ').trim(); }
            function getCompetitionColor(compName) {
                // Utiliser la cl√© canonique pour la couleur
                const canonicalKey = jsonKeyToCanonicalKey[compName] || compName;
                if (!competitionColorMap[canonicalKey]) {
                    competitionColorMap[canonicalKey] = COMPETITION_COLORS[colorIndex % COMPETITION_COLORS.length];
                    colorIndex++;
                }
                return competitionColorMap[canonicalKey];
            }

            let animationStarted = false;

            // --- SCREEN/FILTER NAVIGATION ---

            window.showIntroScreen = function() {
                const lang = languageSelect.value;
                setLanguage(lang); 

                const langScreen = document.getElementById('language-screen');
                const startScreen = document.getElementById('start-screen');

                gsap.to(langScreen, { opacity: 0, visibility: 'hidden', duration: 0.3, onComplete: () => {
                    langScreen.style.display = 'none';
                    startScreen.style.display = 'flex';
                    gsap.to(startScreen, { opacity: 1, visibility: 'visible', duration: 0.3 });
                }});
            }

            window.showFilterScreen = function() {
                const startScreen = document.getElementById('start-screen');
                gsap.to(startScreen, { opacity: 0, visibility: 'hidden', duration: 0.3, onComplete: () => {
                    startScreen.style.display = 'none';

                    const filterScreen = document.getElementById('filter-screen');
                    filterScreen.style.display = 'flex';
                    gsap.to(filterScreen, { opacity: 1, visibility: 'visible', duration: 0.3 });

                    if (regionFiltersDiv.children.length === 0) {
                        initFilterElements(true); 
                    } else {
                        initFilterElements(false); 
                    }
                }});
            }

            window.launchRankingFromFilter = function() {
                applyFilters(); // Applique les filtres (y compris le mode de pond√©ration)

                const filterScreen = document.getElementById('filter-screen');
                gsap.to(filterScreen, { opacity: 0, visibility: 'hidden', duration: 0.3, onComplete: () => {
                    filterScreen.style.display = 'none';

                    if (!animationStarted) {
                        startAll(); 
                        animationStarted = true;
                    } else {
                         clearTimeout(timer);
                         gsap.globalTimeline.clear(); // Nettoyer les animations GSAP
                         
                         // R√©initialisation compl√®te pour relancer
                         allCountries = {}; 
                         for(const key in allRegions) { 
                             allRegions[key].totalTrophies = 0; 
                             allRegions[key].totalWeightedPoints = 0; // Ajout√©
                             allRegions[key].weightedPoints = 0; // Ajout√©
                             allRegions[key].element = null; 
                             allRegions[key].hasAppeared = false; 
                         } 
                         yearlyWins = {}; 
                         
                         parseFilteredData(); // Reparser les donn√©es avec les nouveaux filtres
                         createDOMElements(); // Recr√©er les √©l√©ments
                         startAnimation(); // Lancer la nouvelle animation
                    }
                }});
            }

            async function init() {
                try {
                    const response = await fetch(JSON_FILE_PATH);
                    if (!response.ok) {
                        throw new Error(`Erreur de chargement du JSON: ${response.statusText}`);
                    }
                    const rawJSON = await response.json();

                    await parseRawData(rawJSON); 
                    initEditionFilters();

                    languageSelect.value = currentLang; 
                    setLanguage(currentLang); 

                    document.getElementById('start-screen').style.display = 'none';
                    document.getElementById('filter-screen').style.display = 'none';
                    document.getElementById('language-screen').style.display = 'flex';

                    // Listener de pause/reprise sur le contenu principal
                    mainContentWrapper.addEventListener('click', togglePauseResume); 

                } catch (error) {
                    console.error("√âchec de l'initialisation:", error);
                    alert(`Erreur de chargement des donn√©es. Assurez-vous que le fichier ${JSON_FILE_PATH} est pr√©sent et valide.`);
                }
            }

            // --- PAUSE/RESUME LOGIC ---
            window.togglePauseResume = function() {
                if (!animationStarted || yearIndex >= filteredYears.length) return; 

                isPaused = !isPaused;

                if (isPaused) {
                    // Pause: Arr√™ter le timer et les animations GSAP
                    clearTimeout(timer);
                    gsap.globalTimeline.pause(); // Utiliser la timeline globale pour tout mettre en pause
                    pauseIndicator.style.display = 'block'; // Afficher l'indicateur
                } else {
                    // Resume: Cacher l'indicateur, reprendre GSAP, et relancer le timer
                    pauseIndicator.style.display = 'none'; 
                    gsap.globalTimeline.resume(); 
                    setTimeout(runNextYear, 0); // Relancer le cycle
                }
            }


            // --- FILTER INITIALIZATION & LOGIC ---

            function initFilterElements(checkAllByDefault) {
                let firstInit = regionFiltersDiv.children.length === 0;

                // --- 1. R√©gions ---
                if (firstInit) regionFiltersDiv.innerHTML = ''; 
                const regionFragment = document.createDocumentFragment();
                for (const regionName in regions) {
                    const id = `region-${regionName.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    const translatedRegionName = translateRegionName(regionName, currentLang);
                    let isChecked = firstInit ? checkAllByDefault : selectedRegions.has(regionName);
                    if (firstInit && isChecked) selectedRegions.add(regionName);

                    if (firstInit) {
                        const item = document.createElement('div');
                        item.className = 'filter-item';
                        item.innerHTML = `
                            <input type="checkbox" id="${id}" data-filter-type="region" data-filter-value="${regionName}" ${isChecked ? 'checked' : ''}>
                            <label for="${id}">${translatedRegionName}</label>
                        `;
                        regionFragment.appendChild(item);
                    } else {
                        const input = regionFiltersDiv.querySelector(`input[data-filter-value="${regionName}"]`);
                        if(input) {
                            input.checked = isChecked;
                            input.nextElementSibling.textContent = translatedRegionName;
                        }
                    }
                }
                if (firstInit) regionFiltersDiv.appendChild(regionFragment);

                // --- 2. Comp√©titions ---
                const allCompKeys = new Set();
                Object.values(rawYearlyData).forEach(comps => {
                    Object.keys(comps).forEach(key => allCompKeys.add(key));
                });
                
                if (firstInit) competitionFiltersDiv.innerHTML = '';
                const compFragment = document.createDocumentFragment();
                
                // Utiliser les cl√©s canoniques pour un affichage stable
                const sortedCanonicalKeys = Object.keys(competitionNameMap).sort();
                
                sortedCanonicalKeys.forEach(canonicalKey => {
                    // Trouver la/les cl√©(s) JSON correspondante(s)
                    const jsonKeys = Object.keys(jsonKeyToCanonicalKey).filter(k => jsonKeyToCanonicalKey[k] === canonicalKey);
                    
                    if (jsonKeys.length > 0) {
                        const id = `comp-${canonicalKey.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        const translatedName = getTranslatedCompName(jsonKeys[0], currentLang); // Utiliser la premi√®re cl√© JSON pour la traduction
                        
                        // V√©rifier si AU MOINS UNE des cl√©s JSON est coch√©e
                        let isChecked = firstInit ? checkAllByDefault : jsonKeys.some(k => selectedCompetitions.has(k));
                        if (firstInit && isChecked) {
                            jsonKeys.forEach(k => selectedCompetitions.add(k));
                        }
                        
                        // NOUVEAU: Logique pour afficher les points
                        const points = currentWeights[canonicalKey] || 0;
                        const pointsDisplay = `
                            <span class="competition-points-display" data-comp-key="${canonicalKey}" style="display: ${useWeightedRanking ? 'inline' : 'none'}">
                                (+${points} Pts)
                            </span>`;

                        if (firstInit) {
                            const item = document.createElement('div');
                            item.className = 'filter-item';
                            // Le data-filter-value doit contenir TOUTES les cl√©s JSON associ√©es
                            item.innerHTML = `
                                <input type="checkbox" id="${id}" data-filter-type="competition" data-filter-value="${jsonKeys.join(',')}" ${isChecked ? 'checked' : ''}>
                                <label for="${id}">${translatedName} (${canonicalKey})</label>
                                ${pointsDisplay}
                            `;
                            compFragment.appendChild(item);
                        } else {
                             const input = competitionFiltersDiv.querySelector(`input[id="${id}"]`);
                             if (input) {
                                input.checked = isChecked;
                                input.nextElementSibling.textContent = `${translatedName} (${canonicalKey})`;
                                // Mettre √† jour le span de points existant
                                const span = input.closest('.filter-item').querySelector('.competition-points-display');
                                if (span) {
                                    span.textContent = `(+${points} Pts)`;
                                    span.style.display = useWeightedRanking ? 'inline' : 'none';
                                }
                             }
                        }
                    }
                });

                if (firstInit) competitionFiltersDiv.appendChild(compFragment);

                // --- 3. Listeners (Une seule fois) ---
                if (!regionFiltersDiv.dataset.listenersAdded) {
                    document.getElementById('filter-screen').addEventListener('change', (e) => {
                        const target = e.target;
                        if (target.dataset.filterType === 'region') {
                            const value = target.dataset.filterValue;
                            if (target.checked) selectedRegions.add(value);
                            else selectedRegions.delete(value);
                        
                        } else if (target.dataset.filterType === 'competition') {
                            const jsonKeys = target.dataset.filterValue.split(',');
                            jsonKeys.forEach(key => {
                                if (target.checked) selectedCompetitions.add(key);
                                else selectedCompetitions.delete(key);
                            });
                        } else if (target.id === 'displayRegionRankCheckbox') {
                            displayRegionRank = target.checked;
                        }
                    });
                    regionFiltersDiv.dataset.listenersAdded = 'true';
                }

                displayRegionRankCheckbox.checked = displayRegionRank;
                displayRegionRankCheckbox.nextElementSibling.textContent = translations[currentLang].filter_region_rank_label;
            }

            function translateRegionName(name, lang) {
                 const names = {
                    'Afrique du Nord': { fr: 'Afrique du Nord', en: 'North Africa', es: '√Åfrica del Norte' },
                    'Afrique de l\'Ouest': { fr: 'Afrique de l\'Ouest', en: 'West Africa', es: '√Åfrica Occidental' },
                    'Afrique de l\'Est': { fr: 'Afrique de l\'Est', en: 'East Africa', es: '√Åfrica Oriental' },
                    'Afrique Centrale': { fr: 'Afrique Centrale', en: 'Central Africa', es: '√Åfrica Central' },
                    'Afrique Australe': { fr: 'Afrique Australe', en: 'Southern Africa', es: '√Åfrica Austral' }
                };
                return names[name] ? names[name][lang] || name : name;
            }

            function initEditionFilters() {
                startYearSelect.innerHTML = '';
                endYearSelect.innerHTML = '';

                sortedYears.forEach((year, index) => {
                    const startOption = document.createElement('option');
                    startOption.value = year;
                    startOption.textContent = year;
                    startYearSelect.appendChild(startOption);

                    const endOption = document.createElement('option');
                    endOption.value = year;
                    endOption.textContent = year;
                    endYearSelect.appendChild(endOption);

                    if (index === 0) startOption.selected = true;
                    if (index === sortedYears.length - 1) endOption.selected = true;
                });

                // Sync listeners
                startYearSelect.addEventListener('change', () => {
                    const startY = parseInt(startYearSelect.value);
                    const endY = parseInt(endYearSelect.value);
                    if (startY > endY) endYearSelect.value = startYearSelect.value;
                    startYear = startY;
                });

                endYearSelect.addEventListener('change', () => {
                    const startY = parseInt(startYearSelect.value);
                    const endY = parseInt(endYearSelect.value);
                    if (endY < startY) startYearSelect.value = endYearSelect.value;
                    endYear = endY;
                });

                startYear = parseInt(startYearSelect.value);
                endYear = parseInt(endYearSelect.value);
            }
            
            // --- DATA PARSING & FILTERING ---

            function parseRawData(data) {
                data.Annees.forEach(yearData => {
                    rawYearlyData[yearData.Annee] = yearData.competition;
                });
                sortedYears = Object.keys(rawYearlyData).sort((a, b) => parseInt(a) - parseInt(b));
            }
            
            function applyFilters() {
                // Les valeurs sont d√©j√† mises √† jour par les listeners
                // On r√©initialise l'√©tat avant de parser les donn√©es
                allCountries = {};
                for(const key in allRegions) { 
                    allRegions[key].totalTrophies = 0; 
                    allRegions[key].element = null; 
                    allRegions[key].hasAppeared = false; 
                } 
                yearlyWins = {};

                parseFilteredData();

                // createDOMElements() est maintenant appel√© dans launchRankingFromFilter
            }

            function parseFilteredData() {
                filteredYears = sortedYears.filter(year => 
                    parseInt(year) >= startYear && parseInt(year) <= endYear
                );

                filteredYears.forEach(year => {
                    const yearData = rawYearlyData[year];
                    const winsThisYear = {};

                    for (const compKey in yearData) {
                        // Filtre 1: Comp√©tition
                        if (!selectedCompetitions.has(compKey)) {
                            continue; 
                        }

                        const winnerRaw = yearData[compKey];
                        const winnerInfo = getWinnerInfo(winnerRaw);
                        const countryKey = winnerInfo.countryKey;
                        const count = winnerInfo.count;

                        if (countryKey && countryNameMap[countryKey]) {
                            const countryRegion = countryNameMap[countryKey].region;

                            // Filtre 2: R√©gion
                            if (!selectedRegions.has(countryRegion)) {
                                continue;
                            }

                            // 1. Initialiser le pays si n√©cessaire
                            if (!allCountries[countryKey]) {
                                const info = countryNameMap[countryKey];
                                allCountries[countryKey] = { 
                                    key: countryKey, 
                                    name: getTranslatedCountryName(countryKey, currentLang), 
                                    code: info.code, 
                                    totalTrophies: 0, 
                                    weightedPoints: 0, // Total potentiel de points
                                    totalWeightedPoints: 0, // Accumulation pour l'animation
                                    element: null, 
                                    hasAppeared: false,
                                    region: info.region,
                                    isRegion: false 
                                };
                            }

                            // (L'accumulation se fait dans updateRankingForYear)

                            // Stocker l'information compl√®te du vainqueur pour l'affichage de la comp√©tition
                            winsThisYear[compKey] = winnerInfo; 
                        }
                    }
                    if (Object.keys(winsThisYear).length > 0) { yearlyWins[year] = winsThisYear; }
                });

                // R√©initialiser les troph√©es √† 0 pour l'animation
                Object.values(allCountries).forEach(c => {
                    c.totalTrophies = 0;
                    c.totalWeightedPoints = 0;
                });
                Object.values(allRegions).forEach(r => {
                    r.totalTrophies = 0;
                    r.totalWeightedPoints = 0;
                });
                
                // Retirer les ann√©es qui n'ont plus d'√©v√©nements apr√®s filtrage
                filteredYears = filteredYears.filter(year => yearlyWins[year]);
            }

            // --- ANIMATION CORE ---

            function createDOMElements() {
                chart.innerHTML = ''; 
                gsap.globalTimeline.clear(); // Vider la timeline GSAP

                let rankingEntities = [];
                
                // 1. Initialiser tous les pays
                for (const key in countryNameMap) {
                    const info = countryNameMap[key];
                    if (!allCountries[key] && selectedRegions.has(info.region)) {
                         allCountries[key] = { 
                            key: key, 
                            name: getTranslatedCountryName(key, currentLang), 
                            code: info.code, 
                            totalTrophies: 0, 
                            weightedPoints: 0,
                            totalWeightedPoints: 0,
                            element: null, 
                            hasAppeared: false,
                            region: info.region,
                            isRegion: false 
                        };
                    }
                }
                
                // 2. Initialiser toutes les r√©gions
                for(const key in allRegions) { 
                    allRegions[key].totalTrophies = 0; 
                    allRegions[key].weightedPoints = 0;
                    allRegions[key].totalWeightedPoints = 0;
                    allRegions[key].element = null; 
                    allRegions[key].hasAppeared = false; 
                } 

                if (!displayRegionRank) {
                    Object.values(allCountries)
                        .filter(c => selectedRegions.has(c.region))
                        .forEach(c => rankingEntities.push(c));
                }

                if (displayRegionRank) {
                    Object.values(allRegions)
                        .filter(r => selectedRegions.has(r.key)) 
                        .forEach(r => rankingEntities.push(r));
                }

                rankingEntities.sort((a, b) => {
                    const nameA = a.isRegion ? translateRegionName(a.key, currentLang) : getTranslatedCountryName(a.key, currentLang);
                    const nameB = b.isRegion ? translateRegionName(b.key, currentLang) : getTranslatedCountryName(b.key, currentLang);
                    return nameA.localeCompare(nameB);
                });

                rankingEntities.forEach((entity) => {
                    const row = document.createElement('div');
                    row.className = 'country-row' + (entity.isRegion ? ' is-region' : '');

                    const flagCode = entity.code ? entity.code.toLowerCase() : 'xx';
                    let flagHtml = '';
                    let displayName = entity.isRegion ? translateRegionName(entity.key, currentLang) : getTranslatedCountryName(entity.key, currentLang);

                    if (entity.isRegion) {
                        flagHtml = `<div class="flag" data-region-code="${entity.code}" style="background-color: ${entity.color};"></div>`;
                    } else {
                        // Utiliser une source de drapeau fiable (ex: flagcdn)
                        const flagSrc = `https://flagcdn.com/w40/${flagCode}.png`;
                        flagHtml = `<img src="${flagSrc}" onerror="this.style.display='none'" alt="Flag ${displayName}" class="flag">`;
                    }

                    gsap.set(row, { opacity: 0, visibility: 'hidden' }); 

                    row.innerHTML = `<div class="country-info">
                            ${flagHtml}
                            <span class="country-name">${displayName}</span>
                            <div class="progress-container"><div class="progress-bar"></div></div>
                            <span class="trophy-count">0</span>
                        </div>`;
                    chart.appendChild(row);

                    if (entity.isRegion) {
                        allRegions[entity.key].element = row;
                    } else {
                        allCountries[entity.key].element = row;
                        allCountries[entity.key].name = displayName;
                    }
                });


                if (!allCompetitionsContainer) {
                    allCompetitionsContainer = document.createElement('div');
                    allCompetitionsContainer.id = 'all-competitions-scroll-container';
                    competitionsDisplayContainer.innerHTML = '';
                    competitionsDisplayContainer.appendChild(allCompetitionsContainer);
                }
                allCompetitionsContainer.innerHTML = ''; 
                gsap.set(allCompetitionsContainer, { position: 'relative', y: 0 }); 
            }

            function startAll() {
                // FIX: createDOMElements doit √™tre appel√© ici
                if (!allCompetitionsContainer || chart.children.length === 0) {
                    createDOMElements(); 
                }
                startAnimation();
            }

            function startAnimation() {
                yearIndex = 0; // R√©initialiser l'index
                isPaused = false; // Assurer que l'√©tat de pause est r√©initialis√©
                pauseIndicator.style.display = 'none';

                if (filteredYears.length > 0) { 
                    // Mise √† jour initiale pour la premi√®re ann√©e
                    updateCompetitionsDisplay(filteredYears[0], false);
                    updateRankingForYear(filteredYears[0]);
                    
                    yearIndex++; 
                    const firstYearDelay = BASE_SECONDS_PER_YEAR * 1000;
                    timer = setTimeout(runNextYear, firstYearDelay);
                } else {
                    yearDisplay.textContent = `${startYear}`; 
                    competitionsDisplayContainer.innerHTML = `<p class="no-competitions">${translations[currentLang].no_competitions_filtered}</p>`;
                }
            }
 
            function runNextYear() {
                if (isPaused) return;

                if (yearIndex >= filteredYears.length) { 
                    yearDisplay.textContent = translations[currentLang].final_year;
                    // Assurer que le dernier classement est affich√©
                    updateRankingForYear(filteredYears[filteredYears.length - 1]);
                    return;
                }

                const currentYear = filteredYears[yearIndex];
                const competitionsInYear = yearlyWins[currentYear];
                const numCompetitions = competitionsInYear ? Object.keys(competitionsInYear).length : 0;

                let delay = BASE_SECONDS_PER_YEAR;
                if (numCompetitions > COMPETITION_THRESHOLD) {
                    delay += (numCompetitions - COMPETITION_THRESHOLD) * SLOWDOWN_PER_COMPETITION;
                }

                updateRankingForYear(currentYear);
                updateCompetitionsDisplay(currentYear, true);

                yearIndex++; 
                timer = setTimeout(runNextYear, delay * 1000);
            }

            function updateRankingForYear(year) {
                yearDisplay.textContent = `${year}`; 

                // (La logique d'accumulation est g√©r√©e par la fonction modifi√©e plus bas)

                let rankedEntities = [];
                const sortKey = 'totalTrophies'; // Cl√© par d√©faut

                if (displayRegionRank) {
                    Object.values(allRegions)
                        .filter(region => region.totalTrophies > 0 && selectedRegions.has(region.key))
                        .forEach(region => rankedEntities.push(region));
                } else {
                    Object.values(allCountries)
                        .filter(country => country.totalTrophies > 0 && selectedRegions.has(country.region))
                        .forEach(country => rankedEntities.push(country));
                }

                rankedEntities.sort((a, b) => {
                    if (b.totalTrophies !== a.totalTrophies) {
                        return b.totalTrophies - a.totalTrophies;
                    }
                    const nameA = a.isRegion ? translateRegionName(a.key, currentLang) : getTranslatedCountryName(a.key, currentLang);
                    const nameB = b.isRegion ? translateRegionName(b.key, currentLang) : getTranslatedCountryName(b.key, currentLang);
                    return nameA.localeCompare(nameB); 
                });

                const maxTrophies = Math.max(1, rankedEntities[0] ? rankedEntities[0].totalTrophies : 0);
                chart.style.height = `${rankedEntities.length * ROW_HEIGHT}px`;

                rankedEntities.forEach((entity, index) => {
                    const countryRow = entity.element;
                    if (!countryRow) return;

                    const progressBar = countryRow.querySelector('.progress-bar');
                    const trophyCount = countryRow.querySelector('.trophy-count');
                    const countryNameSpan = countryRow.querySelector('.country-name');
                    
                    const valueToDisplay = entity.totalTrophies;
                    const displayName = entity.isRegion ? translateRegionName(entity.key, currentLang) : getTranslatedCountryName(entity.key, currentLang);
                    countryNameSpan.textContent = displayName;

                    const newY = index * ROW_HEIGHT;
                    const rank = index + 1; 

                    let progressBarBackground = 'linear-gradient(90deg, #FFD700, #DAA520)'; 

                    if (entity.isRegion) {
                        progressBarBackground = `linear-gradient(90deg, ${entity.color}, ${entity.color}AA)`; 
                    } else {
                        if (rank === 2) {
                            progressBarBackground = 'linear-gradient(90deg, #C0C0C0, #A9A9A9)'; 
                        } else if (rank === 3) {
                            progressBarBackground = 'linear-gradient(90deg, #CD7F32, #B87333)'; 
                        } else if (rank > 3) {
                            progressBarBackground = 'linear-gradient(90deg, #4e73df, #224abe)'; 
                        }
                    }

                    if (valueToDisplay > 0 && !entity.hasAppeared) {
                        entity.hasAppeared = true;
                        gsap.fromTo(countryRow, { y: newY, opacity: 0, visibility: 'visible' }, { y: newY, opacity: 1, duration: 0.8, ease: 'power3.out' });
                    } 
                    else if (entity.hasAppeared) {
                        gsap.to(countryRow, { y: newY, duration: .5, ease: 'power3.inOut' });
                        gsap.set(countryRow, { visibility: 'visible', opacity: 1 });
                    }

                    if (entity.hasAppeared) {
                        gsap.to(progressBar, { 
                            width: `${(valueToDisplay / maxTrophies) * 100}%`, 
                            background: progressBarBackground, 
                            duration: 0.5, 
                            ease: 'power3.inOut' 
                        });
                        gsap.to(trophyCount, { 
                            innerText: valueToDisplay, 
                            duration: 0.8, 
                            snap: { innerText: 1 }, 
                            ease: 'power1.inOut' 
                        });
                    }
                });

                // Gestion de la visibilit√©
                Object.values(allCountries).forEach(country => {
                    const isVisible = !displayRegionRank && country.totalTrophies > 0 && selectedRegions.has(country.region);
                    if (!isVisible && country.element && country.hasAppeared) {
                        gsap.to(country.element, { opacity: 0, visibility: 'hidden', duration: 0.3 });
                        country.hasAppeared = false; 
                    }
                });

                 Object.values(allRegions).forEach(region => {
                    const isVisible = displayRegionRank && region.totalTrophies > 0 && selectedRegions.has(region.key);
                    if (!isVisible && region.element && region.hasAppeared) {
                        gsap.to(region.element, { opacity: 0, visibility: 'hidden', duration: 0.3 });
                        region.hasAppeared = false; 
                    }
                });
            }

            function updateCompetitionsDisplay(year, animate = true) {
                // FIX: S'assurer que allCompetitionsContainer existe (corrig√© dans startAll)
                if (!allCompetitionsContainer) {
                     console.error("allCompetitionsContainer est null dans updateCompetitionsDisplay");
                     return 0;
                }

                const competitions = yearlyWins[year] || {}; 
                const compKeys = Object.keys(competitions);

                const yearContainer = document.createElement('div');
                yearContainer.className = 'year-group-container';

                let totalYearHeight = 0; 

                const separator = document.createElement('div');
                separator.className = 'year-separator';
                separator.innerHTML = `<span class="year-separator-text">${year}</span>`;
                yearContainer.appendChild(separator);
                totalYearHeight += SEPARATOR_HEIGHT; 

                let validCompetitionsCount = 0;

                compKeys.forEach((compNameKey) => {
                    const winnerInfo = competitions[compNameKey];
                    if (!winnerInfo) return; // S√©curit√©
                    
                    const translatedCompName = getTranslatedCompName(compNameKey, currentLang); 
                    const competitionColor = getCompetitionColor(compNameKey); // Utiliser la cl√© JSON pour la couleur

                    let winnerDisplay;
                    if (winnerInfo.isClub) {
                        winnerDisplay = `${winnerInfo.clubName}${winnerInfo.displayCount}`;
                    } else {
                        const translatedCountry = getTranslatedCountryName(winnerInfo.countryKey, currentLang);
                        winnerDisplay = `${translatedCountry}${winnerInfo.displayCount}`;
                    }

                    const flagCode = winnerInfo.code ? winnerInfo.code.toLowerCase() : 'xx';
                    const flagSrc = `https://flagcdn.com/w40/${flagCode}.png`;

                    const box = document.createElement('div');
                    box.className = 'competition-box';
                    box.innerHTML = `
                        <div id="flag-column">
                            <img src="${flagSrc}" onerror="this.style.display='none'" alt="Flag ${winnerInfo.countryKey || 'N/A'}">
                        </div>
                        <div id="right-column">
                            <div id="comp-info-case" style="background-color: ${competitionColor};">
                                <span class="comp-name-line">${translatedCompName}</span>
                            </div>
                            <div id="winner-name-case">
                                <span>${winnerDisplay}</span>
                            </div>
                        </div>
                    `;

                    yearContainer.appendChild(box);
                    totalYearHeight += COMP_BOX_HEIGHT + COMP_BOX_GAP;
                    validCompetitionsCount++;
                });

                if (validCompetitionsCount === 0) {
                    // Ne rien ajouter si aucune comp√©tition valide
                } else {
                    totalYearHeight -= COMP_BOX_GAP; 
                }

                yearContainer.style.marginBottom = `${COMP_BOX_GAP}px`;
                totalYearHeight += COMP_BOX_GAP; 

                const scrollDistance = totalYearHeight; 
                gsap.set(yearContainer, { height: totalYearHeight - COMP_BOX_GAP }); 
                
                // C'EST ICI LE BUG. allCompetitionsContainer √©tait null.
                allCompetitionsContainer.prepend(yearContainer);

                if (animate) {
                    gsap.set(allCompetitionsContainer, { y: -scrollDistance });
                    gsap.to(allCompetitionsContainer, {
                        y: 0, 
                        duration: BASE_SECONDS_PER_YEAR * 0.9, 
                        ease: 'power3.out'
                    });
                }
                
                return scrollDistance; 
            }


            // --- DEBUT NOUVEAU: LOGIQUE DES POINTS POND√âR√âS (Version 4.0 - Int√©grant les pastilles) ---
            
            // 1. D√©finition des points par d√©faut (bas√© sur les cl√©s canoniques)
            const DEFAULT_WEIGHTS = {
                'CAN H': 100,
                'CAN F': 100,
                'CHAN H': 50,
                'CAN U23 H': 25,
                // 'CAN U23 F': 25, // Pas de cl√© canonique pour U23 F
                'CAN U20 H': 20,
                'CAN U20 F': 20,
                'CAN U17 H': 15,
                'CAN U17 F': 15,
                'LDC H': 70,
                'LDC F': 70,
                'CAF H': 50,
                'ANC. VAINQUEUR COUPE H': 40,
                'ANC. CAF H': 40,
                'SUPER H': 30,
                'FUTSAL H': 40,
                'FUTSAL F': 40,
                'BEACH H': 40
            };

            let currentWeights = { ...DEFAULT_WEIGHTS };
            // S'assurer que toutes les cl√©s canoniques ont au moins 0
            Object.keys(competitionNameMap).forEach(key => {
                if (currentWeights[key] === undefined) currentWeights[key] = 0;
            });

            let useWeightedRanking = false; 

            // 2. Ajout des traductions
            translations.fr.filter_ranking_mode_title = "Mode de Classement";
            translations.fr.rank_mode_trophies = "Classement par Titres (D√©faut)";
            translations.fr.rank_mode_weighted = "Classement par Points Pond√©r√©s";
            translations.fr.filter_weights_title = "4. Points par Comp√©tition";
            translations.fr.filter_weights_instruction = "Ajustez les points attribu√©s par titre.";
            translations.fr.filter_reset_weights = "R√©initialiser les Points";
            translations.fr.weighted_points_label = "Pts"; // Pour le compteur

            translations.en.filter_ranking_mode_title = "Ranking Mode";
            translations.en.rank_mode_trophies = "Ranking by Trophies (Default)";
            translations.en.rank_mode_weighted = "Ranking by Weighted Points";
            translations.en.filter_weights_title = "4. Competition Weights";
            translations.en.filter_weights_instruction = "Adjust the points awarded per trophy.";
            translations.en.filter_reset_weights = "Reset Weights";
            translations.en.weighted_points_label = "Pts";

            translations.es.filter_ranking_mode_title = "Modo de Clasificaci√≥n";
            translations.es.rank_mode_trophies = "Clasificaci√≥n por T√≠tulos (Defecto)";
            translations.es.rank_mode_weighted = "Clasificaci√≥n por Puntos Ponderados";
            translations.es.filter_weights_title = "4. Puntos por Competici√≥n";
            translations.es.filter_weights_instruction = "Ajuste los puntos otorgados por t√≠tulo.";
            translations.es.filter_reset_weights = "Restablecer Puntos";
            translations.es.weighted_points_label = "Pts";
            
            // 3. Fonctions UI pour les points
            function createWeightingUI() {
                const filterScreen = document.getElementById('filter-screen');
                const screenContent = filterScreen.querySelector('.screen-content');
                
                // S'assurer que les sections ne sont pas dupliqu√©es
                if (document.getElementById('ranking-mode-section')) return;

                // 1. Ajouter la s√©lection du mode de classement (Points vs Titres)
                const modeFilterSection = document.createElement('div');
                modeFilterSection.className = 'filter-section';
                modeFilterSection.id = 'ranking-mode-section';
                modeFilterSection.innerHTML = `
                    <h3 data-lang-key="filter_ranking_mode_title">Mode de Classement</h3>
                    <div class="filter-item">
                        <input type="radio" id="rankModeTrophies" name="rankingMode" value="trophies" ${useWeightedRanking ? '' : 'checked'}>
                        <label for="rankModeTrophies" data-lang-key="rank_mode_trophies">Classement par Titres (D√©faut)</label>
                    </div>
                    <div class="filter-item">
                        <input type="radio" id="rankModeWeighted" name="rankingMode" value="weighted" ${useWeightedRanking ? 'checked' : ''}>
                        <label for="rankModeWeighted" data-lang-key="rank_mode_weighted">Classement par Points Pond√©r√©s</label>
                    </div>
                `;
                // Placer en haut du screen-content, avant la section 1.
                screenContent.insertBefore(modeFilterSection, screenContent.firstChild); 

                // 2. Ajouter la section de configuration des points (pond√©ration)
                const weightFilterSection = document.createElement('div');
                weightFilterSection.className = 'filter-section';
                weightFilterSection.id = 'weight-filter-section';
                weightFilterSection.style.display = useWeightedRanking ? 'block' : 'none'; // Afficher/Masquer
                weightFilterSection.innerHTML = `
                    <h3 data-lang-key="filter_weights_title">4. Points par Comp√©tition</h3>
                    <p style="font-size: 0.75em; color: #777; margin-bottom: 10px;" data-lang-key="filter_weights_instruction">Ajustez les points attribu√©s par titre.</p>
                    <div class="filter-grid" id="weight-input-grid">
                        </div>
                    <div style="text-align: center; margin-top: 15px;">
                        <button class="next-btn" id="resetWeightsButton" type="button" data-lang-key="filter_reset_weights" style="background-color: #f6c23e;">R√©initialiser les Points</button>
                    </div>
                `;
                 // Ins√©rer apr√®s la section 3 (P√©riode)
                const periodFilterSection = screenContent.querySelector('.filter-section:nth-child(4)'); // 4√®me car le mode est 1er
                if (periodFilterSection) {
                    periodFilterSection.parentNode.insertBefore(weightFilterSection, periodFilterSection.nextElementSibling);
                } else {
                    screenContent.appendChild(weightFilterSection); // Fallback
                }
                
                // 3. Remplir les inputs de pond√©ration
                updateWeightInputs();

                // 4. Listeners (attach√©s une seule fois)
                if (!modeFilterSection.dataset.listenersAdded) {
                    modeFilterSection.addEventListener('change', (e) => {
                        if (e.target.name === 'rankingMode') {
                            useWeightedRanking = (e.target.value === 'weighted');
                            document.getElementById('weight-filter-section').style.display = useWeightedRanking ? 'block' : 'none';
                            updateCompetitionPointDisplays(useWeightedRanking); // NOUVEAU
                            updateTrophyCountLabelStyle();
                        }
                    });

                    weightFilterSection.addEventListener('click', (e) => {
                         if (e.target.id === 'resetWeightsButton') {
                            if (confirm('Voulez-vous r√©initialiser tous les points √† leurs valeurs par d√©faut ?')) {
                                // R√©initialiser aux valeurs par d√©faut
                                currentWeights = { ...DEFAULT_WEIGHTS };
                                // Mettre √† jour les cl√©s manquantes √† 0
                                Object.keys(competitionNameMap).forEach(key => {
                                     if(currentWeights[key] === undefined) currentWeights[key] = 0;
                                });
                                updateWeightInputs(); // Mise √† jour de l'UI (inputs ET spans)
                            }
                         }
                    });

                    weightFilterSection.addEventListener('change', (e) => {
                        if (e.target.tagName === 'INPUT' && e.target.type === 'number' && e.target.dataset.compKey) {
                            const key = e.target.dataset.compKey;
                            let value = parseInt(e.target.value);
                            if (isNaN(value) || value < 0) value = 0;
                            currentWeights[key] = value;
                            e.target.value = value; // Assainir l'input
                            
                            // NOUVEAU: Mettre √† jour le span dans la section 2
                            const spanDisplay = competitionFiltersDiv.querySelector(`.competition-points-display[data-comp-key="${key}"]`);
                            if (spanDisplay) spanDisplay.textContent = `(+${value} Pts)`;
                        }
                    });
                    modeFilterSection.dataset.listenersAdded = 'true';
                }

                // Mettre √† jour les labels
                updateRankingModeLabels();
                updateWeightSectionLabels();
            }

            // Remplit la grille de configuration des points (Section 4) ET met √† jour les spans (Section 2)
            function updateWeightInputs() {
                const weightInputGrid = document.getElementById('weight-input-grid');
                if (!weightInputGrid) return;
                weightInputGrid.innerHTML = '';
                
                const sortedCanonicalKeys = Object.keys(competitionNameMap).sort();

                sortedCanonicalKeys.forEach(canonicalKey => {
                    const translatedName = (competitionNameMap[canonicalKey] && competitionNameMap[canonicalKey][currentLang]) || canonicalKey;
                    const currentWeight = currentWeights[canonicalKey] !== undefined ? currentWeights[canonicalKey] : (DEFAULT_WEIGHTS[canonicalKey] || 0);
                    currentWeights[canonicalKey] = currentWeight;

                    // Mettre √† jour l'input (Section 4)
                    const item = document.createElement('div');
                    item.className = 'edition-group'; 
                    item.style.marginBottom = '8px';
                    item.innerHTML = `
                        <label for="weight-${canonicalKey}">${translatedName} (${canonicalKey})</label>
                        <input type="number" id="weight-${canonicalKey}" data-comp-key="${canonicalKey}" value="${currentWeight}" min="0">
                    `;
                    weightInputGrid.appendChild(item);
                    
                    // Mettre √† jour le span (Section 2)
                    const spanDisplay = competitionFiltersDiv.querySelector(`.competition-points-display[data-comp-key="${canonicalKey}"]`);
                    if (spanDisplay) spanDisplay.textContent = `(+${currentWeight} Pts)`;
                });
            }
            
            // NOUVEAU: Fonction pour afficher/masquer les points dans la section 2
            function updateCompetitionPointDisplays(visible) {
                const spans = competitionFiltersDiv.querySelectorAll('.competition-points-display');
                spans.forEach(span => {
                    span.style.display = visible ? 'inline' : 'none';
                });
            }

            // Met √† jour les labels du s√©lecteur de mode
            function updateRankingModeLabels() {
                 const rankModeTrophies = document.getElementById('rankModeTrophies');
                 const rankModeWeighted = document.getElementById('rankModeWeighted');
                 if (rankModeTrophies) rankModeTrophies.nextElementSibling.textContent = translations[currentLang].rank_mode_trophies;
                 if (rankModeWeighted) rankModeWeighted.nextElementSibling.textContent = translations[currentLang].rank_mode_weighted;
                 
                 const title = document.querySelector('#ranking-mode-section h3');
                 if (title) title.textContent = translations[currentLang].filter_ranking_mode_title;
            }

            // Met √† jour les labels de la section de configuration des points
            function updateWeightSectionLabels() {
                 const weightFilterSection = document.getElementById('weight-filter-section');
                 if (!weightFilterSection) return;
                 weightFilterSection.querySelector('h3').textContent = translations[currentLang].filter_weights_title;
                 weightFilterSection.querySelector('p').textContent = translations[currentLang].filter_weights_instruction;
                 document.getElementById('resetWeightsButton').textContent = translations[currentLang].filter_reset_weights;
            }

            // Ajuste le style (largeur) du compteur de troph√©es/points
            function updateTrophyCountLabelStyle() {
                const trophyCountElements = document.querySelectorAll('.trophy-count');
                const width = useWeightedRanking ? '60px' : '40px';
                const fontSize = useWeightedRanking ? '1em' : '1.1em';
                
                trophyCountElements.forEach(el => {
                    el.style.width = width;
                    el.style.fontSize = fontSize;
                });
            }
            
            // MODIFI√â: Fonction pour peupler les pastilles en fond
            function populateBackgroundPills() {
                backgroundPillsContainer.innerHTML = ''; // Vider
                if (!useWeightedRanking) return; // Ne rien faire si mode Titres
                
                // D√©finir les pastilles √† afficher (cl√©s canoniques et couleurs)
                const pillsToShow = [
                    { key: 'CAN H', color: '#E74C3C' },
                    { key: 'LDC H', color: '#3498DB' },
                    { key: 'CAF H', color: '#2ECC71' },
                    { key: 'CHAN H', color: '#F39C12' },
                    { key: 'SUPER H', color: '#9B59B6' },
                    { key: 'ANC. VAINQUEUR COUPE H', color: '#34495E' },
                    { key: 'ANC. CAF H', color: '#1ABC9C' },
                    { key: 'CAN U23 H', color: '#E67E22' },
                    { key: 'CAN U20 H', color: '#7F8C8D' },
                ];
                
                // Get min/max points *from the pills we are showing*
                const validPoints = pillsToShow.map(p => currentWeights[p.key] || 0).filter(p => p > 0);
                if (validPoints.length === 0) return;
                
                const minPoints = Math.min(...validPoints);
                const maxPoints = Math.max(...validPoints);
                const MIN_SIZE = 35; // px
                const MAX_SIZE = 75; // px
                const MIN_FONT = 0.7; // em
                const MAX_FONT = 0.9; // em
                
                // Simple linear scaling function
                const scale = (num, in_min, in_max, out_min, out_max) => {
                    // Handle division by zero if all points are the same
                    if (in_max === in_min) return (out_min + out_max) / 2;
                    return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
                };

                pillsToShow.forEach(pill => {
                    const points = currentWeights[pill.key] || 0;
                    if (points > 0) {
                        const label = (competitionNameMap[pill.key] ? competitionNameMap[pill.key][currentLang] : pill.key);
                        const size = scale(points, minPoints, maxPoints, MIN_SIZE, MAX_SIZE);
                        const fontSize = scale(points, minPoints, maxPoints, MIN_FONT, MAX_FONT);
                        
                        // Random cluster effect
                        const transX = Math.random() * 15 - 7.5; // -7.5px to +7.5px
                        const transY = Math.random() * 10 - 5;   // -5px to +5px
                        
                        backgroundPillsContainer.innerHTML += `
                            <span class="point-pill" style="
                                background-color: ${pill.color};
                                width: ${size}px;
                                height: ${size}px;
                                font-size: ${fontSize}em;
                                transform: translate(${transX}px, ${transY}px);
                            ">
                                ${label}<br>${points} Pts
                            </span>`;
                    }
                });
            }


            // 4. Modification des fonctions existantes (Monkey-Patching)

            // A. MODIFICATION DE `showFilterScreen()` (POUR AFFICHER L'OPTION)
            const originalShowFilterScreen = window.showFilterScreen;
            window.showFilterScreen = function() {
                // Appel de l'original (qui g√®re l'affichage et initFilterElements)
                originalShowFilterScreen();
                
                // Cr√©er l'UI de pond√©ration si ce n'est pas d√©j√† fait
                if (!document.getElementById('ranking-mode-section')) {
                    createWeightingUI();
                }
                // Mettre √† jour les labels (au cas o√π la langue a chang√©)
                updateRankingModeLabels();
                updateWeightSectionLabels();
                // Mettre √† jour la visibilit√© des spans de points
                updateCompetitionPointDisplays(useWeightedRanking);
            }

            // B. MODIFICATION DE `startAll()` (POUR CORRIGER LE BUG)
            const originalStartAll = startAll;
            startAll = function() {
                // FIX: createDOMElements doit √™tre appel√© ici
                if (!allCompetitionsContainer || chart.children.length === 0) {
                    createDOMElements(); 
                }
                
                // NOUVEAU: Peupler les pastilles de fond
                populateBackgroundPills();
                
                // Appel de l'original (qui appelle startAnimation)
                originalStartAll();
            }

            // C. MODIFICATION DE `applyFilters()`
            const originalApplyFilters = applyFilters;
            applyFilters = function() {
                // Lire l'√©tat du mode de classement
                const selectedModeElement = document.querySelector('input[name="rankingMode"]:checked');
                useWeightedRanking = (selectedModeElement && selectedModeElement.value === 'weighted');

                // Lancer la fonction originale (qui lit les filtres et appelle parseFilteredData)
                originalApplyFilters();
                
                // Mettre √† jour le style du compteur (au cas o√π les √©l√©ments existent d√©j√†)
                updateTrophyCountLabelStyle();
                
                // Recalculer les totaux de points potentiels APRES parseFilteredData
                recalculateWeightedPointsTotals();
            }
            
            // Nouvelle fonction pour calculer les totaux de points (appel√©e par applyFilters)
            function recalculateWeightedPointsTotals() {
                 // 1. R√©initialiser les totaux de points
                Object.values(allCountries).forEach(c => c.weightedPoints = 0);
                Object.values(allRegions).forEach(r => r.weightedPoints = 0);
                
                // 2. Parcourir les ann√©es filtr√©es et accumuler les points totaux (potentiels)
                filteredYears.forEach(year => {
                    if (yearlyWins[year]) {
                        for (const compKey in yearlyWins[year]) { // compKey est la cl√© JSON
                            const winnerInfo = yearlyWins[year][compKey];
                            if (!winnerInfo) continue;
                            
                            const countryKey = winnerInfo.countryKey;
                            const winCount = winnerInfo.count;
                            
                            // Trouver la cl√© canonique pour obtenir les points
                            const canonicalKey = jsonKeyToCanonicalKey[compKey];
                            const points = (canonicalKey && currentWeights[canonicalKey] !== undefined) ? currentWeights[canonicalKey] : 0;
                            const totalPoints = points * winCount;

                            if (allCountries[countryKey]) {
                                allCountries[countryKey].weightedPoints += totalPoints; // Total pour le filtre
                                const regionKey = allCountries[countryKey].region;
                                if (allRegions[regionKey]) {
                                    allRegions[regionKey].weightedPoints += totalPoints;
                                }
                            }
                        }
                    }
                });
            }

            // D. MODIFICATION DE `parseFilteredData()`
            const originalParseFilteredData = parseFilteredData;
            parseFilteredData = function() {
                // Appel de l'ancienne fonction (qui peuple allCountries, yearlyWins, etc.)
                originalParseFilteredData();
                
                // (La logique de calcul des points a √©t√© d√©plac√©e dans recalculateWeightedPointsTotals)
                // On s'assure juste que les champs pour l'animation sont √† 0
                 Object.values(allCountries).forEach(c => {
                    c.totalTrophies = 0;
                    c.totalWeightedPoints = 0;
                 });
                 Object.values(allRegions).forEach(r => {
                    r.totalTrophies = 0;
                    r.totalWeightedPoints = 0;
                 });
            }


            // E. MODIFICATION DE `updateRankingForYear()`
            const originalUpdateRankingForYear = updateRankingForYear;
            updateRankingForYear = function(year) {
                yearDisplay.textContent = `${year}`; 

                // 1. Accumulation des troph√©es ET des points pour l'ann√©e en cours
                if (yearlyWins[year]) {
                    for (const compKey in yearlyWins[year]) { // compKey est la cl√© JSON
                        const winnerInfo = yearlyWins[year][compKey];
                        const countryKey = winnerInfo.countryKey;
                        const winCount = winnerInfo.count;
                        
                        // Trouver la cl√© canonique pour obtenir les points
                        const canonicalKey = jsonKeyToCanonicalKey[compKey];
                        const points = (canonicalKey && currentWeights[canonicalKey] !== undefined) ? currentWeights[canonicalKey] : 0;
                        const totalPoints = points * winCount;

                        if(allCountries[countryKey]) {
                             // Accumuler les deux
                             allCountries[countryKey].totalTrophies += winCount; 
                             allCountries[countryKey].totalWeightedPoints += totalPoints;

                             const regionKey = allCountries[countryKey].region;
                             if(allRegions[regionKey]) {
                                 allRegions[regionKey].totalTrophies += winCount;
                                 allRegions[regionKey].totalWeightedPoints += totalPoints;
                             }
                        }
                    }
                }

                // 2. Pr√©paration des entit√©s class√©es
                let rankedEntities = [];
                // D√©terminer quelle cl√© utiliser pour le tri ET le filtrage d'affichage
                const sortKey = useWeightedRanking ? 'totalWeightedPoints' : 'totalTrophies';
                
                // Cl√© pour le filtre de visibilit√© (bas√© sur le total *potentiel* calcul√© dans recalculateWeightedPointsTotals)
                const filterKey = useWeightedRanking ? 'weightedPoints' : 'totalTrophies';

                if (displayRegionRank) {
                    // Pour les r√©gions, on filtre sur le total accumul√© (sortKey) OU le total potentiel (filterKey)
                    Object.values(allRegions)
                        .filter(region => (region[sortKey] > 0 || region[filterKey] > 0) && selectedRegions.has(region.key))
                        .forEach(region => rankedEntities.push(region));
                } else {
                    Object.values(allCountries)
                        .filter(country => (country[sortKey] > 0 || country[filterKey] > 0) && selectedRegions.has(country.region))
                        .forEach(country => rankedEntities.push(country));
                }
                
                // 3. Tri
                rankedEntities.sort((a, b) => {
                    if (b[sortKey] !== a[sortKey]) {
                        return b[sortKey] - a[sortKey];
                    }
                    const nameA = a.isRegion ? translateRegionName(a.key, currentLang) : getTranslatedCountryName(a.key, currentLang);
                    const nameB = b.isRegion ? translateRegionName(b.key, currentLang) : getTranslatedCountryName(b.key, currentLang);
                    return nameA.localeCompare(nameB); 
                });

                // 4. Animation GSAP
                const maxTrophiesOrPoints = Math.max(1, rankedEntities[0] ? rankedEntities[0][sortKey] : 0);
                chart.style.height = `${rankedEntities.length * ROW_HEIGHT}px`;

                rankedEntities.forEach((entity, index) => {
                    const countryRow = entity.element;
                    if (!countryRow) return;

                    const progressBar = countryRow.querySelector('.progress-bar');
                    const trophyCount = countryRow.querySelector('.trophy-count');
                    const countryNameSpan = countryRow.querySelector('.country-name');
                    
                    const valueToDisplay = entity[sortKey]; // Nombre de troph√©es OU de points
                    const displayName = entity.isRegion ? translateRegionName(entity.key, currentLang) : getTranslatedCountryName(entity.key, currentLang);
                    countryNameSpan.textContent = displayName;

                    const newY = index * ROW_HEIGHT;
                    const rank = index + 1; 

                    let progressBarBackground = 'linear-gradient(90deg, #FFD700, #DAA520)'; 
                    if (entity.isRegion) {
                        progressBarBackground = `linear-gradient(90deg, ${entity.color}, ${entity.color}AA)`; 
                    } else if (rank === 2) {
                        progressBarBackground = 'linear-gradient(90deg, #C0C0C0, #A9A9A9)'; 
                    } else if (rank === 3) {
                        progressBarBackground = 'linear-gradient(90deg, #CD7F32, #B87333)'; 
                    } else if (rank > 3) {
                        progressBarBackground = 'linear-gradient(90deg, #4e73df, #224abe)'; 
                    }

                    if (valueToDisplay > 0 && !entity.hasAppeared) {
                        entity.hasAppeared = true;
                        gsap.fromTo(countryRow, { y: newY, opacity: 0, visibility: 'visible' }, { y: newY, opacity: 1, duration: 0.8, ease: 'power3.out' });
                    } 
                    else if (entity.hasAppeared) {
                        gsap.to(countryRow, { y: newY, duration: .5, ease: 'power3.inOut' });
                        gsap.set(countryRow, { visibility: 'visible', opacity: 1 });
                    } else if (valueToDisplay === 0 && entity.hasAppeared) {
                        // Cas o√π l'entit√© retombe √† 0 (ex: changement de filtre)
                        gsap.to(countryRow, { opacity: 0, visibility: 'hidden', duration: 0.3 });
                        entity.hasAppeared = false; 
                    }

                    if (entity.hasAppeared) {
                        gsap.to(progressBar, { 
                            width: `${(valueToDisplay / maxTrophiesOrPoints) * 100}%`, 
                            background: progressBarBackground, 
                            duration: 0.5, 
                            ease: 'power3.inOut' 
                        });
                        gsap.to(trophyCount, { 
                            innerText: valueToDisplay, 
                            duration: 0.8, 
                            snap: { innerText: 1 }, 
                            ease: 'power1.inOut' 
                        });
                        
                        // Mise √† jour du style du compteur
                        trophyCount.style.width = useWeightedRanking ? '60px' : '40px';
                        trophyCount.style.fontSize = useWeightedRanking ? '1em' : '1.1em';
                    }
                });

                // Gestion de la visibilit√© (bas√© sur le total *potentiel* pour √©viter le clignotement)
                const visibilityKey = useWeightedRanking ? 'weightedPoints' : 'totalTrophies';

                Object.values(allCountries).forEach(country => {
                    const isVisible = !displayRegionRank && (country[sortKey] > 0 || country[visibilityKey] > 0) && selectedRegions.has(country.region);
                    if (!isVisible && country.element && country.hasAppeared) {
                        gsap.to(country.element, { opacity: 0, visibility: 'hidden', duration: 0.3 });
                        country.hasAppeared = false; 
                    }
                });

                 Object.values(allRegions).forEach(region => {
                    const isVisible = displayRegionRank && (region[sortKey] > 0 || region[visibilityKey] > 0) && selectedRegions.has(region.key);
                    if (!isVisible && region.element && region.hasAppeared) {
                        gsap.to(region.element, { opacity: 0, visibility: 'hidden', duration: 0.3 });
                        region.hasAppeared = false; 
                    }
                });
            }


            // F. MODIFICATION DE `updateCompetitionsDisplay()`
            const originalUpdateCompetitionsDisplay = updateCompetitionsDisplay;
            updateCompetitionsDisplay = function(year, animate = true) {
                // Utilisation de la fonction originale
                const scrollDistance = originalUpdateCompetitionsDisplay(year, animate);

                // Ajout de l'information des points (uniquement si le mode est activ√©)
                if (useWeightedRanking) {
                    const yearContainer = allCompetitionsContainer.querySelector('.year-group-container'); // Le plus r√©cent (premier enfant)

                    if (yearContainer) {
                        const competitionsThisYear = yearlyWins[year] || {};
                        const boxes = yearContainer.querySelectorAll('.competition-box');
                        const compKeysJSON = Object.keys(competitionsThisYear);

                        boxes.forEach((box, index) => {
                            const compKey = compKeysJSON[index];
                            if (!compKey) return; 

                            const compInfoCase = box.querySelector('#comp-info-case');
                            if (!compInfoCase) return;
                            
                            // Trouver la cl√© canonique pour obtenir les points
                            const canonicalKey = jsonKeyToCanonicalKey[compKey];
                            const points = (canonicalKey && currentWeights[canonicalKey] !== undefined) ? currentWeights[canonicalKey] : 0;
                            const winCount = competitionsThisYear[compKey].count || 1;
                            const totalPoints = points * winCount;

                            // V√©rifier si le span existe d√©j√†
                            let pointsSpan = compInfoCase.querySelector('.points-display');
                            if (!pointsSpan) {
                                pointsSpan = document.createElement('span');
                                pointsSpan.className = 'points-display';
                                pointsSpan.style.cssText = "font-size: 0.9em; font-weight: normal; opacity: 0.8; line-height: 1;"; // 0.9em (√©tait 0.85)
                                // Ne pas ajouter de <br>, il est implicite car #comp-info-case est en colonne
                                compInfoCase.appendChild(pointsSpan);
                            }
                            
                            pointsSpan.textContent = `(+${totalPoints} ${translations[currentLang].weighted_points_label})`;
                        });
                    }
                }
                return scrollDistance;
            }

            // G. MODIFICATION DE `setLanguage()`
            const originalSetLanguage = setLanguage;
            setLanguage = function(lang) {
                originalSetLanguage(lang);
                // Mettre √† jour les labels sp√©cifiques aux points
                if (document.getElementById('ranking-mode-section')) { 
                    updateRankingModeLabels();
                    updateWeightSectionLabels();
                    updateWeightInputs(); // Re-traduire les noms de comp√©titions
                }
                // Mettre √† jour les pastilles de fond
                populateBackgroundPills();
            }

            // --- FIN NOUVEAU: LOGIQUE DES POINTS POND√âR√âS (Version 4.0) ---


            // √âcouteur de langue (utilise la fonction setLanguage modifi√©e)
            languageSelect.addEventListener('change', (e) => {
                setLanguage(e.target.value);
                // Si l'animation est lanc√©e, on relance avec la nouvelle langue
                if (animationStarted) {
                    clearTimeout(timer);
                    gsap.globalTimeline.pause(); 
                    applyFilters(); 
                    createDOMElements(); // Recr√©er les √©l√©ments pour la traduction
                    startAnimation();
                } else {
                    if (document.getElementById('filter-screen').style.display !== 'none') {
                        initFilterElements(false);
                    }
                }
            });

            // √âcouteurs pour les ann√©es et la r√©gion (inchang√©s)
            displayRegionRankCheckbox.addEventListener('change', (e) => {
                displayRegionRank = e.target.checked;
            });
            startYearSelect.addEventListener('change', (e) => {
                startYear = parseInt(e.target.value);
                if (startYear > endYear) { endYear = startYear; endYearSelect.value = startYear; }
            });
            endYearSelect.addEventListener('change', (e) => {
                endYear = parseInt(e.target.value);
                if (endYear < startYear) { startYear = endYear; startYearSelect.value = endYear; }
            });


            init();
        });
    </script>
</body>
</html>
