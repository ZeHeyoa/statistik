<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline Futuriste Avancée V5 - Triée & Stylisée</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #0d0c1d;
            --primary-glow: #00e5ff; /* Cyan */
            --secondary-glow: #ff4700; /* Orange */
            --marker-color: #fffa7a; /* Jaune pâle */
            --widget-bg: #1f1e33;
            --text-color: #f0f0f0;
            --border-color: rgba(0, 229, 255, 0.4);
            --danger-color: #ff3366;

            /* Couleurs pour les axes (Pastilles) */
            --color-axex: #ff0077; 
            --color-axey: #00ffaa; 
            --color-axez: #00aaff; 
            --color-rotx: #ffaa00; 
            --color-roty: #aa00ff; 
            --color-rotz: #ff0000; 

            /* NOUVEAU: Couleurs des barres (plus pâles / transparentes) */
            --bar-color-axex: rgba(255, 0, 119, 0.4); 
            --bar-color-axey: rgba(0, 255, 170, 0.4); 
            --bar-color-axez: rgba(0, 170, 255, 0.4); 
            --bar-color-rotx: rgba(255, 170, 0, 0.4); 
            --bar-color-roty: rgba(170, 0, 255, 0.4); 
            --bar-color-rotz: rgba(255, 0, 0, 0.4); 
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
        }

        /* --- En-tête et Pastille de Référence --- */
        #top-header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px; 
            z-index: 1000;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            background: rgba(13, 12, 29, 0.8);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid var(--border-color);
        }

        #reference-pastille {
            width: 25px; 
            height: 25px; 
            background-color: var(--secondary-glow);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 10px var(--secondary-glow), 0 0 20px var(--secondary-glow);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #reference-pastille:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--secondary-glow), 0 0 30px var(--secondary-glow);
        }
        /* NOUVEAU: Agrandissement au drag */
        #reference-pastille.dragging {
            transform: scale(1.5);
            opacity: 0.8; 
            box-shadow: 0 0 20px var(--secondary-glow), 0 0 40px var(--secondary-glow);
            cursor: grabbing;
        }

        /* --- Styles globaux pour les contrôles --- */
        button, select, input {
            background-color: var(--widget-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px 12px;
            font-family: 'Roboto Mono', monospace;
            transition: background-color 0.2s, box-shadow 0.2s, border-color 0.2s;
        }

        select {
            cursor: pointer;
        }
        
        button {
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            border-color: var(--primary-glow);
            box-shadow: 0 0 8px var(--primary-glow);
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-glow);
            box-shadow: 0 0 8px var(--primary-glow);
        }
        
        #play-btn {
            background-color: var(--color-axey); 
            color: var(--bg-color);
            border-color: var(--color-axey);
            box-shadow: 0 0 10px var(--color-axey);
        }
        #play-btn:hover {
             box-shadow: 0 0 15px var(--color-axey), 0 0 25px var(--color-axey);
        }

        /* --- Timeline (Restylisée) --- */
        #timeline-container {
            position: absolute;
            top: 60px; 
            left: 0;
            width: 100%;
            height: calc(100% - 60px);
            background: #0a0918;
            overflow: auto;
        }
        /* Style de la scrollbar */
        #timeline-container::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        #timeline-container::-webkit-scrollbar-track {
            background: #0a0918;
        }
        #timeline-container::-webkit-scrollbar-thumb {
            background-color: var(--primary-glow);
            border-radius: 10px;
            border: 2px solid #0a0918;
        }


        #timeline {
            position: relative;
            width: 3000px;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 229, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 229, 255, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            border-top: 1px solid var(--border-color);
        }
        
        /* --- Pastilles et Barres --- */
        .pastille {
            position: absolute;
            top: 50%;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            transition: top 0.6s cubic-bezier(.17,.89,.32,1.45), left 0.6s cubic-bezier(.17,.89,.32,1.45), box-shadow 0.2s, background-color 0.2s;
            z-index: 10;
        }

        /* Définition des animations de rebond (DROP) */
        @keyframes bounce-in {
            0% { transform: translate(-50%, -50%) scale(0.6); opacity: 0.5; } 
            50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; } 
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        /* Définition des animations (DRAG START) */
        @keyframes squish-and-lift {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(0.8, 1.2); box-shadow: 0 0 5px var(--secondary-glow); } 
            100% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.5; box-shadow: 0 0 20px var(--secondary-glow); } 
        }

        .pastille-drop-bounce {
            animation: bounce-in 0.6s cubic-bezier(.17,.89,.32,1.45); 
        }

        .pastille-drag-squish {
            animation: squish-and-lift 0.2s forwards; 
            cursor: grabbing;
        }
        
        .duration-bar {
            position: absolute;
            /* COMMENCE AU CENTRE HORIZONTAL DE LA PASTILLE (30px/2) */
            left: 15px; 
            /* COMMENCE AU CENTRE VERTICAL DE LA PASTILLE (30px/2) */
            top: 15px; 
            /* CENTRE VERTICALEMENT LA BARRE (2px de haut) SUR LA LIGNE DE 15px */
            transform: translateY(-50%); 
            height: 2px;
            border-radius: 1px;
            transition: width 0.5s ease-in-out;
            z-index: 9;
        }

        /* --- Repères de Temps --- */
        .time-marker {
            position: absolute;
            width: 1px;
            background: var(--marker-color);
            opacity: 0.7;
            color: var(--marker-color);
            z-index: 1;
        }
        .time-label {
            position: absolute;
            font-size: 8px; 
            display: flex;
            flex-direction: column; 
            align-items: center;
            line-height: 1;
        }
        .marker-top { top: 0; height: 40px; }
        .marker-top .time-label { top: -45px; }

        .marker-bottom { bottom: 0; height: 40px; }
        .marker-bottom .time-label { bottom: -45px; top: unset; }

        .marker-end {
            top: 50%;
            height: 20px;
            transform: translateY(-50%);
        }
        .marker-end .time-label { top: -40px; left: 0; transform: translateX(0); }


        /* --- Éditeur de Temps (#time-editor) --- */
        #time-editor {
            position: fixed; 
            display: none;
            width: 650px; 
            background-color: var(--widget-bg);
            border: 1px solid var(--border-color);
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.3);
            z-index: 2000; 
            overflow: hidden; 
        }
        .editor-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 12px; border-bottom: 1px solid var(--border-color);
            cursor: grab; 
            background: rgba(0,0,0,0.2);
        }

        .editor-body {
            display: flex;
            gap: 20px;
            padding: 15px;
        }

        .editor-controls {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 20px;
            color: var(--text-color);
            width: 25px;
            height: 25px;
            line-height: 25px;
            text-align: center;
            padding: 0;
            border-radius: 50%;
        }
        .close-btn:hover {
            background-color: var(--danger-color);
            color: white;
            box-shadow: 0 0 8px var(--danger-color);
        }

        fieldset {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        legend {
            padding: 0 5px;
            font-size: 12px;
            color: var(--primary-glow);
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .input-group label {
            font-size: 10px;
            opacity: 0.8;
        }
        .input-group input {
            width: 50px;
            padding: 5px;
        }
        input[type="text"]{
             width: 80px;
        }

        .editor-footer {
            padding: 10px 15px;
            border-top: 1px solid var(--border-color);
            text-align: right;
            background: rgba(0,0,0,0.2);
        }

        #ok-editor-btn {
            background-color: var(--primary-glow);
            border-color: var(--primary-glow);
            color: var(--bg-color);
        }

        /* --- Courbe de Bézier --- */
        #curve-area {
            flex-basis: 250px; 
            height: 250px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            position: relative;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 25px 25px;
            overflow: hidden;
            z-index: 200; 
        }
        #curve-canvas {
            display: block; 
            width: 100%;
            height: 100%;
        }
        .curve-control-point {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            cursor: grab;
            z-index: 210;
            transform: translate(-50%, -50%);
            background-color: var(--secondary-glow);
            box-shadow: 0 0 5px var(--secondary-glow);
        }
        .curve-control-point.start-end {
            background-color: var(--color-axey); 
            box-shadow: 0 0 5px var(--color-axey);
        }
        
        /* --- Card de Prévisualisation --- */
        #preview-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 350px;
            background-color: var(--widget-bg);
            border: 2px solid var(--primary-glow);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 229, 255, 0.5);
            z-index: 3000; 
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: space-around; 
            padding: 20px;
            perspective: 800px;
            background-image: url("Psg.jpg");
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
        }
        
        #preview-card h3 {
            font-size: 16px;
            color: var(--primary-glow);
            text-align: center;
        }

        /* PARENT: Gère la Translation */
        #preview-object {
            width: 200px;
            height: 300px;
            /* Maintenir transform-style pour que l'enfant soit 3D */
            transform-style: preserve-3d; 
            
            /* Utilisé uniquement pour centrer l'enfant */
            display: flex; 
            align-items: center;
            justify-content: center;
        }

        /* ENFANT: Gère la Rotation et le style visuel */
        #preview-inner {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: var(--color-axey);
            border: 2px dashed var(--color-axey);
            border-radius: 8px;
            transform-style: preserve-3d; 
            background-image: url("neuf.jpg");
            background-size: cover;      
            background-repeat: no-repeat;
            background-position: center;
        }

        #current-time-display {
            font-size: 18px;
            letter-spacing: 1px;
        }

    </style>
</head>
<body>

    <div id="top-header">
        <div id="reference-pastille" draggable="true"></div>
        <select id="axis-selector">
            <option value="Axe X">Axe X</option>
            <option value="Axe Y">Axe Y</option>
            <option value="Axe Z">Axe Z</option>
            <option value="rotation X">Rotation X</option>
            <option value="rotation Y">Rotation Y</option>
            <option value="rotation Z">Rotation Z</option>
        </select>
        <button id="play-btn">▶ Démarrer Simulation</button>
    </div>

    <div id="timeline-container">
        <div id="timeline"></div>
    </div>

    <div id="preview-card">
        <h3>Simulation</h3>
        <div id="preview-object">
            <div id="preview-inner">OBJET</div>
        </div>
        <span id="current-time-display">00:00:00:000</span>
        <button id="close-preview-btn" class="close-btn" style="position: absolute; top: 5px; right: 5px;">×</button>
    </div>

    <div id="time-editor">
        <div class="editor-header">
            <span>Définir l'Animation</span>
            <button id="close-editor-btn" class="close-btn">×</button>
        </div>
        <div class="editor-body">
            
            <div id="curve-area">
                <canvas id="curve-canvas"></canvas>
                <div class="curve-control-point start-end" id="p0" data-index="0" style="left: 0%; top: 100%;"></div>
                <div class="curve-control-point" id="p1" data-index="1" style="left: 33%; top: 50%;"></div>
                <div class="curve-control-point" id="p2" data-index="2" style="left: 66%; top: 50%;"></div>
                <div class="curve-control-point start-end" id="p3" data-index="3" style="left: 100%; top: 0%;"></div>
            </div>

            <div class="editor-controls">
                <div class="input-group" style="align-self: center;">
                    <label for="editor-axis-selector" style="width: auto;">Axe :</label>
                    <select id="editor-axis-selector" style="width: 150px;">
                        <option value="Axe X">Axe X</option>
                        <option value="Axe Y">Axe Y</option>
                        <option value="Axe Z">Axe Z</option>
                        <option value="rotation X">Rotation X</option>
                        <option value="rotation Y">Rotation Y</option>
                        <option value="rotation Z">Rotation Z</option>
                    </select>
                </div>
                
                <div>
                    <fieldset>
                        <legend>Valeurs</legend>
                        <div class="input-group"><label>Début</label><input type="text" id="start-value" value="0"></div>
                        <div class="input-group"><label>Fin</label><input type="text" id="end-value" value="100"></div>
                    </fieldset>
                </div>

                <div>
                    <fieldset>
                        <legend>Début (HH:MM:SS:ms)</legend>
                        <div class="input-group"><label for="start-h">HH</label><input type="number" id="start-h" min="0" value="0"></div>
                        <div class="input-group"><label for="start-m">MM</label><input type="number" id="start-m" min="0" max="59" value="0"></div>
                        <div class="input-group"><label for="start-s">SS</label><input type="number" id="start-s" min="0" max="59" value="0"></div>
                        <div class="input-group"><label for="start-ms">ms</label><input type="number" id="start-ms" min="0" max="999" value="0"></div>
                    </fieldset>
                    <fieldset>
                        <legend>Fin (HH:MM:SS:ms)</legend>
                        <div class="input-group"><label for="end-h">HH</label><input type="number" id="end-h" min="0" value="0"></div>
                        <div class="input-group"><label for="end-m">MM</label><input type="number" id="end-m" min="0" max="59" value="0"></div>
                        <div class="input-group"><label for="end-s">SS</label><input type="number" id="end-s" min="0" max="59" value="0"></div>
                        <div class="input-group"><label for="end-ms">ms</label><input type="number" id="end-ms" min="0" max="999" value="0"></div>
                    </fieldset>
                </div>
            </div>
        </div>
        <div class="editor-footer">
            <button id="ok-editor-btn">OK</button>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const timelineContainer = document.getElementById('timeline-container');
        const timeline = document.getElementById('timeline');
        const referencePastille = document.getElementById('reference-pastille');
        const axisSelector = document.getElementById('axis-selector');
        const timeEditor = document.getElementById('time-editor');
        const editorHeader = timeEditor.querySelector('.editor-header');
        const okEditorBtn = document.getElementById('ok-editor-btn');
        const closeEditorBtn = document.getElementById('close-editor-btn');
        const editorAxisSelector = document.getElementById('editor-axis-selector');
        const startValueInput = document.getElementById('start-value');
        const endValueInput = document.getElementById('end-value');
        let activePastille = null;

        // --- Éléments de Simulation ---
        const playBtn = document.getElementById('play-btn');
        const previewCard = document.getElementById('preview-card');
        const closePreviewBtn = document.getElementById('close-preview-btn');
        const previewObject = document.getElementById('preview-object'); // Parent (Translation)
        const previewInner = document.getElementById('preview-inner');   // Enfant (Rotation)
        const currentTimeDisplay = document.getElementById('current-time-display');
        let animationFrame = null;
        let animationStartTime = 0;
        let totalTimelineDuration = 0;
        let currentTimelineTime = 0;
        
        // --- Courbe de Bézier ---
        const curveArea = document.getElementById('curve-area');
        const canvas = document.getElementById('curve-canvas');
        const ctx = canvas.getContext('2d');
        const curvePoints = Array.from(document.querySelectorAll('.curve-control-point'));

        // --- Logique de Déplacement de l'Éditeur ---
        let isDraggingEditor = false;
        let editorOffsetX, editorOffsetY;

        editorHeader.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('close-btn')) return;
            isDraggingEditor = true;
            editorHeader.style.cursor = 'grabbing';
            editorOffsetX = e.clientX - timeEditor.getBoundingClientRect().left;
            editorOffsetY = e.clientY - timeEditor.getBoundingClientRect().top;
            
            document.addEventListener('mousemove', dragEditor);
            document.addEventListener('mouseup', stopDragEditor);
            e.preventDefault(); 
        });

        const dragEditor = (e) => {
            if (!isDraggingEditor) return;
            let newX = e.clientX - editorOffsetX;
            let newY = e.clientY - editorOffsetY;

            newX = Math.max(0, Math.min(newX, window.innerWidth - timeEditor.offsetWidth));
            newY = Math.max(0, Math.min(newY, window.innerHeight - timeEditor.offsetHeight));

            timeEditor.style.left = `${newX}px`;
            timeEditor.style.top = `${newY}px`;
        };

        const stopDragEditor = () => {
            isDraggingEditor = false;
            editorHeader.style.cursor = 'grab';
            document.removeEventListener('mousemove', dragEditor);
            document.removeEventListener('mouseup', stopDragEditor);
        };

        // --- Fonctions Utilitaires ---
        const timeToMilliseconds = (h, m, s, ms) => (parseInt(h||0)*3600+parseInt(m||0)*60+parseInt(s||0))*1000+parseInt(ms||0);
        const millisecondsToTime = (totalMs) => {
            if (isNaN(totalMs) || totalMs < 0) return { h:0,m:0,s:0,ms:0 };
            let r=totalMs; const h=Math.floor(r/3600000); r%=3600000;
            const m=Math.floor(r/60000); r%=60000;
            const s=Math.floor(r/1000); const ms=r%1000;
            return {h,m,s,ms};
        };
        const formatTimeDisplay = (ms) => {
            const t = millisecondsToTime(ms);
            return `${String(t.h).padStart(2,'0')}:${String(t.m).padStart(2,'0')}:${String(t.s).padStart(2,'0')}:${String(t.ms).padStart(3,'0')}`;
        };
        const formatTimeVertical = (ms) => {
            const t = millisecondsToTime(ms);
            return `<div class="time-label">
                <span>${String(t.h).padStart(2,'0')}H</span>
                <span>${String(t.m).padStart(2,'0')}M</span>
                <span>${String(t.s).padStart(2,'0')}S</span>
                <span>${String(t.ms).padStart(3,'0')}ms</span>
            </div>`;
        };
        
        const getAxisColor = (axis) => {
            switch(axis) {
                case "Axe X": return "var(--color-axex)";
                case "Axe Y": return "var(--color-axey)";
                case "Axe Z": return "var(--color-axez)";
                case "rotation X": return "var(--color-rotx)";
                case "rotation Y": return "var(--color-roty)";
                case "rotation Z": return "var(--color-rotz)";
                default: return "var(--primary-glow)";
            }
        };

        const getBarColor = (axis) => {
            switch(axis) {
                case "Axe X": return "var(--bar-color-axex)";
                case "Axe Y": return "var(--bar-color-axey)";
                case "Axe Z": return "var(--bar-color-axez)";
                case "rotation X": return "var(--bar-color-rotx)";
                case "rotation Y": return "var(--bar-color-roty)";
                case "rotation Z": return "var(--bar-color-rotz)";
                default: return "var(--border-color)";
            }
        };


        // --- Logique Courbe de Bézier ---
        const updateCanvasSize = () => {
            canvas.width = curveArea.clientWidth;
            canvas.height = curveArea.clientHeight;
            drawBezierCurve();
        };

        const drawBezierCurve = () => {
            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            const getPointCoords = (index) => {
                const style = curvePoints[index].style;
                const x = parseFloat(style.left) * w / 100;
                const y = h - (parseFloat(style.top) * h / 100); 
                return { x, y };
            };
            
            if (w === 0 || h === 0) return;

            const p0 = getPointCoords(0);
            const p1 = getPointCoords(1);
            const p2 = getPointCoords(2);
            const p3 = getPointCoords(3);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.moveTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.stroke();
            ctx.setLineDash([]); 

            ctx.strokeStyle = 'var(--secondary-glow)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
            ctx.stroke();
        };

        let draggingCurvePoint = null;

        const startDragCurve = (e) => {
            if (isDraggingEditor) return;
            
            draggingCurvePoint = e.target;
            const rect = curveArea.getBoundingClientRect();

            const moveHandler = (moveEvent) => {
                if (!draggingCurvePoint) return;
                
                let x = moveEvent.clientX - rect.left;
                let y = moveEvent.clientY - rect.top;

                let newLeft = (x / rect.width) * 100;
                let newTop = (y / rect.height) * 100;

                const index = parseInt(draggingCurvePoint.dataset.index);

                newLeft = Math.max(0, Math.min(100, newLeft));
                newTop = Math.max(0, Math.min(100, newTop));

                if (index === 1 || index === 2) {
                    draggingCurvePoint.style.left = `${newLeft}%`;
                    draggingCurvePoint.style.top = `${newTop}%`;
                } else if (index === 0) {
                    draggingCurvePoint.style.left = `0%`; 
                    draggingCurvePoint.style.top = `${newTop}%`;
                } else if (index === 3) {
                    draggingCurvePoint.style.left = `100%`; 
                    draggingCurvePoint.style.top = `${newTop}%`;
                }

                drawBezierCurve();
            };

            const stopHandler = () => {
                 if (activePastille && draggingCurvePoint) {
                    const pointIndex = draggingCurvePoint.dataset.index;
                    activePastille.dataset[`curveP${pointIndex}Left`] = draggingCurvePoint.style.left;
                    activePastille.dataset[`curveP${pointIndex}Top`] = draggingCurvePoint.style.top;
                }
                draggingCurvePoint = null;
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', stopHandler);
            };

            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', stopHandler);
            e.preventDefault();
        };

        curvePoints.forEach(p => p.addEventListener('mousedown', startDragCurve));
        window.addEventListener('resize', updateCanvasSize);

        // --- Fonctions Principales ---
        const createPastille = (x, y) => {
            const pastille = document.createElement('div');
            pastille.className = 'pastille pastille-drop-bounce'; 
            pastille.id = `pastille-${Date.now()}`;
            
            const minX = 30; 
            const finalX = Math.max(minX, x);

            pastille.style.left = `${finalX}px`;
            pastille.style.top = `${y}px`;
            pastille.dataset.startTimeMs = '0';
            pastille.dataset.endTimeMs = '0';
            pastille.dataset.startValue = '0';
            pastille.dataset.endValue = '100';
            pastille.dataset.axis = axisSelector.value;
            pastille.draggable = true;

            pastille.dataset.curveP0Left = '0%'; pastille.dataset.curveP0Top = '100%';
            pastille.dataset.curveP1Left = '33%'; pastille.dataset.curveP1Top = '50%';
            pastille.dataset.curveP2Left = '66%'; pastille.dataset.curveP2Top = '50%';
            pastille.dataset.curveP3Left = '100%'; pastille.dataset.curveP3Top = '0%';
            
            const durationBar = document.createElement('div');
            durationBar.className = 'duration-bar';
            pastille.appendChild(durationBar); // Le bar est enfant de la pastille
            timeline.appendChild(pastille);

            pastille.addEventListener('animationend', (e) => {
                if (e.animationName === 'bounce-in') {
                    pastille.classList.remove('pastille-drop-bounce');
                }
            });

            const initialColor = getAxisColor(pastille.dataset.axis);
            const initialBarColor = getBarColor(pastille.dataset.axis);

            pastille.style.setProperty('background-color', initialColor);
            pastille.style.setProperty('box-shadow', `0 0 8px ${initialColor}, 0 0 15px ${initialColor}`);
            
            durationBar.style.setProperty('background-color', initialBarColor);
            durationBar.style.setProperty('box-shadow', `0 0 4px ${initialColor}`); 

            pastille.addEventListener('click', (e) => {
                showTimeEditor(pastille);
            });

            pastille.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', e.target.id);
                e.dataTransfer.effectAllowed = 'move';
                e.target.classList.add('pastille-drag-squish'); 
            });
            pastille.addEventListener('dragend', (e) => {
                e.target.classList.remove('pastille-drag-squish'); 
                updateAndDrawMarkers();
            });
            return pastille;
        };

        const showTimeEditor = (p) => {
            activePastille = p;
            
            const startTime = millisecondsToTime(parseInt(p.dataset.startTimeMs));
            const endTime = millisecondsToTime(parseInt(p.dataset.endTimeMs));
            
            ['start','end'].forEach(type => {
                const t = type === 'start' ? startTime : endTime;
                Object.keys(t).forEach(unit => {
                    document.getElementById(`${type}-${unit}`).value = t[unit];
                });
            });
            startValueInput.value = p.dataset.startValue;
            endValueInput.value = p.dataset.endValue;

            editorAxisSelector.value = p.dataset.axis;
            curvePoints.forEach((cp, index) => {
                cp.style.left = p.dataset[`curveP${index}Left`] || cp.style.left;
                cp.style.top = p.dataset[`curveP${index}Top`] || cp.style.top;
            });
            
            if (timeEditor.style.display !== 'block') {
                 timeEditor.style.left = `${(window.innerWidth - timeEditor.offsetWidth) / 2}px`;
                 timeEditor.style.top = `${(window.innerHeight - timeEditor.offsetHeight) / 2}px`;
            }

            timeEditor.style.display = 'block';
            updateCanvasSize();
        };
        
        const updateAndDrawMarkers = () => {
            document.querySelectorAll('.time-marker').forEach(m => m.remove());

            let pastilles = Array.from(timeline.querySelectorAll('.pastille'));
            
            pastilles.sort((a, b) => parseInt(a.dataset.startTimeMs) - parseInt(b.dataset.startTimeMs));
            
            if (pastilles.length === 0) {
                totalTimelineDuration = 0;
                return;
            }

            let maxTime = 0;
            pastilles.forEach(p => {
                maxTime = Math.max(maxTime, parseInt(p.dataset.endTimeMs));
            });

            if (maxTime <= 0) maxTime = 1000;

            totalTimelineDuration = maxTime;

            const timelineWidth = timeline.scrollWidth;
            const pixelsPerMs = timelineWidth / totalTimelineDuration;
            const minX = 30;

            pastilles.forEach(p => {
                const startMs = parseInt(p.dataset.startTimeMs);
                const endMs = parseInt(p.dataset.endTimeMs);
                const durationMs = Math.max(0, endMs - startMs);

                const posX = (startMs * pixelsPerMs);
                p.style.left = `${posX + minX}px`;
                
                const bar = p.querySelector('.duration-bar');
                if (bar) bar.style.width = `${durationMs * pixelsPerMs}px`;
                

                createMarker(posX + minX, formatTimeVertical(startMs), 'top');
                createMarker(posX + minX, formatTimeVertical(startMs), 'bottom');
                if (durationMs > 0) {
                    createMarker(posX + minX + (durationMs * pixelsPerMs), formatTimeVertical(endMs), 'end', p.style.top);
                }
            });
        };

        const createMarker = (x, htmlContent, type, y = null) => {
            const marker = document.createElement('div');
            marker.className = `time-marker marker-${type}`;
            marker.style.left = `${x}px`;
            if (y) marker.style.top = y;
            marker.innerHTML = htmlContent;
            timeline.appendChild(marker);
        };

        // --- Logique d'Animation ---
        const getBezierValue = (t, P0_y, P1_y, P2_y, P3_y) => {
            const t2 = t * t;
            const t3 = t2 * t;
            const mt = 1 - t;
            const mt2 = mt * mt;
            const mt3 = mt2 * mt;
            return P0_y * mt3 + 3 * P1_y * mt2 * t + 3 * P2_y * mt * t2 + P3_y * t3;
        };

        const applyTransform = (timeMs) => {
            let transforms = {
                translateX: 0, translateY: 0, translateZ: 0,
                rotateX: 0, rotateY: 0, rotateZ: 0
            };

            const pastilles = timeline.querySelectorAll('.pastille');

            pastilles.forEach(p => {
                const startMs = parseInt(p.dataset.startTimeMs);
                const endMs = parseInt(p.dataset.endTimeMs);
                const durationMs = endMs - startMs;

                if (durationMs > 0 && timeMs >= startMs && timeMs <= endMs) {
                    const t_progression = (timeMs - startMs) / durationMs;
                    
                    const P0_y = 1 - (parseFloat(p.dataset.curveP0Top) / 100);
                    const P1_y = 1 - (parseFloat(p.dataset.curveP1Top) / 100);
                    const P2_y = 1 - (parseFloat(p.dataset.curveP2Top) / 100);
                    const P3_y = 1 - (parseFloat(p.dataset.curveP3Top) / 100);
                    
                    const curve_value = getBezierValue(t_progression, P0_y, P1_y, P2_y, P3_y);

                    const startVal = parseFloat(p.dataset.startValue || 0);
                    const endVal = parseFloat(p.dataset.endValue || 0);
                    const final_value = startVal + (endVal - startVal) * curve_value;
                    
                    const axis = p.dataset.axis;
                    if (axis === 'Axe X') transforms.translateX += final_value;
                    if (axis === 'Axe Y') transforms.translateY += final_value;
                    if (axis === 'Axe Z') transforms.translateZ += final_value;
                    if (axis === 'rotation X') transforms.rotateX += final_value;
                    if (axis === 'rotation Y') transforms.rotateY += final_value;
                    if (axis === 'rotation Z') transforms.rotateZ += final_value;
                }
            });
            
            // CORRECTION CLÉ : Séparation des transformations sur deux éléments.
            
            // 1. Appliquer la ROTATION à l'élément ENFANT (previewInner).
            // L'objet lui-même est tourné.
            previewInner.style.transform = `
                rotateX(${transforms.rotateX}deg) 
                rotateY(${transforms.rotateY}deg) 
                rotateZ(${transforms.rotateZ}deg)
            `;
            
            // 2. Appliquer la TRANSLATION à l'élément PARENT (previewObject).
            // Le parent est toujours aligné sur les axes du monde (car il n'a pas de rotation), 
            // garantissant que translateX se fait horizontalement sur l'écran.
            previewObject.style.transform = `
                translateX(${transforms.translateX}px) 
                translateY(${transforms.translateY}px) 
                translateZ(${transforms.translateZ}px) 
            `;

            previewInner.textContent = `OBJET`;
        };

        const animateTimeline = (timestamp) => {
            if (!animationStartTime) animationStartTime = timestamp;
            const elapsed = timestamp - animationStartTime;
            
            currentTimelineTime = elapsed;
            
            if(currentTimelineTime > totalTimelineDuration){
                animationStartTime = timestamp; // loop
                currentTimelineTime = 0;
            }

            currentTimeDisplay.textContent = formatTimeDisplay(currentTimelineTime);
            applyTransform(currentTimelineTime);
            
            animationFrame = requestAnimationFrame(animateTimeline);
        };

        const stopAnimation = () => {
            cancelAnimationFrame(animationFrame);
            animationFrame = null;
            animationStartTime = 0;
            currentTimelineTime = 0;
            previewCard.style.display = 'none';
            // Réinitialiser les deux éléments
            previewObject.style.transform = ''; 
            previewInner.style.transform = ''; 
            currentTimeDisplay.textContent = formatTimeDisplay(0); 
        };

        // --- Gestionnaires d'Événements ---

        referencePastille.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', 'reference-pastille');
            // AJOUT: Agrandir au début du glissement
            e.target.classList.add('dragging'); 
        });

        referencePastille.addEventListener('dragend', (e) => {
            // AJOUT: Revenir à la taille normale à la fin du glissement
            e.target.classList.remove('dragging');
        });

        timeline.addEventListener('dragover', (e) => e.preventDefault());
        timeline.addEventListener('drop', (e) => {
            e.preventDefault();
            const id = e.dataTransfer.getData('text/plain');
            const draggedElement = document.getElementById(id);

            const rect = timeline.getBoundingClientRect();
            const x = e.clientX - rect.left + timelineContainer.scrollLeft;
            const y = e.clientY - rect.top + timelineContainer.scrollTop;

            if (id === 'reference-pastille') {
                const newPastille = createPastille(x, y);
                showTimeEditor(newPastille);
            } else if (draggedElement && draggedElement.classList.contains('pastille')) {
                draggedElement.classList.remove('pastille-drop-bounce'); 
                void draggedElement.offsetWidth; 
                draggedElement.classList.add('pastille-drop-bounce');
                
                draggedElement.style.left = `${x}px`;
                draggedElement.style.top = `${y}px`;
                
                const startMs = (x-30) * (totalTimelineDuration / timeline.scrollWidth);
                const endMs = parseInt(draggedElement.dataset.endTimeMs) - parseInt(draggedElement.dataset.startTimeMs) + startMs;
                draggedElement.dataset.startTimeMs = Math.max(0, startMs);
                draggedElement.dataset.endTimeMs = Math.max(0, endMs);
                updateAndDrawMarkers();
            }
        });

        okEditorBtn.addEventListener('click', () => {
            if (!activePastille) return;
            const getMs = (type) => timeToMilliseconds(
                document.getElementById(`${type}-h`).value, document.getElementById(`${type}-m`).value,
                document.getElementById(`${type}-s`).value, document.getElementById(`${type}-ms`).value
            );
            
            const newAxis = editorAxisSelector.value;
            activePastille.dataset.startTimeMs = getMs('start');
            activePastille.dataset.endTimeMs = getMs('end');
            activePastille.dataset.axis = newAxis;
            activePastille.dataset.startValue = startValueInput.value;
            activePastille.dataset.endValue = endValueInput.value;
            
            const newColor = getAxisColor(newAxis);
            const newBarColor = getBarColor(newAxis); 
            
            activePastille.style.setProperty('background-color', newColor);
            activePastille.style.setProperty('box-shadow', `0 0 8px ${newColor}, 0 0 15px ${newColor}`);
            
            const bar = activePastille.querySelector('.duration-bar');
            if (bar) {
                bar.style.setProperty('background-color', newBarColor);
                bar.style.setProperty('box-shadow', `0 0 4px ${newColor}`);
            }

            curvePoints.forEach((cp, index) => {
                activePastille.dataset[`curveP${index}Left`] = cp.style.left;
                activePastille.dataset[`curveP${index}Top`] = cp.style.top;
            });
            
            timeEditor.style.display = 'none';
            updateAndDrawMarkers();
            activePastille = null;
        });

        closeEditorBtn.addEventListener('click', () => {
            if (activePastille && (parseInt(activePastille.dataset.startTimeMs) === 0 && parseInt(activePastille.dataset.endTimeMs) === 0)) {
                activePastille.remove();
            } else if (activePastille && confirm("Voulez-vous supprimer cette animation ?")) {
                activePastille.remove();
                updateAndDrawMarkers();
            }
            timeEditor.style.display = 'none';
            activePastille = null;
        });

        playBtn.addEventListener('click', () => {
            if (totalTimelineDuration <= 1) {
                alert("Veuillez créer et configurer au moins une animation avec une durée !");
                return;
            }
            previewCard.style.display = 'flex';
            // Réinitialiser les deux éléments
            previewObject.style.transform = ''; 
            previewInner.style.transform = '';
            animationFrame = requestAnimationFrame(animateTimeline);
        });

        closePreviewBtn.addEventListener('click', stopAnimation);

        updateCanvasSize();
        updateAndDrawMarkers();
    });
    </script>
</body>
</html>
