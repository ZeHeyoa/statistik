<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline Futuriste Avanc√©e V11 - Parent√© et Position Relative</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #0d0c1d;
            --primary-glow: #00e5ff;
            --secondary-glow: #ff4700;
            --marker-color: #fffa7a; /* Couleur de la graduation */
            --widget-bg: #1f1e33;
            --text-color: #f0f0f0;
            --border-color: rgba(0, 229, 255, 0.4);
            --danger-color: #ff3366;
            --color-axex: #ff0077; 
            --color-axey: #00ffaa; 
            --color-axez: #00aaff; 
            --color-rotx: #ffaa00; /* ORANGE */
            --color-roty: #aa00ff; 
            --color-rotz: #ff0000;
            --color-pivot: #f0f0f0; 
            --bar-color-axex: rgba(255, 0, 119, 0.4); 
            --bar-color-axey: rgba(0, 255, 170, 0.4); 
            --bar-color-axez: rgba(0, 170, 255, 0.4); 
            --bar-color-rotx: rgba(255, 170, 0, 0.4); 
            --bar-color-roty: rgba(170, 0, 255, 0.4); 
            --bar-color-rotz: rgba(255, 0, 0, 0.4);
            --bar-color-pivot: rgba(240, 240, 240, 0.4); 
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #top-header {
            width: 100%;
            height: 60px; 
            z-index: 1000;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            background: rgba(13, 12, 29, 0.8);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0; 
        }

        #reference-pastille {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: var(--color-rotx); 
            box-shadow: 0 0 8px var(--color-rotx), 0 0 15px var(--color-rotx);
            cursor: grab;
            flex-shrink: 0; 
            transition: transform 0.2s;
        }
        #reference-pastille.dragging {
            transform: scale(0.8);
            opacity: 0.8;
        }
        
        #current-time-display {
            font-size: 1.2em;
            color: var(--primary-glow);
            text-shadow: 0 0 5px var(--primary-glow);
        }

        #group-list-container {
            width: 100%;
            padding: 10px 20px;
            background: #15142a;
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
            white-space: nowrap; 
            flex-shrink: 0; 
        }
        .group-item {
            display: inline-flex;
            align-items: center;
            padding: 5px 10px;
            margin-right: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--widget-bg);
            font-size: 12px;
        }
        .group-color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .delete-group-btn {
            margin-left: 10px;
            background: none;
            border: none;
            color: var(--danger-color);
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .delete-group-btn:hover {
            color: var(--secondary-glow);
        }


        #timeline-container {
            position: relative;
            width: 100%;
            flex-grow: 1; 
            background: #0a0918;
            overflow: auto;
        }
        #timeline-container::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        #timeline-container::-webkit-scrollbar-track {
            background: #0a0918;
        }
        #timeline-container::-webkit-scrollbar-thumb {
            background-color: var(--primary-glow);
            border-radius: 10px;
            border: 2px solid #0a0918;
        }

        #timeline {
            position: relative;
            width: 3000px;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 229, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 229, 255, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            border-top: 1px solid var(--border-color);
        }
        
        /* Styles de Graduation du Temps */
        .time-marker {
            position: absolute;
            height: 100%; 
            width: 1px;
            background-color: var(--marker-color); 
            box-shadow: 0 0 5px var(--marker-color);
            transform: translateX(-50%);
            pointer-events: none; 
            z-index: 5;
            opacity: 0.8;
        }

        .time-marker.marker-top {
            top: 0;
            height: 10px; 
        }

        .time-marker.marker-bottom {
            bottom: 0;
            height: 10px; 
        }

        .time-marker.marker-end {
            height: 30px; 
            width: 2px;
            opacity: 1;
            z-index: 6;
        }

        .time-label {
            position: absolute;
            top: -45px; 
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 3px 5px;
            border-radius: 3px;
            white-space: nowrap;
            font-size: 10px;
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* Fin Styles de Graduation */

        .pastille {
            position: absolute;
            top: 50%;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            transition: top 0.6s cubic-bezier(.17,.89,.32,1.45), left 0.6s cubic-bezier(.17,.89,.32,1.45), box-shadow 0.2s, background-color 0.2s;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pastille.grouped {
            box-sizing: content-box; 
            padding: 2px; 
            border: 2px solid transparent; 
        }
        .pastille .group-label {
            position: absolute;
            top: -15px;
            font-size: 10px;
            color: var(--text-color);
            background: rgba(0, 0, 0, 0.7);
            padding: 1px 4px;
            border-radius: 2px;
            z-index: 20;
            pointer-events: none;
        }
        
        .duration-bar {
            position: absolute;
            left: 15px; 
            top: 15px; 
            transform: translateY(-50%); 
            height: 2px;
            border-radius: 1px;
            transition: width 0.5s ease-in-out;
            z-index: 9;
        }

        #footer-controls {
            flex-shrink: 0;
            height: 60px;
            background: rgba(13, 12, 29, 0.8);
            backdrop-filter: blur(5px);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 0 20px;
        }
        
        #save-json-btn {
            background-color: var(--danger-color); 
            color: white;
            border-color: var(--danger-color);
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.7);
        }
        #save-json-btn:hover {
            box-shadow: 0 0 15px var(--danger-color), 0 0 25px var(--danger-color);
        }

        #load-json-btn {
            background-color: var(--widget-bg);
            color: var(--primary-glow);
            border-color: var(--primary-glow);
        }
        
        button, select, input {
            background-color: var(--widget-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px 12px; 
            font-family: 'Roboto Mono', monospace;
            transition: background-color 0.2s, box-shadow 0.2s, border-color 0.2s;
            font-size: 12px;
        }
        
        /* Styles de l'√©diteur */
        #time-editor {
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            display: none; 
            width: 450px; 
            background-color: var(--widget-bg);
            border: 1px solid var(--border-color);
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.3);
            z-index: 2000; 
            overflow: hidden; 
            font-size: 12px; 
            transition: width 0.3s ease-in-out; 
        }
        .editor-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 12px; border-bottom: 1px solid var(--border-color);
            cursor: default; 
            background: rgba(0,0,0,0.2);
        }
        .editor-body-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
        }
        #editor-slide-2 {
            padding: 15px;
        }
        .close-btn {
            background: none;
            border: none;
            font-size: 16px; 
            color: var(--text-color);
            width: 25px;
            height: 25px;
            line-height: 25px;
            text-align: center;
            padding: 0;
            border-radius: 50%;
        }
        fieldset {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        legend {
            padding: 0 5px;
            font-size: 11px;
            color: var(--primary-glow);
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px; 
        }
        .input-group label {
            opacity: 0.8;
            width: 15px;
            text-align: right;
        }
        .input-group input {
            width: 50px;
            padding: 4px;
        }
        input[type="text"]{
             width: 80px;
        }
        #pivot-fieldset {
            display: none; 
        }
        #relative-pos-fieldset {
             display: none; /* Cache par d√©faut */
        }
        .slide-footer {
            padding: 10px 15px;
            border-top: 1px solid var(--border-color);
            display: flex; 
            justify-content: space-between;
            background: rgba(0,0,0,0.2);
        }
        .ok-btn {
            background-color: var(--primary-glow);
            border-color: var(--primary-glow);
            color: var(--bg-color);
            padding: 6px 10px;
            font-size: 12px;
            font-weight: bold;
        }
        .slide-btn {
            padding: 6px 10px;
            font-size: 12px;
            background-color: var(--widget-bg);
            border-color: var(--border-color);
        }
        #curve-area {
            width: 100%;
            height: 300px; 
            border: 1px solid var(--border-color);
            border-radius: 4px;
            position: relative;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 25px 25px;
            overflow: hidden;
            z-index: 200; 
        }
        #curve-canvas {
            display: block; 
            width: 100%;
            height: 100%;
        }
        .curve-control-point {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            cursor: grab;
            z-index: 210;
            transform: translate(-50%, -50%);
            background-color: var(--secondary-glow);
            box-shadow: 0 0 5px var(--secondary-glow);
        }
        .curve-control-point.start-end {
            background-color: var(--color-axey); 
            box-shadow: 0 0 5px var(--color-axey);
        }
        #preview-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 90%;
           background-image: 
                linear-gradient(rgba(0, 229, 255, 0.05) .5px, transparent .5px),
                linear-gradient(90deg, rgba(0, 229, 255, 0.05) 1px, transparent 1px);
            border: 2px solid var(--primary-glow);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 229, 255, 0.5);
            z-index: 3000; 
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: space-around; 
            padding: 20px;
            perspective: 800px;
        }
        #preview-object {
            width: 200px; /* Dimensions de r√©f√©rence */
            height: 300px; /* Dimensions de r√©f√©rence */
            transform-style: preserve-3d; 
            display: flex; 
            align-items: center;
            justify-content: center;
        }
        #preview-inner {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: var(--color-axey);
            border: 2px dashed var(--color-axey);
            border-radius: 8px;
            transform-style: preserve-3d; 
            background-size: cover;      
            background-repeat: no-repeat;
            background-position: center;
            background-color: rgba(255, 255, 255, 0.1); 
        }
    </style>
</head>
<body>
    <div id="top-header">
        <div id="reference-pastille" draggable="true"></div> 
        <button id="play-btn">‚ñ∂ D√©marrer Simulation</button>
        <span id="current-time-display">00:00:00:000</span>
    </div>

    <div id="group-list-container">
        <span style="opacity: 0.6; margin-right: 10px;">Groupes:</span>
    </div>

    <div id="timeline-container">
        <div id="timeline"></div>
    </div>

    <div id="footer-controls">
        <button id="save-json-btn">üíæ SAUVEGARDER S√âQUENCE</button>
        <input type="file" id="load-json-file" style="display: none;" accept=".json">
        <button id="load-json-btn">üìÇ CHARGER S√âQUENCE</button>
    </div>
    
    <div id="preview-card">
        <h3>Simulation</h3>
        <div id="preview-object">
            <div id="preview-inner">OBJET</div>
        </div>
        <button id="close-preview-btn" class="close-btn" style="position: absolute; top: 5px; right: 5px;">√ó</button>
    </div>

    <div id="time-editor">
        <div class="editor-header">
            <span>D√©finir l'Animation</span>
            <button id="close-editor-btn" class="close-btn">√ó</button>
        </div>
        
        <div id="slide-container"> 
            
            <div id="editor-slide-1" class="editor-slide">
                <div class="editor-body-controls">
                    <div class="input-group" style="align-self: center;">
                        <label for="editor-axis-selector" style="width: auto;">Axe :</label>
                        <select id="editor-axis-selector" style="width: 150px; padding: 4px 8px;">
                            <option value="Axe X">Axe X</option>
                            <option value="Axe Y">Axe Y</option>
                            <option value="Axe Z">Axe Z</option>
                            <option value="rotation X">Rotation X</option>
                            <option value="rotation Y">Rotation Y</option>
                            <option value="rotation Z">Rotation Z</option>
                            <option value="rotation Pivot">Rotation Axe Personnalis√©</option>
                        </select>
                    </div>
                    
                    <fieldset>
                        <legend>Valeurs</legend>
                        <div class="input-group"><label>D√©but</label><input type="text" id="start-value" value="0"></div>
                        <div class="input-group"><label>Fin</label><input type="text" id="end-value" value="100"></div>
                    </fieldset>
                    
                    <fieldset id="pivot-fieldset">
                        <legend>Points Pivots (coordonn√©es relatives √† l'objet)</legend>
                        <div class="pivot-group">
                            <div class="input-group"><label for="pivot-ax">Ax (%)</label><input type="number" id="pivot-ax" value="-50"></div>
                            <div class="input-group"><label for="pivot-ay">Ay (%)</label><input type="number" id="pivot-ay" value="-50"></div>
                            <div class="input-group"><label for="pivot-az">Az (px)</label><input type="number" id="pivot-az" value="0"></div>
                        </div>
                        <div class="pivot-group">
                             <div class="input-group"><label for="pivot-bx">Bx (%)</label><input type="number" id="pivot-bx" value="50"></div>
                            <div class="input-group"><label for="pivot-by">By (%)</label><input type="number" id="pivot-by" value="50"></div>
                            <div class="input-group"><label for="pivot-bz">Bz (px)</label><input type="number" id="pivot-bz" value="0"></div>
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Parent√©</legend>
                        <div class="input-group" style="flex-direction: column; align-items: flex-start; width: 100%;">
                            <label for="parent-id-selector" style="width: auto;">Parent (ID Pastille) :</label>
                            <select id="parent-id-selector" style="width: 100%; padding: 4px 8px;">
                                <option value="">(Aucun Parent)</option>
                            </select>
                        </div>
                    </fieldset>

                    <fieldset id="relative-pos-fieldset">
                        <legend>Position Relative au Parent (px)</legend>
                        <div class="input-group"><label for="relative-x">X</label><input type="number" id="relative-x" value="0"></div>
                        <div class="input-group"><label for="relative-y">Y</label><input type="number" id="relative-y" value="0"></div>
                        <div class="input-group"><label for="relative-z">Z</label><input type="number" id="relative-z" value="0"></div>
                    </fieldset>
                    <div>
                        <fieldset>
                            <legend>D√©but (HH:MM:SS:ms)</legend>
                            <div class="input-group"><label for="start-h">HH</label><input type="number" id="start-h" min="0" value="0"></div>
                            <div class="input-group"><label for="start-m">MM</label><input type="number" id="start-m" min="0" max="59" value="0"></div>
                            <div class="input-group"><label for="start-s">SS</label><input type="number" id="start-s" min="0" max="59" value="0"></div>
                            <div class="input-group"><label for="start-ms">ms</label><input type="number" id="start-ms" min="0" max="999" value="0"></div>
                        </fieldset>
                        <fieldset>
                            <legend>Fin (HH:MM:SS:ms)</legend>
                            <div class="input-group"><label for="end-h">HH</label><input type="number" id="end-h" min="0" value="0"></div>
                            <div class="input-group"><label for="end-m">MM</label><input type="number" id="end-m" min="0" max="59" value="0"></div>
                            <div class="input-group"><label for="end-s">SS</label><input type="number" id="end-s" min="0" max="59" value="0"></div>
                            <div class="input-group"><label for="end-ms">ms</label><input type="number" id="end-ms" min="0" max="999" value="0"></div>
                        </fieldset>
                    </div>
                </div>
                <div class="slide-footer">
                    <button id="next-slide-btn" class="slide-btn">Suivant >></button>
                    <button class="ok-btn">OK</button>
                </div>
            </div>
            
            <div id="editor-slide-2" class="editor-slide" style="display: none;">
                <div id="curve-area">
                    <canvas id="curve-canvas"></canvas>
                    <div class="curve-control-point start-end" id="p0" data-index="0" style="left: 0%; top: 100%;"></div>
                    <div class="curve-control-point" id="p1" data-index="1" style="left: 33%; top: 50%;"></div>
                    <div class="curve-control-point" id="p2" data-index="2" style="left: 66%; top: 50%;"></div>
                    <div class="curve-control-point start-end" id="p3" data-index="3" style="left: 100%; top: 0%;"></div>
                </div>
                <div class="slide-footer">
                    <button id="prev-slide-btn" class="slide-btn"><< Pr√©c√©dent</button>
                    <button class="ok-btn">OK</button>
                </div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- CLASSE QUATERNION (Pour les rotations 3D) ---
        class Quaternion {
            constructor(w, x, y, z) { this.w = w; this.x = x; this.y = y; this.z = z; }
            static fromAxisAngle(axis, angle) {
                const s = Math.sin(angle / 2);
                return new Quaternion(Math.cos(angle / 2), axis.x * s, axis.y * s, axis.z * s);
            }
            // Utilise l'orientation actuelle (this) pour faire une nouvelle rotation (q)
            multiply(q) {
                return new Quaternion(
                    this.w*q.w-this.x*q.x-this.y*q.y-this.z*q.z,
                    this.w*q.x+this.x*q.w+this.y*q.z-this.z*q.y,
                    this.w*q.y-this.x*q.z+this.y*q.w+this.z*q.x,
                    this.w*q.z+this.x*q.y-this.y*q.x+this.z*q.w
                );
            }
            // Tourne un vecteur (p) par cette orientation (this)
            rotatePoint(p) {
                const qp = new Quaternion(0, p.x, p.y, p.z);
                const res = this.multiply(qp).multiply(new Quaternion(this.w, -this.x, -this.y, -this.z));
                return { x: res.x, y: res.y, z: res.z };
            }
            toMatrix4(tx = 0, ty = 0, tz = 0) {
                const w=this.w, x=this.x, y=this.y, z=this.z,
                      x2=x+x, y2=y+y, z2=z+z,
                      xx=x*x2, xy=x*y2, xz=x*z2,
                      yy=y*y2, yz=y*z2, zz=z*z2,
                      wx=w*x2, wy=w*y2, wz=w*z2;
                
                const matrixValues = [
                    1-(yy+zz), xy+wz, xz-wy, 0,
                    xy-wz, 1-(xx+zz), yz+wx, 0,
                    xz+wy, yz-wx, 1-(xx+yy), 0,
                    tx, ty, tz, 1
                ];
                return `matrix3d(${matrixValues.join(',')})`;
            }
        }
        // --- FIN CLASSE QUATERNION ---

        const timelineContainer = document.getElementById('timeline-container');
        const timeline = document.getElementById('timeline');
        const referencePastille = document.getElementById('reference-pastille');
        const timeEditor = document.getElementById('time-editor');
        const okBtns = document.querySelectorAll('#time-editor .ok-btn'); 
        const closeEditorBtn = document.getElementById('close-editor-btn');
        const editorAxisSelector = document.getElementById('editor-axis-selector');
        const startValueInput = document.getElementById('start-value');
        const endValueInput = document.getElementById('end-value');
        const pivotFieldset = document.getElementById('pivot-fieldset');
        // NOUVEAU: R√©f√©rences pour la parent√© et la position relative
        const parentIdSelector = document.getElementById('parent-id-selector');
        const relativeXInput = document.getElementById('relative-x');
        const relativeYInput = document.getElementById('relative-y');
        const relativeZInput = document.getElementById('relative-z');
        const relativePosFieldset = document.getElementById('relative-pos-fieldset');
        // FIN NOUVEAU
        let activePastille = null;

        const slide1 = document.getElementById('editor-slide-1');
        const slide2 = document.getElementById('editor-slide-2');
        const nextSlideBtn = document.getElementById('next-slide-btn');
        const prevSlideBtn = document.getElementById('prev-slide-btn');

        const playBtn = document.getElementById('play-btn');
        const previewCard = document.getElementById('preview-card');
        const previewObject = document.getElementById('preview-object');
        const previewInner = document.getElementById('preview-inner');
        const currentTimeDisplay = document.getElementById('current-time-display');
        const groupListContainer = document.getElementById('group-list-container');
        const saveJsonBtn = document.getElementById('save-json-btn');
        const loadJsonBtn = document.getElementById('load-json-btn');
        const loadJsonFile = document.getElementById('load-json-file');
        const closePreviewBtn = document.getElementById('close-preview-btn'); 

        let animationFrame = null;
        let animationStartTime = 0;
        let totalTimelineDuration = 0;
        let currentTimelineTime = 0;
        
        let currentSlide = 1;
        
        // GESTION DES GROUPES
        let allGroups = []; 
        let nextGroupNumber = 1; 
        
        // --- Fonctions utilitaires ---
        const timeToMilliseconds = (h, m, s, ms) => (parseInt(h||0)*3600+parseInt(m||0)*60+parseInt(s||0))*1000+parseInt(ms||0);
        const millisecondsToTime = (totalMs) => {
            if (isNaN(totalMs) || totalMs < 0) return { h:0,m:0,s:0,ms:0 };
            let r=totalMs; const h=Math.floor(r/3600000); r%=3600000;
            const m=Math.floor(r/60000); r%=60000;
            const s=Math.floor(r/1000); const ms=r%1000;
            return {h,m,s,ms};
        };
        
        const formatTimeDisplay = (ms) => {
            const t = millisecondsToTime(ms);
            return `${String(t.h).padStart(2,'0')}:${String(t.m).padStart(2,'0')}:${String(t.s).padStart(2,'0')}:${String(t.ms).padStart(3,'0')}`;
        };
        
        const formatTimeVertical = (totalMs) => {
            const t = millisecondsToTime(totalMs);
            const parts = [];
            if (t.h > 0) parts.push(`<span>${String(t.h).padStart(2,'0')}H</span>`);
            if (t.m > 0 || t.h > 0) parts.push(`<span>${String(t.m).padStart(2,'0')}M</span>`);
            parts.push(`<span>${String(t.s).padStart(2,'0')}S</span>`);
            parts.push(`<span>${String(t.ms).padStart(3,'0')}ms</span>`);

            return `<div class="time-label">${parts.join('')}</div>`;
        };
        const getAxisColor = (axis) => {
            switch(axis) {
                case "Axe X": return "var(--color-axex)";
                case "Axe Y": return "var(--color-axey)";
                case "Axe Z": return "var(--color-axez)";
                case "rotation X": return "var(--color-rotx)";
                case "rotation Y": return "var(--color-roty)";
                case "rotation Z": return "var(--color-rotz)";
                case "rotation Pivot": return "var(--color-pivot)";
                default: return "var(--primary-glow)";
            }
        };

        const getBarColor = (axis) => {
            switch(axis) {
                case "Axe X": return "var(--bar-color-axex)";
                case "Axe Y": return "var(--bar-color-axey)";
                case "Axe Z": return "var(--bar-color-axez)";
                case "rotation X": return "var(--bar-color-rotx)";
                case "rotation Y": return "var(--bar-color-roty)";
                case "rotation Z": return "var(--bar-color-rotz)";
                case "rotation Pivot": return "var(--bar-color-pivot)";
                default: return "var(--border-color)";
            }
        };

        const getRandomPaleColor = () => {
            const h = Math.floor(Math.random() * 360);
            const s = Math.floor(Math.random() * 30 + 30); 
            const l = Math.floor(Math.random() * 15 + 70); 
            return `hsl(${h}, ${s}%, ${l}%)`;
        };

        const downloadJson = (data, filename = 'timeline_sequence.json') => {
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };
        // --- Fin fonctions utilitaires ---


        // --- Gestion de la courbe de B√©zier ---
        const curveArea = document.getElementById('curve-area');
        const canvas = document.getElementById('curve-canvas');
        const ctx = canvas.getContext('2d');
        const curvePoints = Array.from(document.querySelectorAll('.curve-control-point'));

        const updateCanvasSize = () => {
            canvas.width = curveArea.clientWidth;
            canvas.height = curveArea.clientHeight;
            drawBezierCurve();
        };
        const showSlide = (slideNumber) => {
            slide1.style.display = (slideNumber === 1) ? 'block' : 'none';
            slide2.style.display = (slideNumber === 2) ? 'block' : 'none';
            currentSlide = slideNumber;

            if (slideNumber === 2) {
                timeEditor.style.width = '330px'; 
                updateCanvasSize();
            } else {
                timeEditor.style.width = '450px'; 
            }
        };
        nextSlideBtn.addEventListener('click', () => showSlide(2));
        prevSlideBtn.addEventListener('click', () => showSlide(1));
        const drawBezierCurve = () => {
            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);
            const getPointCoords = (index) => {
                const style = curvePoints[index].style;
                const x = parseFloat(style.left) * w / 100;
                const y = h - (parseFloat(style.top) * h / 100); 
                return { x, y };
            };
            if (w === 0 || h === 0) return;
            const p0 = getPointCoords(0);
            const p1 = getPointCoords(1);
            const p2 = getPointCoords(2);
            const p3 = getPointCoords(3);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.moveTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.stroke();
            ctx.setLineDash([]); 
            ctx.strokeStyle = 'var(--secondary-glow)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.x, p3.x, p3.y);
            ctx.stroke();
        };
        let draggingCurvePoint = null;
        const startDragCurve = (e) => {
            draggingCurvePoint = e.target;
            const rect = curveArea.getBoundingClientRect();
            const moveHandler = (moveEvent) => {
                if (!draggingCurvePoint) return;
                let x = moveEvent.clientX - rect.left;
                let y = moveEvent.clientY - rect.top;
                let newLeft = (x / rect.width) * 100;
                let newTop = (y / rect.height) * 100;
                const index = parseInt(draggingCurvePoint.dataset.index);
                newLeft = Math.max(0, Math.min(100, newLeft));
                newTop = Math.max(0, Math.min(100, newTop));
                if (index === 1 || index === 2) {
                    draggingCurvePoint.style.left = `${newLeft}%`;
                    draggingCurvePoint.style.top = `${newTop}%`;
                } else if (index === 0) {
                    draggingCurvePoint.style.left = `0%`; 
                    draggingCurvePoint.style.top = `${newTop}%`;
                } else if (index === 3) {
                    draggingCurvePoint.style.left = `100%`; 
                    draggingCurvePoint.style.top = `${newTop}%`;
                }
                drawBezierCurve();
            };
            const stopHandler = () => {
                 if (activePastille && draggingCurvePoint) {
                    const pointIndex = draggingCurvePoint.dataset.index;
                    activePastille.dataset[`curveP${pointIndex}Left`] = draggingCurvePoint.style.left;
                    activePastille.dataset[`curveP${pointIndex}Top`] = draggingCurvePoint.style.top;
                }
                draggingCurvePoint = null;
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', stopHandler);
            };
            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', stopHandler);
            e.preventDefault();
        };
        curvePoints.forEach(p => p.addEventListener('mousedown', startDragCurve));
        window.addEventListener('resize', updateCanvasSize);
        const getBezierValue = (t, P0_y, P1_y, P2_y, P3_y) => {
            const t2 = t*t, t3 = t2*t, mt = 1-t, mt2 = mt*mt, mt3 = mt2*mt;
            return P0_y * mt3 + 3 * P1_y * mt2 * t + 3 * P2_y * mt * t2 + P3_y * t3;
        };
        // --- Fin gestion de la courbe de B√©zier ---


        // Mise √† jour du style (incluant le groupe)
        const updatePastilleStyle = (pastille) => {
            const axis = pastille.dataset.axis || 'Axe X';
            const initialColor = getAxisColor(axis);
            const initialBarColor = getBarColor(axis);
            const durationBar = pastille.querySelector('.duration-bar');

            // 1. Style de base
            pastille.style.setProperty('background-color', initialColor);
            pastille.style.setProperty('box-shadow', `0 0 8px ${initialColor}, 0 0 15px ${initialColor}`);
            if (durationBar) {
                durationBar.style.setProperty('background-color', initialBarColor);
                durationBar.style.setProperty('box-shadow', `0 0 4px ${initialColor}`);
            }

            // 2. Style de Groupe
            let label = pastille.querySelector('.group-label');
            if (pastille.dataset.groupId) {
                const groupId = pastille.dataset.groupId;
                const group = allGroups.find(g => g.id === groupId);
                
                pastille.classList.add('grouped');
                if (group) {
                    pastille.style.setProperty('border', `2px solid ${group.color}`);
                }

                if (!label) {
                    label = document.createElement('span');
                    label.className = 'group-label';
                    pastille.appendChild(label);
                }
                label.textContent = `G${pastille.dataset.groupNumber}`;

            } else {
                pastille.classList.remove('grouped');
                pastille.style.removeProperty('border');
                if (label) label.remove();
            }

             // 3. Indicateur de Parent√© (si parentId est d√©fini, on ajoute un contour sp√©cial)
            if (pastille.dataset.parentId) {
                pastille.style.setProperty('border', `2px solid var(--secondary-glow)`);
                pastille.style.setProperty('box-shadow', `0 0 8px ${initialColor}, 0 0 15px ${initialColor}, 0 0 10px 5px var(--secondary-glow) inset`);
            }
        };

        const createPastille = (x, y, data = {}, groupId = null, groupNumber = null) => {
            const pastille = document.createElement('div');
            pastille.className = 'pastille pastille-drop-bounce'; 
            pastille.id = data.id || `pastille-${Date.now()}`;
            
            const minX = 30; 
            const finalX = Math.max(minX, x);

            pastille.style.left = data.left || `${finalX}px`;
            pastille.style.top = data.top || `${y}px`;

            pastille.dataset.startTimeMs = data.startTimeMs || '0';
            pastille.dataset.endTimeMs = data.endTimeMs || '0';
            pastille.dataset.startValue = data.startValue || '0';
            pastille.dataset.endValue = data.endValue || '100';
            pastille.dataset.axis = data.axis || 'rotation X'; 

            pastille.dataset.curveP0Left = data.curveP0Left || '0%'; pastille.dataset.curveP0Top = data.curveP0Top || '100%';
            pastille.dataset.curveP1Left = data.curveP1Left || '33%'; pastille.dataset.curveP1Top = data.curveP1Top || '50%';
            pastille.dataset.curveP2Left = data.curveP2Left || '66%'; pastille.dataset.curveP2Top = data.curveP2Top || '50%';
            pastille.dataset.curveP3Left = data.curveP3Left || '100%'; pastille.dataset.curveP3Top = data.curveP3Top || '0%';
            
            pastille.dataset.pivotAx = data.pivotAx || "-50"; pastille.dataset.pivotAy = data.pivotAy || "-50"; pastille.dataset.pivotAz = data.pivotAz || "0";
            pastille.dataset.pivotBx = data.pivotBx || "50"; pastille.dataset.pivotBy = data.pivotBy || "50"; pastille.dataset.pivotBz = data.pivotBz || "0";
            
            // NOUVEAU: Donn√©es de Parent√© et de Position Relative
            pastille.dataset.parentId = data.parentId || '';
            pastille.dataset.relativeX = data.relativeX || '0';
            pastille.dataset.relativeY = data.relativeY || '0';
            pastille.dataset.relativeZ = data.relativeZ || '0';
            // FIN NOUVEAU
            
            if (groupId !== null) {
                pastille.dataset.groupId = groupId;
                pastille.dataset.groupNumber = groupNumber;
            }

            const durationBar = document.createElement('div');
            durationBar.className = 'duration-bar';
            pastille.appendChild(durationBar);
            timeline.appendChild(pastille);

            updatePastilleStyle(pastille); 

            pastille.addEventListener('animationend', (e) => {
                if (e.animationName === 'bounce-in') {
                    pastille.classList.remove('pastille-drop-bounce');
                }
            });

            pastille.addEventListener('click', (e) => {
                showTimeEditor(pastille);
            });
            pastille.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', e.target.id);
                e.dataTransfer.effectAllowed = 'move';
                e.target.classList.add('pastille-drag-squish'); 
            });
            pastille.addEventListener('dragend', (e) => {
                e.target.classList.remove('pastille-drag-squish'); 
                updateAndDrawMarkers();
            });
            return pastille;
        };


        // --- Fonctions de gestion des groupes ---

        const updateGroupList = () => {
            groupListContainer.innerHTML = '<span style="opacity: 0.6; margin-right: 10px;">Groupes:</span>';
            allGroups.forEach(group => {
                const item = document.createElement('div');
                item.className = 'group-item';
                item.innerHTML = `
                    <span class="group-color-dot" style="background-color: ${group.color};"></span>
                    <span>Groupe ${group.number}</span>
                    <button class="delete-group-btn" data-group-id="${group.id}">X</button>
                `;
                groupListContainer.appendChild(item);
            });

            document.querySelectorAll('.delete-group-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const groupId = e.target.dataset.groupId;
                    if (confirm(`Voulez-vous supprimer le Groupe ${allGroups.find(g => g.id === groupId)?.number} et toutes ses pastilles ?`)) {
                        deleteGroup(groupId);
                    }
                });
            });
        };

        const deleteGroup = (groupId) => {
            document.querySelectorAll(`.pastille[data-group-id="${groupId}"]`).forEach(p => p.remove());
            allGroups = allGroups.filter(g => g.id !== groupId);
            
            updateGroupList();
            updateAndDrawMarkers();
        };
        
        // --- Logique d'interaction et d'animation ---
        
        const showTimeEditor = (p) => {
            activePastille = p;
            
            const startTime = millisecondsToTime(parseInt(p.dataset.startTimeMs));
            const endTime = millisecondsToTime(parseInt(p.dataset.endTimeMs));
            
            ['start','end'].forEach(type => {
                const t = type === 'start' ? startTime : endTime;
                Object.keys(t).forEach(unit => document.getElementById(`${type}-${unit}`).value = t[unit] );
            });
            startValueInput.value = p.dataset.startValue;
            endValueInput.value = p.dataset.endValue;
            editorAxisSelector.value = p.dataset.axis;

            pivotFieldset.style.display = (p.dataset.axis === 'rotation Pivot') ? 'flex' : 'none';
            
            document.getElementById('pivot-ax').value = p.dataset.pivotAx;
            document.getElementById('pivot-ay').value = p.dataset.pivotAy;
            document.getElementById('pivot-az').value = p.dataset.pivotAz;
            document.getElementById('pivot-bx').value = p.dataset.pivotBx;
            document.getElementById('pivot-by').value = p.dataset.pivotBy;
            document.getElementById('pivot-bz').value = p.dataset.pivotBz;

            // NOUVEAU: Remplissage de la s√©lection de Parent et des inputs de position relative
            parentIdSelector.innerHTML = '<option value="">(Aucun Parent)</option>';
            const allPastilles = Array.from(timeline.querySelectorAll('.pastille'));
            
            allPastilles.forEach(pInTimeline => {
                if (pInTimeline.id !== p.id) { // Une pastille ne peut pas √™tre son propre parent
                    const option = document.createElement('option');
                    option.value = pInTimeline.id;
                    // Afficher l'ID pour le moment. On pourrait ajouter un nom si on en avait un.
                    option.textContent = pInTimeline.id; 
                    parentIdSelector.appendChild(option);
                }
            });
            
            parentIdSelector.value = p.dataset.parentId;
            
            relativeXInput.value = p.dataset.relativeX;
            relativeYInput.value = p.dataset.relativeY;
            relativeZInput.value = p.dataset.relativeZ;

            // Afficher/Cacher la position relative en fonction de la parent√©
            relativePosFieldset.style.display = p.dataset.parentId ? 'flex' : 'none';
            // FIN NOUVEAU

            curvePoints.forEach((cp, index) => {
                cp.style.left = p.dataset[`curveP${index}Left`] || cp.style.left;
                cp.style.top = p.dataset[`curveP${index}Top`] || cp.style.top;
            });
            
            timeEditor.style.display = 'block';
            showSlide(1); 
        };
        
        // NOUVEAU: √âcouteur pour montrer/cacher la position relative lors du changement de parent
        parentIdSelector.addEventListener('change', () => {
            relativePosFieldset.style.display = parentIdSelector.value ? 'flex' : 'none';
        });

        // üìê Mise √† jour des marqueurs et de la dur√©e
        const updateAndDrawMarkers = () => {
            document.querySelectorAll('.time-marker').forEach(m => m.remove());
            let pastilles = Array.from(timeline.querySelectorAll('.pastille'));
            pastilles.sort((a, b) => parseInt(a.dataset.startTimeMs) - parseInt(b.dataset.startTimeMs));
            
            if (pastilles.length === 0) {
                totalTimelineDuration = 0; 
                currentTimeDisplay.textContent = formatTimeDisplay(0); 
                return;
            }
            let maxTime = 0;
            pastilles.forEach(p => maxTime = Math.max(maxTime, parseInt(p.dataset.endTimeMs)) );
            if (maxTime <= 0) maxTime = 1000;
            totalTimelineDuration = maxTime;

            const timelineWidth = timeline.scrollWidth;
            const pixelsPerMs = timelineWidth / totalTimelineDuration;
            const minX = 30;

            pastilles.forEach(p => {
                const startMs = parseInt(p.dataset.startTimeMs);
                const endMs = parseInt(p.dataset.endTimeMs);
                const durationMs = Math.max(0, endMs - startMs);
                const posX = (startMs * pixelsPerMs);
                p.style.left = `${posX + minX}px`;
                const bar = p.querySelector('.duration-bar');
                if (bar) bar.style.width = `${durationMs * pixelsPerMs}px`;
                
                // Cr√©ation des marqueurs
                createMarker(posX + minX, formatTimeVertical(startMs), 'top');
                createMarker(posX + minX, formatTimeVertical(startMs), 'bottom');
                if (durationMs > 0) {
                    createMarker(posX + minX + (durationMs * pixelsPerMs), formatTimeVertical(endMs), 'end', p.style.top);
                }
                updatePastilleStyle(p); 
            });
        };

        const createMarker = (x, htmlContent, type, y = null) => {
            const marker = document.createElement('div');
            marker.className = `time-marker marker-${type}`;
            marker.style.left = `${x}px`;
            if (y) { 
                marker.style.top = y; 
                marker.style.transform = `translate(-50%, -50%)`;
            } else {
                marker.style.transform = `translateX(-50%)`;
            }
            marker.innerHTML = htmlContent;
            timeline.appendChild(marker);
        };
        
        // La fonction applyTransform est modifi√©e pour g√©rer la hi√©rarchie
        const applyTransform = (timeMs) => {
            const pastilles = Array.from(timeline.querySelectorAll('.pastille'));
            
            // Tri par temps (obligatoire)
            pastilles.sort((a, b) => parseInt(a.dataset.startTimeMs) - parseInt(b.dataset.startTimeMs));
            
            // √âtat Monde Global de l'objet (accumul√© par les pastilles SANS parent)
            let orientation = new Quaternion(1, 0, 0, 0); 
            let position = { x: 0, y: 0, z: 0 };         
            
            // Map pour stocker l'√©tat Monde (Quat/Pos) apr√®s chaque pastille, pour les enfants
            const pastilleWorldStates = {}; 
            
            previewObject.style.transformOrigin = '50% 50% 0';

            const PREVIEW_WIDTH = 200;
            const PREVIEW_HEIGHT = 300;


            pastilles.forEach(p => {
                const startMs = parseInt(p.dataset.startTimeMs);
                const endMs = parseInt(p.dataset.endTimeMs);
                const durationMs = endMs - startMs;
                
                // √âtat de d√©part pour l'animation de P : soit l'accumulation globale, soit l'√©tat du Parent.
                let startOrientation = orientation; 
                let startPosition = {...position}; // Copie de l'objet pour ne pas modifier l'√©tat global directement
                let isChild = false;

                // --- 1. D√âFINITION DE L'ORIGINE (Parent ou Accumulation Globale) ---
                const parentId = p.dataset.parentId;
                if (parentId && pastilleWorldStates[parentId]) {
                    // La pastille est un enfant. Son animation est relative au Parent.
                    const parentState = pastilleWorldStates[parentId];
                    // H√©riter correctement de l'orientation et la position du parent
                    startOrientation = parentState.orientation;
                    startPosition = {...parentState.position}; 
                    isChild = true;
                    
                    // Appliquer l'Offset Relatif (Translation du Child par rapport au Parent)
                    const relX = parseFloat(p.dataset.relativeX || 0);
                    const relY = parseFloat(p.dataset.relativeY || 0);
                    const relZ = parseFloat(p.dataset.relativeZ || 0);
                    const relativeOffset = { x: relX, y: relY, z: relZ };

                    // L'offset est tourn√© par l'orientation du parent (dans l'espace Monde)
                    const rotatedOffset = startOrientation.rotatePoint(relativeOffset); 

                    startPosition.x += rotatedOffset.x;
                    startPosition.y += rotatedOffset.y;
                    startPosition.z += rotatedOffset.z;
                } 
                // Sinon, c'est une animation racine, qui se construit sur l'√©tat global actuel.

                // --- 2. CALCUL ET APPLICATION DE L'ANIMATION P ---
                
                let rotQuat = null;
                let transVec = { x: 0, y: 0, z: 0 }; 

                if (durationMs > 0 && timeMs >= startMs && timeMs <= endMs) {
                    const t_progression = (timeMs - startMs) / durationMs;
                    const curve_value = getBezierValue(t_progression, 1-(parseFloat(p.dataset.curveP0Top)/100), 1-(parseFloat(p.dataset.curveP1Top)/100), 1-(parseFloat(p.dataset.curveP2Top)/100), 1-(parseFloat(p.dataset.curveP3Top)/100));
                    const startVal = parseFloat(p.dataset.startValue || 0);
                    const endVal = parseFloat(p.dataset.endValue || 0);
                    const final_value = startVal + (endVal - startVal) * curve_value;
                    const axis = p.dataset.axis;

                    if (axis === 'Axe X') transVec.x = final_value;
                    if (axis === 'Axe Y') transVec.y = final_value;
                    if (axis === 'Axe Z') transVec.z = final_value;

                    if (axis.startsWith('rotation')) {
                        const angleRad = final_value * Math.PI / 180;

                        if (axis === 'rotation X') {
                            rotQuat = Quaternion.fromAxisAngle({x:1, y:0, z:0}, angleRad);
                        } else if (axis === 'rotation Y') {
                            rotQuat = Quaternion.fromAxisAngle({x:0, y:1, z:0}, angleRad);
                        } else if (axis === 'rotation Z') {
                            rotQuat = Quaternion.fromAxisAngle({x:0, y:0, z:1}, angleRad);
                        } else if (axis === 'rotation Pivot') {
                            const pAx_pct = parseFloat(p.dataset.pivotAx || 0);
                            const pAy_pct = parseFloat(p.dataset.pivotAy || 0);
                            const pAz_px = parseFloat(p.dataset.pivotAz || 0);
                            const pBx = parseFloat(p.dataset.pivotBx || 0);
                            const pBy = parseFloat(p.dataset.pivotBy || 0);
                            const pBz = parseFloat(p.dataset.pivotBz || 0);
                            const pivotPoint = {
                                x: (PREVIEW_WIDTH / 100) * pAx_pct,
                                y: (PREVIEW_HEIGHT / 100) * pAy_pct,
                                z: pAz_px 
                            };
                            let vx = (PREVIEW_WIDTH / 100) * (pBx - pAx_pct);
                            let vy = (PREVIEW_HEIGHT / 100) * (pBy - pAy_pct);
                            let vz = pBz - pAz_px;
                            const mag = Math.sqrt(vx*vx + vy*vy + vz*vz);
                            let rotationAxis = {x: 0, y: 1, z: 0}; 
                            if (mag > 1e-6) rotationAxis = { x: vx / mag, y: vy / mag, z: vz / mag };
                            
                            rotQuat = Quaternion.fromAxisAngle(rotationAxis, angleRad);
                            
                            // La compensation est calcul√©e dans l'espace local de l'animation
                            const rotatedPivot = rotQuat.rotatePoint(pivotPoint);
                            const compensation = { 
                                x: pivotPoint.x - rotatedPivot.x,
                                y: pivotPoint.y - rotatedPivot.y,
                                z: pivotPoint.z - rotatedPivot.z
                            };
                            transVec.x += compensation.x;
                            transVec.y += compensation.y;
                            transVec.z += compensation.z;
                        }
                    }

                    // Translation anim√©e (relative √† l'orientation du point de d√©part)
                    if (transVec.x !== 0 || transVec.y !== 0 || transVec.z !== 0) {
                        const rotatedTranslation = startOrientation.rotatePoint(transVec);
                        startPosition.x += rotatedTranslation.x;
                        startPosition.y += rotatedTranslation.y;
                        startPosition.z += rotatedTranslation.z;
                    }
                    
                    // Rotation anim√©e (Globale/Monde)
                    if (rotQuat) {
                        // Rotation appliqu√©e sur l'orientation de d√©part
                        // --- IMPORTANT : on compose la rotation locale de la pastille **par-dessus**
                        // l'orientation h√©rit√©e du parent (si il y en a une).
                        startOrientation = startOrientation.multiply(rotQuat); 
                    }
                }
                
                // --- 3. MISE √Ä JOUR DES √âTATS GLOBALS ET INTERM√âDIAIRES ---

                // Sauvegarde de l'√©tat Monde (apr√®s application de P) pour ses enfants
                pastilleWorldStates[p.id] = { 
                    orientation: startOrientation, 
                    position: startPosition 
                };
                
                // Si c'est une animation racine, elle devient l'√©tat global pour les futures pastilles racines.
                if (!isChild) {
                    orientation = startOrientation;
                    position = startPosition;
                }
            });
            
            // Le transform final est l'√©tat global accumul√©.
            const combinedTransform = orientation.toMatrix4(position.x, position.y, position.z);
            previewObject.style.transform = combinedTransform;
            previewInner.style.transform = ''; 
            previewInner.textContent = `OBJET`;
        };
        
        const animateTimeline = (timestamp) => {
            if (!animationStartTime) animationStartTime = timestamp;
            const elapsed = timestamp - animationStartTime;
            currentTimelineTime = elapsed;
            if(currentTimelineTime > totalTimelineDuration){
                animationStartTime = timestamp;
                currentTimelineTime = 0;
            }
            // Affichage avec le format correct (HH:MM:SS:ms)
            currentTimeDisplay.textContent = formatTimeDisplay(currentTimelineTime); 
            applyTransform(currentTimelineTime);
            animationFrame = requestAnimationFrame(animateTimeline);
        };

        // üõë CORRECTION : R√©initialisation de l'affichage du temps
        const stopAnimation = () => {
            cancelAnimationFrame(animationFrame);
            animationFrame = null;
            animationStartTime = 0;
            currentTimelineTime = 0;
            previewCard.style.display = 'none';
            previewObject.style.transform = ''; 
            previewObject.style.transformOrigin = '50% 50% 0';
            previewInner.style.transform = ''; 
            currentTimeDisplay.textContent = formatTimeDisplay(0); // R√©initialisation de la minuterie
        };

        referencePastille.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', 'reference-pastille');
            e.target.classList.add('dragging'); 
        });
        referencePastille.addEventListener('dragend', (e) => e.target.classList.remove('dragging'));

        timeline.addEventListener('dragover', (e) => e.preventDefault());
        timeline.addEventListener('drop', (e) => {
            e.preventDefault();
            const id = e.dataTransfer.getData('text/plain');
            const draggedElement = document.getElementById(id);
            const rect = timeline.getBoundingClientRect();
            const x = e.clientX - rect.left + timelineContainer.scrollLeft;
            const y = e.clientY - rect.top + timelineContainer.scrollTop;

            if (id === 'reference-pastille') {
                const newPastille = createPastille(x, y);
                showTimeEditor(newPastille);
            } else if (draggedElement && draggedElement.classList.contains('pastille')) {
                draggedElement.classList.remove('pastille-drop-bounce'); 
                void draggedElement.offsetWidth; 
                draggedElement.classList.add('pastille-drop-bounce');
                draggedElement.style.left = `${x}px`;
                draggedElement.style.top = `${y}px`;
                const startMs = (x-30) * (totalTimelineDuration / timeline.scrollWidth);
                const endMs = parseInt(draggedElement.dataset.endTimeMs) - parseInt(draggedElement.dataset.startTimeMs) + startMs;
                draggedElement.dataset.startTimeMs = Math.max(0, startMs);
                draggedElement.dataset.endTimeMs = Math.max(0, endMs);
                updateAndDrawMarkers();
            }
        });

        okBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (!activePastille) return;
                const getMs = (type) => timeToMilliseconds(
                    document.getElementById(`${type}-h`).value, document.getElementById(`${type}-m`).value,
                    document.getElementById(`${type}-s`).value, document.getElementById(`${type}-ms`).value
                );
                
                const newAxis = editorAxisSelector.value;
                activePastille.dataset.startTimeMs = getMs('start');
                activePastille.dataset.endTimeMs = getMs('end');
                activePastille.dataset.axis = newAxis;
                activePastille.dataset.startValue = startValueInput.value;
                activePastille.dataset.endValue = endValueInput.value;
                
                if (newAxis === 'rotation Pivot') {
                    activePastille.dataset.pivotAx = document.getElementById('pivot-ax').value;
                    activePastille.dataset.pivotAy = document.getElementById('pivot-ay').value;
                    activePastille.dataset.pivotAz = document.getElementById('pivot-az').value;
                    activePastille.dataset.pivotBx = document.getElementById('pivot-bx').value;
                    activePastille.dataset.pivotBy = document.getElementById('pivot-by').value;
                    activePastille.dataset.pivotBz = document.getElementById('pivot-bz').value;
                }

                // NOUVEAU: Sauvegarde de la Parent√© et de la Position Relative
                activePastille.dataset.parentId = parentIdSelector.value;
                activePastille.dataset.relativeX = relativeXInput.value;
                activePastille.dataset.relativeY = relativeYInput.value;
                activePastille.dataset.relativeZ = relativeZInput.value;
                // FIN NOUVEAU

                curvePoints.forEach((cp, index) => {
                    activePastille.dataset[`curveP${index}Left`] = cp.style.left;
                    activePastille.dataset[`curveP${index}Top`] = cp.style.top;
                });
                
                updatePastilleStyle(activePastille); 
                
                timeEditor.style.display = 'none';
                updateAndDrawMarkers();
                activePastille = null;
            });
        });

        closeEditorBtn.addEventListener('click', () => {
            if (activePastille && (parseInt(activePastille.dataset.startTimeMs) === 0 && parseInt(activePastille.dataset.endTimeMs) === 0)) {
                activePastille.remove();
            } else if (activePastille && confirm("Voulez-vous supprimer cette animation ?")) {
                activePastille.remove();
                updateAndDrawMarkers();
            }
            timeEditor.style.display = 'none';
            activePastille = null;
        });

        playBtn.addEventListener('click', () => {
            if (totalTimelineDuration <= 1) {
                alert("Veuillez cr√©er et configurer au moins une animation avec une dur√©e !");
                return;
            }
            previewCard.style.display = 'flex';
            previewObject.style.transform = ''; 
            previewInner.style.transform = '';
            animationFrame = requestAnimationFrame(animateTimeline);
        });

        // Le bouton de fermeture appelle stopAnimation
        closePreviewBtn.addEventListener('click', stopAnimation);

        // --- Fonctions d'export/import JSON (inchang√©es) ---

        saveJsonBtn.addEventListener('click', () => {
            const pastillesData = Array.from(timeline.querySelectorAll('.pastille')).map(p => {
                const data = { 
                    left: p.style.left, 
                    top: p.style.top,
                    id: p.id
                };
                for (const key in p.dataset) {
                    data[key] = p.dataset[key];
                }
                return data;
            });

            const exportData = {
                timestamp: new Date().toISOString(),
                pastilles: pastillesData
            };
            
            downloadJson(exportData, `timeline_export_${Date.now()}.json`);
        });

        loadJsonBtn.addEventListener('click', () => {
            loadJsonFile.click();
        });

        loadJsonFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const jsonContent = JSON.parse(event.target.result);
                    importTimelineFromJson(jsonContent);
                } catch (error) {
                    alert("Erreur lors du chargement du fichier JSON. Format invalide.");
                    console.error("Erreur de chargement JSON:", error);
                }
            };
            reader.readAsText(file);
            e.target.value = null; 
        });

        const importTimelineFromJson = (importData) => {
            if (!importData || !Array.isArray(importData.pastilles)) {
                alert("Erreur: Le fichier JSON ne contient pas de tableau 'pastilles' valide.");
                return;
            }

            const newGroupId = `group-${Date.now()}`;
            const newGroupColor = getRandomPaleColor();
            const newGroupNumber = nextGroupNumber++;

            const newGroup = {
                id: newGroupId,
                number: newGroupNumber,
                color: newGroupColor
            };
            allGroups.push(newGroup);
            
            // Assurez-vous d'importer les pastilles dans l'ordre pour les d√©pendances
            importData.pastilles.sort((a, b) => {
                const idA = a.id || '';
                const idB = b.id || '';
                if (b.parentId === idA) return -1; // A doit venir avant B si A est le parent de B
                if (a.parentId === idB) return 1;  // B doit venir avant A si B est le parent de A
                return 0;
            });


            importData.pastilles.forEach(pData => {
                const x = parseFloat(pData.left.replace('px', '')) || 30;
                const y = parseFloat(pData.top.replace('px', '')) || 50;
                
                createPastille(x, y, pData, newGroupId, newGroupNumber);
            });

            updateGroupList();
            updateAndDrawMarkers();
            
            alert(`S√©quence import√©e avec succ√®s! Pastilles ajout√©es au Groupe ${newGroupNumber} (couleur p√¢le).`);
        };
        // --- Fin fonctions d'export/import JSON ---

        // --- Initialisation ---
        currentTimeDisplay.textContent = formatTimeDisplay(0); 
        updateCanvasSize();
        updateAndDrawMarkers();
        updateGroupList(); 
    });
    </script>
</body>
</html>
