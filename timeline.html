<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline Futuriste Avancée V7 - Slides de Paramétrage</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #0d0c1d;
            --primary-glow: #00e5ff;
            --secondary-glow: #ff4700;
            --marker-color: #fffa7a;
            --widget-bg: #1f1e33;
            --text-color: #f0f0f0;
            --border-color: rgba(0, 229, 255, 0.4);
            --danger-color: #ff3366;
            --color-axex: #ff0077; 
            --color-axey: #00ffaa; 
            --color-axez: #00aaff; 
            --color-rotx: #ffaa00; 
            --color-roty: #aa00ff; 
            --color-rotz: #ff0000;
            --color-pivot: #f0f0f0; 
            --bar-color-axex: rgba(255, 0, 119, 0.4); 
            --bar-color-axey: rgba(0, 255, 170, 0.4); 
            --bar-color-axez: rgba(0, 170, 255, 0.4); 
            --bar-color-rotx: rgba(255, 170, 0, 0.4); 
            --bar-color-roty: rgba(170, 0, 255, 0.4); 
            --bar-color-rotz: rgba(255, 0, 0, 0.4);
            --bar-color-pivot: rgba(240, 240, 240, 0.4); 
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
        }

        #top-header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px; 
            z-index: 1000;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            background: rgba(13, 12, 29, 0.8);
            backdrop-filter: blur(5px);
            border-bottom: 1px solid var(--border-color);
        }

        #reference-pastille {
            width: 30px; 
            height: 30px; 
            background-color: var(--secondary-glow);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--secondary-glow), 0 0 15px var(--secondary-glow);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #reference-pastille:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px var(--secondary-glow), 0 0 20px var(--secondary-glow);
        }
        #reference-pastille.dragging {
            transform: scale(1.5);
            opacity: 0.8; 
            box-shadow: 0 0 15px var(--secondary-glow), 0 0 30px var(--secondary-glow);
            cursor: grabbing;
        }

        button, select, input {
            background-color: var(--widget-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px 12px; 
            font-family: 'Roboto Mono', monospace;
            transition: background-color 0.2s, box-shadow 0.2s, border-color 0.2s;
        }

        select {
            cursor: pointer;
        }
        
        button {
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            border-color: var(--primary-glow);
            box-shadow: 0 0 8px var(--primary-glow);
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-glow);
            box-shadow: 0 0 8px var(--primary-glow);
        }
        
        #play-btn {
            background-color: var(--color-axey); 
            color: var(--bg-color);
            border-color: var(--color-axey);
            box-shadow: 0 0 10px var(--color-axey);
        }
        #play-btn:hover {
             box-shadow: 0 0 15px var(--color-axey), 0 0 25px var(--color-axey);
        }

        #timeline-container {
            position: absolute;
            top: 60px; 
            left: 0;
            width: 100%;
            height: calc(100% - 60px);
            background: #0a0918;
            overflow: auto;
        }
        #timeline-container::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        #timeline-container::-webkit-scrollbar-track {
            background: #0a0918;
        }
        #timeline-container::-webkit-scrollbar-thumb {
            background-color: var(--primary-glow);
            border-radius: 10px;
            border: 2px solid #0a0918;
        }

        #timeline {
            position: relative;
            width: 3000px;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 229, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 229, 255, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            border-top: 1px solid var(--border-color);
        }
        
        .pastille {
            position: absolute;
            top: 50%;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            transition: top 0.6s cubic-bezier(.17,.89,.32,1.45), left 0.6s cubic-bezier(.17,.89,.32,1.45), box-shadow 0.2s, background-color 0.2s;
            z-index: 10;
        }

        @keyframes bounce-in {
            0% { transform: translate(-50%, -50%) scale(0.6); opacity: 0.5; } 
            50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; } 
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        @keyframes squish-and-lift {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(0.8, 1.2); box-shadow: 0 0 5px var(--secondary-glow); } 
            100% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.5; box-shadow: 0 0 20px var(--secondary-glow); } 
        }

        .pastille-drop-bounce {
            animation: bounce-in 0.6s cubic-bezier(.17,.89,.32,1.45); 
        }

        .pastille-drag-squish {
            animation: squish-and-lift 0.2s forwards; 
            cursor: grabbing;
        }
        
        .duration-bar {
            position: absolute;
            left: 15px; 
            top: 15px; 
            transform: translateY(-50%); 
            height: 2px;
            border-radius: 1px;
            transition: width 0.5s ease-in-out;
            z-index: 9;
        }

        .time-marker {
            position: absolute;
            width: 1px;
            background: var(--marker-color);
            opacity: 0.7;
            color: var(--marker-color);
            z-index: 1;
        }
        .time-label {
            position: absolute;
            font-size: 8px; 
            display: flex;
            flex-direction: column; 
            align-items: center;
            line-height: 1;
        }
        .marker-top { top: 0; height: 40px; }
        .marker-top .time-label { top: -45px; }

        .marker-bottom { bottom: 0; height: 40px; }
        .marker-bottom .time-label { bottom: -45px; top: unset; }

        .marker-end {
            top: 50%;
            height: 20px;
            transform: translateY(-50%);
        }
        .marker-end .time-label { top: -40px; left: 0; transform: translateX(0); }

        /* MODIFIÉ: Nouvelle structure pour les slides (display: none par défaut) */
        #time-editor {
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            display: none; /* Masqué par défaut */ 
            width: 450px; /* Largeur par défaut pour Slide 1 (Contrôles) */
            background-color: var(--widget-bg);
            border: 1px solid var(--border-color);
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.3);
            z-index: 2000; 
            overflow: hidden; 
            font-size: 12px; /* Police conservée */
            transition: width 0.3s ease-in-out; /* Transition pour le changement de slide */
        }
        .editor-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 12px; border-bottom: 1px solid var(--border-color);
            cursor: default; 
            background: rgba(0,0,0,0.2);
        }

        /* Styles de la Slide 1 */
        .editor-body-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
        }

        /* Styles de la Slide 2 */
        #editor-slide-2 {
            padding: 15px;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 16px; 
            color: var(--text-color);
            width: 25px;
            height: 25px;
            line-height: 25px;
            text-align: center;
            padding: 0;
            border-radius: 50%;
        }
        .close-btn:hover {
            background-color: var(--danger-color);
            color: white;
            box-shadow: 0 0 8px var(--danger-color);
        }

        fieldset {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        legend {
            padding: 0 5px;
            font-size: 11px;
            color: var(--primary-glow);
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .input-group label {
            opacity: 0.8;
            width: 15px;
            text-align: right;
        }
        .input-group input {
            width: 50px;
            padding: 4px;
        }
        input[type="text"]{
             width: 80px;
        }

        #pivot-fieldset {
            display: none; 
        }
        #pivot-fieldset .pivot-group {
             flex-basis: 100%;
             display: flex;
             gap: 8px;
             justify-content: space-around;
        }

        /* Footer des Slides */
        .slide-footer {
            padding: 10px 15px;
            border-top: 1px solid var(--border-color);
            display: flex; 
            justify-content: space-between;
            background: rgba(0,0,0,0.2);
        }

        /* Bouton OK */
        .ok-btn {
            background-color: var(--primary-glow);
            border-color: var(--primary-glow);
            color: var(--bg-color);
            padding: 6px 10px;
            font-size: 12px;
            font-weight: bold;
        }

        /* Boutons Suivant/Précédent */
        .slide-btn {
            padding: 6px 10px;
            font-size: 12px;
            background-color: var(--widget-bg);
            border-color: var(--border-color);
        }

        #curve-area {
            width: 100%;
            height: 300px; /* Taille augmentée pour la slide dédiée */
            border: 1px solid var(--border-color);
            border-radius: 4px;
            position: relative;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 25px 25px;
            overflow: hidden;
            z-index: 200; 
        }
        #curve-canvas {
            display: block; 
            width: 100%;
            height: 100%;
        }
        .curve-control-point {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            cursor: grab;
            z-index: 210;
            transform: translate(-50%, -50%);
            background-color: var(--secondary-glow);
            box-shadow: 0 0 5px var(--secondary-glow);
        }
        .curve-control-point.start-end {
            background-color: var(--color-axey); 
            box-shadow: 0 0 5px var(--color-axey);
        }
        
        #preview-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 90%;
           background-image: 
                linear-gradient(rgba(0, 229, 255, 0.05) .5px, transparent .5px),
                linear-gradient(90deg, rgba(0, 229, 255, 0.05) 1px, transparent 1px);
            border: 2px solid var(--primary-glow);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 229, 255, 0.5);
            z-index: 3000; 
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: space-around; 
            padding: 20px;
            perspective: 800px;
        }
        
        #preview-card h3 {
            font-size: 16px;
            color: var(--primary-glow);
            text-align: center;
        }

        #preview-object {
            width: 200px;
            height: 300px;
            transform-style: preserve-3d; 
            display: flex; 
            align-items: center;
            justify-content: center;
        }

        #preview-inner {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: var(--color-axey);
            border: 2px dashed var(--color-axey);
            border-radius: 8px;
            transform-style: preserve-3d; 
            background-image: url("Psg.jpg");
            background-size: cover;      
            background-repeat: no-repeat;
            background-position: center;
        }

        #current-time-display {
            font-size: 18px;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div id="top-header">
        <div id="reference-pastille" draggable="true"></div> 
        <button id="play-btn">▶ Démarrer Simulation</button>
    </div>

    <div id="timeline-container">
        <div id="timeline"></div>
    </div>

    <div id="preview-card">
        <h3>Simulation</h3>
        <div id="preview-object">
            <div id="preview-inner">OBJET</div>
        </div>
        <span id="current-time-display">00:00:00:000</span>
        <button id="close-preview-btn" class="close-btn" style="position: absolute; top: 5px; right: 5px;">×</button>
    </div>

    <div id="time-editor">
        <div class="editor-header">
            <span>Définir l'Animation</span>
            <button id="close-editor-btn" class="close-btn">×</button>
        </div>
        
        <div id="slide-container"> 
            
            <div id="editor-slide-1" class="editor-slide">
                <div class="editor-body-controls">
                    <div class="input-group" style="align-self: center;">
                        <label for="editor-axis-selector" style="width: auto;">Axe :</label>
                        <select id="editor-axis-selector" style="width: 150px; padding: 4px 8px;">
                            <option value="Axe X">Axe X</option>
                            <option value="Axe Y">Axe Y</option>
                            <option value="Axe Z">Axe Z</option>
                            <option value="rotation X">Rotation X</option>
                            <option value="rotation Y">Rotation Y</option>
                            <option value="rotation Z">Rotation Z</option>
                            <option value="rotation Pivot">Rotation Axe Personnalisé</option>
                        </select>
                    </div>
                    
                    <fieldset>
                        <legend>Valeurs</legend>
                        <div class="input-group"><label>Début</label><input type="text" id="start-value" value="0"></div>
                        <div class="input-group"><label>Fin</label><input type="text" id="end-value" value="100"></div>
                    </fieldset>
                    
                    <fieldset id="pivot-fieldset">
                        <legend>Points Pivots (%)</legend>
                        <div class="pivot-group">
                            <div class="input-group"><label for="pivot-ax">Ax</label><input type="number" id="pivot-ax" value="-50"></div>
                            <div class="input-group"><label for="pivot-ay">Ay</label><input type="number" id="pivot-ay" value="-50"></div>
                            <div class="input-group"><label for="pivot-az">Az</label><input type="number" id="pivot-az" value="0"></div>
                        </div>
                        <div class="pivot-group">
                             <div class="input-group"><label for="pivot-bx">Bx</label><input type="number" id="pivot-bx" value="50"></div>
                            <div class="input-group"><label for="pivot-by">By</label><input type="number" id="pivot-by" value="50"></div>
                            <div class="input-group"><label for="pivot-bz">Bz</label><input type="number" id="pivot-bz" value="0"></div>
                        </div>
                    </fieldset>
    
                    <div>
                        <fieldset>
                            <legend>Début (HH:MM:SS:ms)</legend>
                            <div class="input-group"><label for="start-h">HH</label><input type="number" id="start-h" min="0" value="0"></div>
                            <div class="input-group"><label for="start-m">MM</label><input type="number" id="start-m" min="0" max="59" value="0"></div>
                            <div class="input-group"><label for="start-s">SS</label><input type="number" id="start-s" min="0" max="59" value="0"></div>
                            <div class="input-group"><label for="start-ms">ms</label><input type="number" id="start-ms" min="0" max="999" value="0"></div>
                        </fieldset>
                        <fieldset>
                            <legend>Fin (HH:MM:SS:ms)</legend>
                            <div class="input-group"><label for="end-h">HH</label><input type="number" id="end-h" min="0" value="0"></div>
                            <div class="input-group"><label for="end-m">MM</label><input type="number" id="end-m" min="0" max="59" value="0"></div>
                            <div class="input-group"><label for="end-s">SS</label><input type="number" id="end-s" min="0" max="59" value="0"></div>
                            <div class="input-group"><label for="end-ms">ms</label><input type="number" id="end-ms" min="0" max="999" value="0"></div>
                        </fieldset>
                    </div>
                </div>
                <div class="slide-footer">
                    <button id="next-slide-btn" class="slide-btn">Suivant >></button>
                    <button class="ok-btn">OK</button>
                </div>
            </div>
            
            <div id="editor-slide-2" class="editor-slide" style="display: none;">
                <div id="curve-area">
                    <canvas id="curve-canvas"></canvas>
                    <div class="curve-control-point start-end" id="p0" data-index="0" style="left: 0%; top: 100%;"></div>
                    <div class="curve-control-point" id="p1" data-index="1" style="left: 33%; top: 50%;"></div>
                    <div class="curve-control-point" id="p2" data-index="2" style="left: 66%; top: 50%;"></div>
                    <div class="curve-control-point start-end" id="p3" data-index="3" style="left: 100%; top: 0%;"></div>
                </div>
                <div class="slide-footer">
                    <button id="prev-slide-btn" class="slide-btn"><< Précédent</button>
                    <button class="ok-btn">OK</button>
                </div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        class Quaternion {
            constructor(w, x, y, z) { this.w = w; this.x = x; this.y = y; this.z = z; }
            static fromAxisAngle(axis, angle) {
                const s = Math.sin(angle / 2);
                return new Quaternion(Math.cos(angle / 2), axis.x * s, axis.y * s, axis.z * s);
            }
            multiply(q) {
                return new Quaternion(
                    this.w*q.w-this.x*q.x-this.y*q.y-this.z*q.z,
                    this.w*q.x+this.x*q.w+this.y*q.z-this.z*q.y,
                    this.w*q.y-this.x*q.z+this.y*q.w+this.z*q.x,
                    this.w*q.z+this.x*q.y-this.y*q.x+this.z*q.w
                );
            }
            rotatePoint(p) {
                const qp = new Quaternion(0, p.x, p.y, p.z);
                const res = this.multiply(qp).multiply(new Quaternion(this.w, -this.x, -this.y, -this.z));
                return { x: res.x, y: res.y, z: res.z };
            }
            toMatrix4(tx = 0, ty = 0, tz = 0) {
                const w=this.w, x=this.x, y=this.y, z=this.z,
                      x2=x+x, y2=y+y, z2=z+z,
                      xx=x*x2, xy=x*y2, xz=x*z2,
                      yy=y*y2, yz=y*z2, zz=z*z2,
                      wx=w*x2, wy=w*y2, wz=w*z2;
                
                const matrixValues = [
                    1-(yy+zz), xy+wz, xz-wy, 0,
                    xy-wz, 1-(xx+zz), yz+wx, 0,
                    xz+wy, yz-wx, 1-(xx+yy), 0,
                    tx, ty, tz, 1
                ];
                return `matrix3d(${matrixValues.join(',')})`;
            }
        }

        const timelineContainer = document.getElementById('timeline-container');
        const timeline = document.getElementById('timeline');
        const referencePastille = document.getElementById('reference-pastille');
        const timeEditor = document.getElementById('time-editor');
        const editorHeader = timeEditor.querySelector('.editor-header');
        // Remplacé okEditorBtn par la sélection de tous les boutons .ok-btn
        const okBtns = document.querySelectorAll('#time-editor .ok-btn'); 
        const closeEditorBtn = document.getElementById('close-editor-btn');
        const editorAxisSelector = document.getElementById('editor-axis-selector');
        const startValueInput = document.getElementById('start-value');
        const endValueInput = document.getElementById('end-value');
        const pivotFieldset = document.getElementById('pivot-fieldset');
        let activePastille = null;

        // Nouvelles références pour le multi-slide
        const slide1 = document.getElementById('editor-slide-1');
        const slide2 = document.getElementById('editor-slide-2');
        const nextSlideBtn = document.getElementById('next-slide-btn');
        const prevSlideBtn = document.getElementById('prev-slide-btn');

        const playBtn = document.getElementById('play-btn');
        const previewCard = document.getElementById('preview-card');
        const closePreviewBtn = document.getElementById('close-preview-btn');
        const previewObject = document.getElementById('preview-object');
        const previewInner = document.getElementById('preview-inner');
        const currentTimeDisplay = document.getElementById('current-time-display');
        let animationFrame = null;
        let animationStartTime = 0;
        let totalTimelineDuration = 0;
        let currentTimelineTime = 0;
        
        const curveArea = document.getElementById('curve-area');
        const canvas = document.getElementById('curve-canvas');
        const ctx = canvas.getContext('2d');
        const curvePoints = Array.from(document.querySelectorAll('.curve-control-point'));

        let currentSlide = 1;

        const timeToMilliseconds = (h, m, s, ms) => (parseInt(h||0)*3600+parseInt(m||0)*60+parseInt(s||0))*1000+parseInt(ms||0);
        const millisecondsToTime = (totalMs) => {
            if (isNaN(totalMs) || totalMs < 0) return { h:0,m:0,s:0,ms:0 };
            let r=totalMs; const h=Math.floor(r/3600000); r%=3600000;
            const m=Math.floor(r/60000); r%=60000;
            const s=Math.floor(r/1000); const ms=r%1000;
            return {h,m,s,ms};
        };
        const formatTimeDisplay = (ms) => {
            const t = millisecondsToTime(ms);
            return `${String(t.h).padStart(2,'0')}:${String(t.m).padStart(2,'0')}:${String(t.s).padStart(2,'0')}:${String(t.ms).padStart(3,'0')}`;
        };
        const formatTimeVertical = (ms) => {
            const t = millisecondsToTime(ms);
            return `<div class="time-label">
                <span>${String(t.h).padStart(2,'0')}H</span>
                <span>${String(t.m).padStart(2,'0')}M</span>
                <span>${String(t.s).padStart(2,'0')}S</span>
                <span>${String(t.ms).padStart(3,'0')}ms</span>
            </div>`;
        };
        const getAxisColor = (axis) => {
            switch(axis) {
                case "Axe X": return "var(--color-axex)";
                case "Axe Y": return "var(--color-axey)";
                case "Axe Z": return "var(--color-axez)";
                case "rotation X": return "var(--color-rotx)";
                case "rotation Y": return "var(--color-roty)";
                case "rotation Z": return "var(--color-rotz)";
                case "rotation Pivot": return "var(--color-pivot)";
                default: return "var(--primary-glow)";
            }
        };

        const getBarColor = (axis) => {
            switch(axis) {
                case "Axe X": return "var(--bar-color-axex)";
                case "Axe Y": return "var(--bar-color-axey)";
                case "Axe Z": return "var(--bar-color-axez)";
                case "rotation X": return "var(--bar-color-rotx)";
                case "rotation Y": return "var(--bar-color-roty)";
                case "rotation Z": return "var(--bar-color-rotz)";
                case "rotation Pivot": return "var(--bar-color-pivot)";
                default: return "var(--border-color)";
            }
        };

        const updateCanvasSize = () => {
            // S'assure que la taille du canvas correspond à son conteneur pour le redimensionnement
            canvas.width = curveArea.clientWidth;
            canvas.height = curveArea.clientHeight;
            drawBezierCurve();
        };
        
        const showSlide = (slideNumber) => {
            slide1.style.display = (slideNumber === 1) ? 'block' : 'none';
            slide2.style.display = (slideNumber === 2) ? 'block' : 'none';
            currentSlide = slideNumber;

            // Ajustement de la largeur de la fenêtre pour la slide
            if (slideNumber === 2) {
                timeEditor.style.width = '330px'; 
                updateCanvasSize();
            } else {
                timeEditor.style.width = '450px'; 
            }
        };

        nextSlideBtn.addEventListener('click', () => showSlide(2));
        prevSlideBtn.addEventListener('click', () => showSlide(1));

        const drawBezierCurve = () => {
            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            const getPointCoords = (index) => {
                const style = curvePoints[index].style;
                const x = parseFloat(style.left) * w / 100;
                const y = h - (parseFloat(style.top) * h / 100); 
                return { x, y };
            };
            
            if (w === 0 || h === 0) return;

            const p0 = getPointCoords(0);
            const p1 = getPointCoords(1);
            const p2 = getPointCoords(2);
            const p3 = getPointCoords(3);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.moveTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.stroke();
            ctx.setLineDash([]); 

            ctx.strokeStyle = 'var(--secondary-glow)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
            ctx.stroke();
        };

        let draggingCurvePoint = null;
        const startDragCurve = (e) => {
            draggingCurvePoint = e.target;
            const rect = curveArea.getBoundingClientRect();

            const moveHandler = (moveEvent) => {
                if (!draggingCurvePoint) return;
                let x = moveEvent.clientX - rect.left;
                let y = moveEvent.clientY - rect.top;
                let newLeft = (x / rect.width) * 100;
                let newTop = (y / rect.height) * 100;
                const index = parseInt(draggingCurvePoint.dataset.index);
                newLeft = Math.max(0, Math.min(100, newLeft));
                newTop = Math.max(0, Math.min(100, newTop));
                if (index === 1 || index === 2) {
                    draggingCurvePoint.style.left = `${newLeft}%`;
                    draggingCurvePoint.style.top = `${newTop}%`;
                } else if (index === 0) {
                    draggingCurvePoint.style.left = `0%`; 
                    draggingCurvePoint.style.top = `${newTop}%`;
                } else if (index === 3) {
                    draggingCurvePoint.style.left = `100%`; 
                    draggingCurvePoint.style.top = `${newTop}%`;
                }
                drawBezierCurve();
            };

            const stopHandler = () => {
                 if (activePastille && draggingCurvePoint) {
                    const pointIndex = draggingCurvePoint.dataset.index;
                    activePastille.dataset[`curveP${pointIndex}Left`] = draggingCurvePoint.style.left;
                    activePastille.dataset[`curveP${pointIndex}Top`] = draggingCurvePoint.style.top;
                }
                draggingCurvePoint = null;
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', stopHandler);
            };

            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', stopHandler);
            e.preventDefault();
        };
        curvePoints.forEach(p => p.addEventListener('mousedown', startDragCurve));
        window.addEventListener('resize', updateCanvasSize);


        const createPastille = (x, y) => {
            const pastille = document.createElement('div');
            pastille.className = 'pastille pastille-drop-bounce'; 
            pastille.id = `pastille-${Date.now()}`;
            
            const minX = 30; 
            const finalX = Math.max(minX, x);

            pastille.style.left = `${finalX}px`;
            pastille.style.top = `${y}px`;
            pastille.dataset.startTimeMs = '0';
            pastille.dataset.endTimeMs = '0';
            pastille.dataset.startValue = '0';
            pastille.dataset.endValue = '100';
            pastille.dataset.axis = 'Axe X'; 

            // Default curve points
            pastille.dataset.curveP0Left = '0%'; pastille.dataset.curveP0Top = '100%';
            pastille.dataset.curveP1Left = '33%'; pastille.dataset.curveP1Top = '50%';
            pastille.dataset.curveP2Left = '66%'; pastille.dataset.curveP2Top = '50%';
            pastille.dataset.curveP3Left = '100%'; pastille.dataset.curveP3Top = '0%';
            
            // Default pivot points
            pastille.dataset.pivotAx = "-50"; pastille.dataset.pivotAy = "-50"; pastille.dataset.pivotAz = "0";
            pastille.dataset.pivotBx = "50"; pastille.dataset.pivotBy = "50"; pastille.dataset.pivotBz = "0";

            
            const durationBar = document.createElement('div');
            durationBar.className = 'duration-bar';
            pastille.appendChild(durationBar);
            timeline.appendChild(pastille);

            pastille.addEventListener('animationend', (e) => {
                if (e.animationName === 'bounce-in') {
                    pastille.classList.remove('pastille-drop-bounce');
                }
            });

            const initialColor = getAxisColor(pastille.dataset.axis);
            const initialBarColor = getBarColor(pastille.dataset.axis);

            pastille.style.setProperty('background-color', initialColor);
            pastille.style.setProperty('box-shadow', `0 0 8px ${initialColor}, 0 0 15px ${initialColor}`);
            durationBar.style.setProperty('background-color', initialBarColor);
            durationBar.style.setProperty('box-shadow', `0 0 4px ${initialColor}`); 

            pastille.addEventListener('click', (e) => {
                showTimeEditor(pastille);
            });
            pastille.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', e.target.id);
                e.dataTransfer.effectAllowed = 'move';
                e.target.classList.add('pastille-drag-squish'); 
            });
            pastille.addEventListener('dragend', (e) => {
                e.target.classList.remove('pastille-drag-squish'); 
                updateAndDrawMarkers();
            });
            return pastille;
        };

        editorAxisSelector.addEventListener('change', (e) => {
            pivotFieldset.style.display = (e.target.value === 'rotation Pivot') ? 'flex' : 'none';
        });

        const showTimeEditor = (p) => {
            activePastille = p;
            
            const startTime = millisecondsToTime(parseInt(p.dataset.startTimeMs));
            const endTime = millisecondsToTime(parseInt(p.dataset.endTimeMs));
            
            ['start','end'].forEach(type => {
                const t = type === 'start' ? startTime : endTime;
                Object.keys(t).forEach(unit => document.getElementById(`${type}-${unit}`).value = t[unit] );
            });
            startValueInput.value = p.dataset.startValue;
            endValueInput.value = p.dataset.endValue;
            editorAxisSelector.value = p.dataset.axis;

            // Show/hide pivot fields based on saved axis
            pivotFieldset.style.display = (p.dataset.axis === 'rotation Pivot') ? 'flex' : 'none';
            
            // Populate pivot fields
            document.getElementById('pivot-ax').value = p.dataset.pivotAx;
            document.getElementById('pivot-ay').value = p.dataset.pivotAy;
            document.getElementById('pivot-az').value = p.dataset.pivotAz;
            document.getElementById('pivot-bx').value = p.dataset.pivotBx;
            document.getElementById('pivot-by').value = p.dataset.pivotBy;
            document.getElementById('pivot-bz').value = p.dataset.pivotBz;

            curvePoints.forEach((cp, index) => {
                cp.style.left = p.dataset[`curveP${index}Left`] || cp.style.left;
                cp.style.top = p.dataset[`curveP${index}Top`] || cp.style.top;
            });
            
            timeEditor.style.display = 'block';
            showSlide(1); // Affiche la première slide par défaut
        };
        
        const updateAndDrawMarkers = () => {
            document.querySelectorAll('.time-marker').forEach(m => m.remove());
            let pastilles = Array.from(timeline.querySelectorAll('.pastille'));
            pastilles.sort((a, b) => parseInt(a.dataset.startTimeMs) - parseInt(b.dataset.startTimeMs));
            
            if (pastilles.length === 0) {
                totalTimelineDuration = 0; return;
            }
            let maxTime = 0;
            pastilles.forEach(p => maxTime = Math.max(maxTime, parseInt(p.dataset.endTimeMs)) );
            if (maxTime <= 0) maxTime = 1000;
            totalTimelineDuration = maxTime;

            const timelineWidth = timeline.scrollWidth;
            const pixelsPerMs = timelineWidth / totalTimelineDuration;
            const minX = 30;

            pastilles.forEach(p => {
                const startMs = parseInt(p.dataset.startTimeMs);
                const endMs = parseInt(p.dataset.endTimeMs);
                const durationMs = Math.max(0, endMs - startMs);
                const posX = (startMs * pixelsPerMs);
                p.style.left = `${posX + minX}px`;
                const bar = p.querySelector('.duration-bar');
                if (bar) bar.style.width = `${durationMs * pixelsPerMs}px`;
                createMarker(posX + minX, formatTimeVertical(startMs), 'top');
                createMarker(posX + minX, formatTimeVertical(startMs), 'bottom');
                if (durationMs > 0) {
                    createMarker(posX + minX + (durationMs * pixelsPerMs), formatTimeVertical(endMs), 'end', p.style.top);
                }
            });
        };

        const createMarker = (x, htmlContent, type, y = null) => {
            const marker = document.createElement('div');
            marker.className = `time-marker marker-${type}`;
            marker.style.left = `${x}px`;
            if (y) marker.style.top = y;
            marker.innerHTML = htmlContent;
            timeline.appendChild(marker);
        };
        
        const getBezierValue = (t, P0_y, P1_y, P2_y, P3_y) => {
            const t2 = t*t, t3 = t2*t, mt = 1-t, mt2 = mt*mt, mt3 = mt2*mt;
            return P0_y * mt3 + 3 * P1_y * mt2 * t + 3 * P2_y * mt * t2 + P3_y * t3;
        };

        const applyTransform = (timeMs) => {
            let translateX = 0, translateY = 0, translateZ = 0;
            let orientation = new Quaternion(1, 0, 0, 0);

            // Default transform origin, reset each frame
            previewObject.style.transformOrigin = '50% 50% 0';

            const pastilles = timeline.querySelectorAll('.pastille');

            pastilles.forEach(p => {
                const startMs = parseInt(p.dataset.startTimeMs);
                const endMs = parseInt(p.dataset.endTimeMs);
                const durationMs = endMs - startMs;

                if (durationMs > 0 && timeMs >= startMs && timeMs <= endMs) {
                    const t_progression = (timeMs - startMs) / durationMs;
                    const curve_value = getBezierValue(t_progression, 1-(parseFloat(p.dataset.curveP0Top)/100), 1-(parseFloat(p.dataset.curveP1Top)/100), 1-(parseFloat(p.dataset.curveP2Top)/100), 1-(parseFloat(p.dataset.curveP3Top)/100));
                    const startVal = parseFloat(p.dataset.startValue || 0);
                    const endVal = parseFloat(p.dataset.endValue || 0);
                    const final_value = startVal + (endVal - startVal) * curve_value;
                    const axis = p.dataset.axis;
                    
                    if (axis === 'Axe X') translateX += final_value;
                    if (axis === 'Axe Y') translateY += final_value;
                    if (axis === 'Axe Z') translateZ += final_value;
                    
                    const angleRad = final_value * Math.PI / 180;
                    let rotQuat;

                    if (axis === 'rotation X') {
                        rotQuat = Quaternion.fromAxisAngle({x:1, y:0, z:0}, angleRad);
                        orientation = orientation.multiply(rotQuat);
                    } else if (axis === 'rotation Y') {
                        rotQuat = Quaternion.fromAxisAngle({x:0, y:1, z:0}, angleRad);
                        orientation = orientation.multiply(rotQuat);
                    } else if (axis === 'rotation Z') {
                        rotQuat = Quaternion.fromAxisAngle({x:0, y:0, z:1}, angleRad);
                        orientation = orientation.multiply(rotQuat);
                    } else if (axis === 'rotation Pivot') {
                        // 1. Set the transform origin based on Pivot A
                        const pAx = parseFloat(p.dataset.pivotAx || 0);
                        const pAy = parseFloat(p.dataset.pivotAy || 0);
                        const pAz = parseFloat(p.dataset.pivotAz || 0);
                        
                        // Convert from (-50, 50) to (0, 100) for CSS, and invert Y
                        const originX = 50 + pAx;
                        const originY = 50 - pAy; 
                        // Z is pixels based on a % of the object's width
                        const zUnit = previewObject.offsetWidth;
                        const originZ = (pAz / 100) * zUnit;
                        previewObject.style.transformOrigin = `${originX}% ${originY}% ${originZ}px`;

                        // 2. Calculate the rotation axis vector (B - A)
                        const pBx = parseFloat(p.dataset.pivotBx || 0);
                        const pBy = parseFloat(p.dataset.pivotBy || 0);
                        const pBz = parseFloat(p.dataset.pivotBz || 0);
                        let vx = pBx - pAx, vy = pBy - pAy, vz = pBz - pAz;

                        // 3. Normalize the vector
                        const mag = Math.sqrt(vx*vx + vy*vy + vz*vz);
                        let rotationAxis = {x: 0, y: 1, z: 0}; // Default to Y axis if magnitude is 0
                        if (mag > 1e-6) {
                            rotationAxis = { x: vx / mag, y: vy / mag, z: vz / mag };
                        }
                        
                        rotQuat = Quaternion.fromAxisAngle(rotationAxis, angleRad);
                        orientation = orientation.multiply(rotQuat);
                    }
                }
            });
            
            const combinedTransform = orientation.toMatrix4(translateX, translateY, translateZ);
            previewObject.style.transform = combinedTransform;
            previewInner.style.transform = ''; 
            previewInner.textContent = `OBJET`;
        };

        const animateTimeline = (timestamp) => {
            if (!animationStartTime) animationStartTime = timestamp;
            const elapsed = timestamp - animationStartTime;
            currentTimelineTime = elapsed;
            if(currentTimelineTime > totalTimelineDuration){
                animationStartTime = timestamp;
                currentTimelineTime = 0;
            }
            currentTimeDisplay.textContent = formatTimeDisplay(currentTimelineTime);
            applyTransform(currentTimelineTime);
            animationFrame = requestAnimationFrame(animateTimeline);
        };

        const stopAnimation = () => {
            cancelAnimationFrame(animationFrame);
            animationFrame = null;
            animationStartTime = 0;
            currentTimelineTime = 0;
            previewCard.style.display = 'none';
            previewObject.style.transform = ''; 
            previewObject.style.transformOrigin = '50% 50% 0';
            previewInner.style.transform = ''; 
            currentTimeDisplay.textContent = formatTimeDisplay(0); 
        };

        referencePastille.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', 'reference-pastille');
            e.target.classList.add('dragging'); 
        });
        referencePastille.addEventListener('dragend', (e) => e.target.classList.remove('dragging'));

        timeline.addEventListener('dragover', (e) => e.preventDefault());
        timeline.addEventListener('drop', (e) => {
            e.preventDefault();
            const id = e.dataTransfer.getData('text/plain');
            const draggedElement = document.getElementById(id);
            const rect = timeline.getBoundingClientRect();
            const x = e.clientX - rect.left + timelineContainer.scrollLeft;
            const y = e.clientY - rect.top + timelineContainer.scrollTop;

            if (id === 'reference-pastille') {
                const newPastille = createPastille(x, y);
                showTimeEditor(newPastille);
            } else if (draggedElement && draggedElement.classList.contains('pastille')) {
                draggedElement.classList.remove('pastille-drop-bounce'); 
                void draggedElement.offsetWidth; 
                draggedElement.classList.add('pastille-drop-bounce');
                draggedElement.style.left = `${x}px`;
                draggedElement.style.top = `${y}px`;
                const startMs = (x-30) * (totalTimelineDuration / timeline.scrollWidth);
                const endMs = parseInt(draggedElement.dataset.endTimeMs) - parseInt(draggedElement.dataset.startTimeMs) + startMs;
                draggedElement.dataset.startTimeMs = Math.max(0, startMs);
                draggedElement.dataset.endTimeMs = Math.max(0, endMs);
                updateAndDrawMarkers();
            }
        });

        // Logique de sauvegarde attachée à TOUS les boutons OK
        okBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (!activePastille) return;
                const getMs = (type) => timeToMilliseconds(
                    document.getElementById(`${type}-h`).value, document.getElementById(`${type}-m`).value,
                    document.getElementById(`${type}-s`).value, document.getElementById(`${type}-ms`).value
                );
                
                const newAxis = editorAxisSelector.value;
                activePastille.dataset.startTimeMs = getMs('start');
                activePastille.dataset.endTimeMs = getMs('end');
                activePastille.dataset.axis = newAxis;
                activePastille.dataset.startValue = startValueInput.value;
                activePastille.dataset.endValue = endValueInput.value;
                
                // Save pivot data if the axis is set to pivot
                if (newAxis === 'rotation Pivot') {
                    activePastille.dataset.pivotAx = document.getElementById('pivot-ax').value;
                    activePastille.dataset.pivotAy = document.getElementById('pivot-ay').value;
                    activePastille.dataset.pivotAz = document.getElementById('pivot-az').value;
                    activePastille.dataset.pivotBx = document.getElementById('pivot-bx').value;
                    activePastille.dataset.pivotBy = document.getElementById('pivot-by').value;
                    activePastille.dataset.pivotBz = document.getElementById('pivot-bz').value;
                }

                const newColor = getAxisColor(newAxis);
                const newBarColor = getBarColor(newAxis); 
                activePastille.style.setProperty('background-color', newColor);
                activePastille.style.setProperty('box-shadow', `0 0 8px ${newColor}, 0 0 15px ${newColor}`);
                const bar = activePastille.querySelector('.duration-bar');
                if (bar) {
                    bar.style.setProperty('background-color', newBarColor);
                    bar.style.setProperty('box-shadow', `0 0 4px ${newColor}`);
                }

                curvePoints.forEach((cp, index) => {
                    activePastille.dataset[`curveP${index}Left`] = cp.style.left;
                    activePastille.dataset[`curveP${index}Top`] = cp.style.top;
                });
                
                timeEditor.style.display = 'none';
                updateAndDrawMarkers();
                activePastille = null;
            });
        });

        closeEditorBtn.addEventListener('click', () => {
            if (activePastille && (parseInt(activePastille.dataset.startTimeMs) === 0 && parseInt(activePastille.dataset.endTimeMs) === 0)) {
                activePastille.remove();
            } else if (activePastille && confirm("Voulez-vous supprimer cette animation ?")) {
                activePastille.remove();
                updateAndDrawMarkers();
            }
            timeEditor.style.display = 'none';
            activePastille = null;
        });

        playBtn.addEventListener('click', () => {
            if (totalTimelineDuration <= 1) {
                alert("Veuillez créer et configurer au moins une animation avec une durée !");
                return;
            }
            previewCard.style.display = 'flex';
            previewObject.style.transform = ''; 
            previewInner.style.transform = '';
            animationFrame = requestAnimationFrame(animateTimeline);
        });

        closePreviewBtn.addEventListener('click', stopAnimation);

        updateCanvasSize();
        updateAndDrawMarkers();
    });
    </script>
</body>
</html>
