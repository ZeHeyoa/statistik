<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline Futuriste Avancée V5 - Triée & Stylisée</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #0d0c1d;
            --primary-glow: #00e5ff; /* Cyan */
            --secondary-glow: #ff4700; /* Orange */
            --duration-bar-color: #90ff00; /* Vert pâle */
            --marker-color: #fffa7a; /* Jaune pâle */
            --widget-bg: #1f1e33;
            --text-color: #f0f0f0;
            --border-color: rgba(0, 229, 255, 0.4);

            /* Couleurs pour les axes */
            --color-axex: #ff0077; 
            --color-axey: #00ffaa; 
            --color-axez: #00aaff; 
            --color-rotx: #ffaa00; 
            --color-roty: #aa00ff; 
            --color-rotz: #ff0000; 
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
        }

        /* --- En-tête et Pastille de Référence --- */
        #top-header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 20%; 
            z-index: 1000;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
        }

        #reference-pastille {
            width: 25px; 
            height: 25px; 
            background-color: var(--secondary-glow);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 10px var(--secondary-glow), 0 0 20px var(--secondary-glow);
            transition: transform 0.2s;
        }

        #play-btn {
            background-color: var(--duration-bar-color);
            color: var(--bg-color);
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 0 10px var(--duration-bar-color);
        }

        /* --- Timeline (Restylisée) --- */
        #timeline-container {
            position: absolute;
            top: 20%; 
            left: 0;
            width: 100%;
            height: 80%;
            background: #0a0918;
            overflow: auto;
        }

        #timeline {
            position: relative;
            width: 3000px;
            height: 100%;
            /* Grille plus subtile */
            background-image: 
                linear-gradient(rgba(0, 229, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 229, 255, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            border-top: 1px solid var(--border-color);
        }
        
        /* --- Pastilles et Barres --- */
        .pastille {
            position: absolute;
            top: 50%;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            transition: box-shadow 0.2s, background-color 0.2s, left 0.5s ease; /* Ajout transition left pour le tri */
            z-index: 10;
        }

        .duration-bar {
            position: absolute;
            /* NOUVEAU: Fine barre verte sous la pastille, s'étendant à droite */
            left: 50%;
            top: calc(50% + 20px); /* 50% + 15px (moitié pastille) + 5px (marge) */
            transform: translateY(-50%);
            height: 2px; /* Très fin */
            background-color: var(--duration-bar-color);
            border-radius: 1px;
            box-shadow: 0 0 4px var(--duration-bar-color);
            transition: width 0.5s ease-in-out;
            z-index: 9; /* En dessous de la pastille */
        }

        /* --- Repères de Temps (inchangés) --- */
        .time-marker {
            position: absolute;
            width: 1px;
            background: var(--marker-color);
            opacity: 0.7;
            color: var(--marker-color);
            z-index: 1;
        }
        .time-label {
            /* styles labels (inchangés) */
            position: absolute;
            font-size: 8px; 
            display: flex;
            flex-direction: column; 
            align-items: center;
            line-height: 1;
        }
        .marker-top { top: 0; height: 40px; }
        .marker-top .time-label { top: -45px; }

        .marker-bottom { bottom: 0; height: 40px; }
        .marker-bottom .time-label { bottom: -45px; top: unset; }

        .marker-end {
            top: 50%;
            height: 20px;
            transform: translateY(-50%);
        }
        .marker-end .time-label { top: -40px; left: 0; transform: translateX(0); }


        /* --- Éditeur de Temps (#time-editor) - DÉPLAÇABLE (Restylisé) --- */
        #time-editor {
            position: fixed; 
            display: none;
            width: 650px; 
            background-color: var(--widget-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.3);
            z-index: 2000; 
            cursor: move; 
        }
        .editor-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 12px; border-bottom: 1px solid var(--border-color);
            cursor: grab; 
        }
        /* ... (styles fieldset, input-group, input, select, etc. inchangés) ... */

        /* --- Courbe de Bézier (Correction d'Affichage) --- */
        #curve-area {
            flex-basis: 300px;
            height: 300px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            position: relative;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 30px 30px;
            overflow: hidden;
            z-index: 200; 
        }
        /* Le canvas doit être un block et remplir l'espace */
        #curve-canvas {
            display: block; 
            width: 100%;
            height: 100%;
        }
        .curve-control-point {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            cursor: grab;
            z-index: 210; /* Doit être au-dessus du canvas */
            transform: translate(-50%, -50%);
            background-color: var(--secondary-glow);
            box-shadow: 0 0 5px var(--secondary-glow);
        }
        .curve-control-point.start-end {
            background-color: var(--duration-bar-color); 
            box-shadow: 0 0 5px var(--duration-bar-color);
        }
        
        /* --- Card de Prévisualisation (inchangée) --- */
        #preview-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20%;
            height: 40%;
            background-color: var(--widget-bg);
            border: 2px solid var(--primary-glow);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 229, 255, 0.5);
            z-index: 3000; 
            display: none; 
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
    </style>
</head>
<body>

    <div id="top-header">
        <div id="reference-pastille" draggable="true"></div>
        <select id="axis-selector" style="padding: 5px; background: var(--widget-bg); color: var(--text-color); border: 1px solid var(--border-color);">
            <option value="Axe X">Axe X</option>
            <option value="Axe Y">Axe Y</option>
            <option value="Axe Z">Axe Z</option>
            <option value="rotation X">Rotation X</option>
            <option value="rotation Y">Rotation Y</option>
            <option value="rotation Z">Rotation Z</option>
        </select>
        <button id="play-btn">▶ Démarrer Simulation</button>
    </div>

    <div id="timeline-container">
        <div id="timeline"></div>
    </div>

    <div id="preview-card">
        <button id="close-preview-btn">×</button>
        <h3>Simulation d'Animation</h3>
        <div id="preview-object">OBJET</div>
        <span id="current-time-display">00:00:00:000</span>
    </div>

    <div id="time-editor">
        <div class="editor-header">
            <span>Définir l'Animation</span>
            <button id="close-editor-btn">×</button>
        </div>
        <div class="editor-body">
            
            <div id="curve-area">
                <canvas id="curve-canvas"></canvas>
                <div class="curve-control-point start-end" id="p0" data-index="0" style="left: 0%; top: 100%;"></div>
                <div class="curve-control-point" id="p1" data-index="1" style="left: 33%; top: 50%;"></div>
                <div class="curve-control-point" id="p2" data-index="2" style="left: 66%; top: 50%;"></div>
                <div class="curve-control-point start-end" id="p3" data-index="3" style="left: 100%; top: 0%;"></div>
            </div>

            <div class="editor-controls">
                <div class="input-group" style="align-self: center;">
                    <label for="editor-axis-selector" style="width: auto;">Axe :</label>
                    <select id="editor-axis-selector" style="width: 120px;">
                        <option value="Axe X">Axe X</option>
                        <option value="Axe Y">Axe Y</option>
                        <option value="Axe Z">Axe Z</option>
                        <option value="rotation X">Rotation X</option>
                        <option value="rotation Y">Rotation Y</option>
                        <option value="rotation Z">Rotation Z</option>
                    </select>
                </div>
                
                <div class="value-fields">
                    <fieldset>
                        <legend>Valeur Début</legend>
                        <div class="input-group"><label>Val</label><input type="text" id="start-value" value="0"></div>
                    </fieldset>
                    <fieldset>
                        <legend>Valeur Fin</legend>
                        <div class="input-group"><label>Val</label><input type="text" id="end-value" value="100"></div>
                    </fieldset>
                </div>

                <div class="time-fields">
                    <fieldset>
                        <legend>Début (HH:MM:SS:ms)</legend>
                        <div class="input-group"><label for="start-h">HH</label><input type="number" id="start-h" min="0"></div>
                        <div class="input-group"><label for="start-m">MM</label><input type="number" id="start-m" min="0" max="59"></div>
                        <div class="input-group"><label for="start-s">SS</label><input type="number" id="start-s" min="0" max="59"></div>
                        <div class="input-group"><label for="start-ms">ms</label><input type="number" id="start-ms" min="0" max="999"></div>
                    </fieldset>
                    <fieldset>
                        <legend>Fin (HH:MM:SS:ms)</legend>
                        <div class="input-group"><label for="end-h">HH</label><input type="number" id="end-h" min="0"></div>
                        <div class="input-group"><label for="end-m">MM</label><input type="number" id="end-m" min="0" max="59"></div>
                        <div class="input-group"><label for="end-s">SS</label><input type="number" id="end-s" min="0" max="59"></div>
                        <div class="input-group"><label for="end-ms">ms</label><input type="number" id="end-ms" min="0" max="999"></div>
                    </fieldset>
                </div>
            </div>
        </div>
        <div class="editor-footer">
            <button id="ok-editor-btn">OK</button>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const timelineContainer = document.getElementById('timeline-container');
        const timeline = document.getElementById('timeline');
        const referencePastille = document.getElementById('reference-pastille');
        const axisSelector = document.getElementById('axis-selector');
        const timeEditor = document.getElementById('time-editor');
        const editorHeader = timeEditor.querySelector('.editor-header');
        const okEditorBtn = document.getElementById('ok-editor-btn');
        const closeEditorBtn = document.getElementById('close-editor-btn');
        const editorAxisSelector = document.getElementById('editor-axis-selector');
        const startValueInput = document.getElementById('start-value');
        const endValueInput = document.getElementById('end-value');
        let activePastille = null;

        // --- Éléments de Simulation ---
        const playBtn = document.getElementById('play-btn');
        const previewCard = document.getElementById('preview-card');
        const closePreviewBtn = document.getElementById('close-preview-btn');
        const previewObject = document.getElementById('preview-object');
        const currentTimeDisplay = document.getElementById('current-time-display');
        let animationFrame = null;
        let animationStartTime = 0;
        let totalTimelineDuration = 0;
        let currentTimelineTime = 0;
        
        // --- Courbe de Bézier ---
        const curveArea = document.getElementById('curve-area');
        const canvas = document.getElementById('curve-canvas');
        const ctx = canvas.getContext('2d');
        const curvePoints = Array.from(document.querySelectorAll('.curve-control-point'));

        // --- Logique de Déplacement de l'Éditeur (inchangée) ---
        let isDraggingEditor = false;
        let editorOffsetX, editorOffsetY;

        editorHeader.addEventListener('mousedown', (e) => {
            isDraggingEditor = true;
            editorHeader.style.cursor = 'grabbing';
            editorOffsetX = e.clientX - timeEditor.getBoundingClientRect().left;
            editorOffsetY = e.clientY - timeEditor.getBoundingClientRect().top;
            
            document.addEventListener('mousemove', dragEditor);
            document.addEventListener('mouseup', stopDragEditor);
            e.preventDefault(); 
        });

        const dragEditor = (e) => {
            if (!isDraggingEditor) return;
            let newX = e.clientX - editorOffsetX;
            let newY = e.clientY - editorOffsetY;

            newX = Math.max(0, Math.min(newX, window.innerWidth - timeEditor.offsetWidth));
            newY = Math.max(0, Math.min(newY, window.innerHeight - timeEditor.offsetHeight));

            timeEditor.style.left = `${newX}px`;
            timeEditor.style.top = `${newY}px`;
        };

        const stopDragEditor = () => {
            isDraggingEditor = false;
            editorHeader.style.cursor = 'grab';
            document.removeEventListener('mousemove', dragEditor);
            document.removeEventListener('mouseup', stopDragEditor);
        };

        // --- Fonctions Utilitaires (inchangées) ---
        const timeToMilliseconds = (h, m, s, ms) => (parseInt(h||0)*3600+parseInt(m||0)*60+parseInt(s||0))*1000+parseInt(ms||0);
        const millisecondsToTime = (totalMs) => {
            if (isNaN(totalMs) || totalMs < 0) return { h:0,m:0,s:0,ms:0 };
            let r=totalMs; const h=Math.floor(r/3600000); r%=3600000;
            const m=Math.floor(r/60000); r%=60000;
            const s=Math.floor(r/1000); const ms=r%1000;
            return {h,m,s,ms};
        };
        const formatTimeDisplay = (ms) => {
            const t = millisecondsToTime(ms);
            return `${String(t.h).padStart(2,'0')}:${String(t.m).padStart(2,'0')}:${String(t.s).padStart(2,'0')}:${String(t.ms).padStart(3,'0')}`;
        };
        const formatTimeVertical = (ms) => {
            const t = millisecondsToTime(ms);
            return `<div class="time-label">
                <span>${String(t.h).padStart(2,'0')}H</span>
                <span>${String(t.m).padStart(2,'0')}M</span>
                <span>${String(t.s).padStart(2,'0')}S</span>
                <span>${String(t.ms).padStart(3,'0')}ms</span>
            </div>`;
        };
        const getAxisColor = (axis) => {
            switch(axis) {
                case "Axe X": return "var(--color-axex)";
                case "Axe Y": return "var(--color-axey)";
                case "Axe Z": return "var(--color-axez)";
                case "rotation X": return "var(--color-rotx)";
                case "rotation Y": return "var(--color-roty)";
                case "rotation Z": return "var(--color-rotz)";
                default: return "var(--primary-glow)";
            }
        };

        // --- Logique Courbe de Bézier (pour l'éditeur) ---
        const updateCanvasSize = () => {
            canvas.width = curveArea.clientWidth;
            canvas.height = curveArea.clientHeight;
            drawBezierCurve();
        };

        const drawBezierCurve = () => {
            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            const getPointCoords = (index) => {
                const style = curvePoints[index].style;
                const x = parseFloat(style.left) * w / 100;
                // Y est inversé car top 0% = haut (valeur 1 de la courbe)
                const y = h - (parseFloat(style.top) * h / 100); 
                return { x, y };
            };
            
            // Correction: Si l'éditeur est caché, le canvas peut avoir 0px. On utilise les pourcentages directement.
            if (w === 0 || h === 0) return;

            const p0 = getPointCoords(0);
            const p1 = getPointCoords(1);
            const p2 = getPointCoords(2);
            const p3 = getPointCoords(3);

            // Lignes de contrôle (gris transparent)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.lineTo(p1.x, p1.y);
            ctx.moveTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.stroke();
            ctx.setLineDash([]); 

            // Courbe de Bézier (cyan-orangé)
            // NOUVEAU: La courbe doit être visible même si P0 ou P3 est en blanc (vert)
            ctx.strokeStyle = 'var(--secondary-glow)'; // Reste la couleur secondaire
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
            ctx.stroke();
        };

        let draggingCurvePoint = null;
        let startCurveX, startCurveY, startCurveLeft, startCurveTop;

        const startDragCurve = (e) => {
            if (isDraggingEditor) return;
            
            draggingCurvePoint = e.target;
            startCurveX = e.clientX;
            startCurveY = e.clientY;
            startCurveLeft = parseFloat(draggingCurvePoint.style.left);
            startCurveTop = parseFloat(draggingCurvePoint.style.top);

            document.addEventListener('mousemove', dragCurve);
            document.addEventListener('mouseup', stopDragCurve);
            e.preventDefault();
        };

        const dragCurve = (e) => {
            if (!draggingCurvePoint) return;

            const dx = e.clientX - startCurveX;
            const dy = e.clientY - startCurveY;

            const areaW = curveArea.clientWidth;
            const areaH = curveArea.clientHeight;

            let newLeft = startCurveLeft + (dx / areaW) * 100;
            let newTop = startCurveTop + (dy / areaH) * 100;
            const index = parseInt(draggingCurvePoint.dataset.index);

            newLeft = Math.max(0, Math.min(100, newLeft));
            newTop = Math.max(0, Math.min(100, newTop));

            // P1 & P2: X et Y libres
            if (index === 1 || index === 2) {
                draggingCurvePoint.style.left = `${newLeft}%`;
                draggingCurvePoint.style.top = `${newTop}%`;
            } 
            // P0 (Début): X fixé à 0%
            else if (index === 0) {
                draggingCurvePoint.style.left = `0%`; 
                draggingCurvePoint.style.top = `${newTop}%`;
            } 
            // P3 (Fin): X fixé à 100%
            else if (index === 3) {
                draggingCurvePoint.style.left = `100%`; 
                draggingCurvePoint.style.top = `${newTop}%`;
            }

            drawBezierCurve();
        };

        const stopDragCurve = () => {
            if (!draggingCurvePoint) return;

            if (activePastille) {
                const pointIndex = draggingCurvePoint.dataset.index;
                activePastille.dataset[`curveP${pointIndex}Left`] = draggingCurvePoint.style.left;
                activePastille.dataset[`curveP${pointIndex}Top`] = draggingCurvePoint.style.top;
            }

            draggingCurvePoint = null;
            document.removeEventListener('mousemove', dragCurve);
            document.removeEventListener('mouseup', stopDragCurve);
        };

        curvePoints.forEach(p => p.addEventListener('mousedown', startDragCurve));
        window.addEventListener('resize', updateCanvasSize);

        // --- Fonctions Principales ---
        const createPastille = (x, y) => {
            const pastille = document.createElement('div');
            pastille.className = 'pastille';
            pastille.id = `pastille-${Date.now()}`;
            
            // Contrainte de 1% (1% de 3000px = 30px)
            const minX = 30; 
            const finalX = Math.max(minX, x);

            pastille.style.left = `${finalX}px`;
            pastille.style.top = `${y}px`;
            pastille.dataset.startTimeMs = '0';
            pastille.dataset.endTimeMs = '0';
            pastille.dataset.startValue = '0';
            pastille.dataset.endValue = '100';
            pastille.dataset.axis = axisSelector.value;
            pastille.draggable = true;

            // Initialiser les données de courbe par défaut
            pastille.dataset.curveP0Left = '0%'; pastille.dataset.curveP0Top = '100%';
            pastille.dataset.curveP1Left = '33%'; pastille.dataset.curveP1Top = '50%';
            pastille.dataset.curveP2Left = '66%'; pastille.dataset.curveP2Top = '50%';
            pastille.dataset.curveP3Left = '100%'; pastille.dataset.curveP3Top = '0%';
            
            const durationBar = document.createElement('div');
            durationBar.className = 'duration-bar';
            pastille.appendChild(durationBar);
            timeline.appendChild(pastille);

            const initialColor = getAxisColor(pastille.dataset.axis);
            pastille.style.setProperty('background-color', initialColor);
            pastille.style.setProperty('box-shadow', `0 0 8px ${initialColor}, 0 0 15px ${initialColor}`);

            pastille.addEventListener('click', (e) => {
                if (e.detail === 0) return; 
                showTimeEditor(pastille);
            });

            pastille.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', e.target.id);
                e.dataTransfer.effectAllowed = 'move';
                setTimeout(() => e.target.style.opacity = '0.5', 0);
            });
            pastille.addEventListener('dragend', (e) => {
                e.target.style.opacity = '1';
                const currentLeft = parseFloat(e.target.style.left);
                if (currentLeft < minX) {
                     e.target.style.left = `${minX}px`;
                }
                updateAndDrawMarkers(); // Mettre à jour après déplacement
            });
            return pastille;
        };

        const showTimeEditor = (p) => {
            activePastille = p;
            
            // 1. Charger les valeurs de temps et de valeur
            const startTime = millisecondsToTime(parseInt(p.dataset.startTimeMs));
            const endTime = millisecondsToTime(parseInt(p.dataset.endTimeMs));
            
            ['start','end'].forEach(type => {
                const t = type === 'start' ? startTime : endTime;
                Object.keys(t).forEach(unit => {
                    document.getElementById(`${type}-${unit}`).value = t[unit];
                });
            });
            startValueInput.value = p.dataset.startValue;
            endValueInput.value = p.dataset.endValue;

            // 2. Charger l'axe et la courbe
            editorAxisSelector.value = p.dataset.axis;
            curvePoints.forEach((cp, index) => {
                cp.style.left = p.dataset[`curveP${index}Left`];
                cp.style.top = p.dataset[`curveP${index}Top`];
            });
            
            // 3. Afficher et positionner l'éditeur (initialement centré)
            const editorWidth = timeEditor.offsetWidth;
            const editorHeight = timeEditor.offsetHeight;

            timeEditor.style.left = `${(window.innerWidth - editorWidth) / 2}px`;
            timeEditor.style.top = `${(window.innerHeight - editorHeight) / 2}px`;

            timeEditor.style.display = 'block';
            updateCanvasSize(); // Assure que la courbe est dessinée après l'affichage
        };

        const updateAndDrawMarkers = () => {
            document.querySelectorAll('.time-marker').forEach(m => m.remove());

            let pastilles = Array.from(timeline.querySelectorAll('.pastille'))
                .filter(p => parseInt(p.dataset.endTimeMs) >= 0); // Inclure pastilles non configurées
            
            // NOUVEAU: Tri des pastilles par temps de début (ancienne à gauche)
            pastilles.sort((a, b) => {
                const startA = parseInt(a.dataset.startTimeMs);
                const startB = parseInt(b.dataset.startTimeMs);
                return startA - startB;
            });
            
            if (pastilles.length < 1) {
                totalTimelineDuration = 0;
                return;
            }

            let minTime = Infinity, maxTime = -Infinity;
            // Calculer la durée totale basée sur toutes les pastilles configurées
            pastilles.forEach(p => {
                minTime = Math.min(minTime, parseInt(p.dataset.startTimeMs));
                maxTime = Math.max(maxTime, parseInt(p.dataset.endTimeMs));
            });

            // Si aucune pastille n'a de temps de fin valide (toutes à 0), on prend le temps de début min
            if (maxTime <= 0 && pastilles.length > 0) {
                 maxTime = parseInt(pastilles[pastilles.length - 1].dataset.startTimeMs);
            }
            if (maxTime <= 0) maxTime = 1; // Évite la division par zéro si tout est à 0

            totalTimelineDuration = maxTime;

            const totalMs = maxTime; 
            const timelineWidth = timeline.scrollWidth;
            const pixelsPerMs = totalMs > 0 ? timelineWidth / totalMs : 0;
            const minX = 30; // 1% de 3000px

            pastilles.forEach(p => {
                const startMs = parseInt(p.dataset.startTimeMs);
                const endMs = parseInt(p.dataset.endTimeMs);
                const durationMs = endMs - startMs;

                // Position X calculée à partir du temps de début
                const posX = (startMs * pixelsPerMs) + minX; 
                p.style.left = `${posX}px`;
                
                const bar = p.querySelector('.duration-bar');
                if (bar) bar.style.width = `${durationMs * pixelsPerMs}px`;

                // Créer les repères
                createMarker(posX, formatTimeVertical(startMs), 'top');
                createMarker(posX, formatTimeVertical(startMs), 'bottom');
                if (durationMs > 0) {
                    createMarker(posX + (durationMs * pixelsPerMs), formatTimeVertical(endMs), 'end', p.style.top);
                }
            });
        };

        const createMarker = (x, htmlContent, type, y = null) => {
            const marker = document.createElement('div');
            marker.className = `time-marker marker-${type}`;
            marker.style.left = `${x}px`;
            if (y) marker.style.top = y;
            marker.innerHTML = htmlContent;
            timeline.appendChild(marker);
        };

        // --- Logique d'Animation (inchangée) ---

        const getBezierValue = (t, P0_y, P1_y, P2_y, P3_y) => {
            return (1 - t) ** 3 * P0_y +
                   3 * (1 - t) ** 2 * t * P1_y +
                   3 * (1 - t) * t ** 2 * P2_y +
                   t ** 3 * P3_y;
        };

        const applyTransform = (timeMs) => {
            if (totalTimelineDuration === 0) return;
            
            previewObject.style.transform = '';
            
            const pastilles = Array.from(timeline.querySelectorAll('.pastille'))
                .filter(p => parseInt(p.dataset.endTimeMs) > 0);

            pastilles.forEach(p => {
                const startMs = parseInt(p.dataset.startTimeMs);
                const endMs = parseInt(p.dataset.endTimeMs);
                const durationMs = endMs - startMs;

                if (timeMs >= startMs && timeMs <= endMs) {
                    const t_progression = (timeMs - startMs) / durationMs;
                    
                    const P0_y = 1 - (parseFloat(p.dataset.curveP0Top) / 100);
                    const P1_y = 1 - (parseFloat(p.dataset.curveP1Top) / 100);
                    const P2_y = 1 - (parseFloat(p.dataset.curveP2Top) / 100);
                    const P3_y = 1 - (parseFloat(p.dataset.curveP3Top) / 100);
                    
                    const curve_value = getBezierValue(t_progression, P0_y, P1_y, P2_y, P3_y);

                    const startVal = parseFloat(p.dataset.startValue || 0);
                    const endVal = parseFloat(p.dataset.endValue || 0);
                    const final_value = startVal + (endVal - startVal) * curve_value;
                    
                    const axis = p.dataset.axis;
                    let transform = '';

                    if (axis.startsWith('Axe')) {
                        const unit = 'px';
                        if (axis === 'Axe X') transform = `translateX(${final_value}${unit})`;
                        if (axis === 'Axe Y') transform = `translateY(${final_value}${unit})`;
                        if (axis === 'Axe Z') transform = `translateZ(${final_value}${unit})`;
                    } else if (axis.startsWith('rotation')) {
                        const unit = 'deg';
                        if (axis === 'rotation X') transform = `rotateX(${final_value}${unit})`;
                        if (axis === 'rotation Y') transform = `rotateY(${final_value}${unit})`;
                        if (axis === 'rotation Z') transform = `rotateZ(${final_value}${unit})`;
                    }

                    previewObject.style.transform += ' ' + transform;
                }
            });
            previewObject.textContent = Math.floor(currentTimelineTime / 1000) + 's';
        };

        const animateTimeline = (timestamp) => {
            if (!animationStartTime) animationStartTime = timestamp;
            const elapsed = timestamp - animationStartTime;
            
            currentTimelineTime = elapsed % totalTimelineDuration;
            
            currentTimeDisplay.textContent = formatTimeDisplay(currentTimelineTime);
            applyTransform(currentTimelineTime);
            
            animationFrame = requestAnimationFrame(animateTimeline);
        };

        const stopAnimation = () => {
            cancelAnimationFrame(animationFrame);
            animationFrame = null;
            animationStartTime = 0;
            currentTimelineTime = 0;
            previewCard.style.display = 'none';
            previewObject.style.transform = ''; 
            currentTimeDisplay.textContent = formatTimeDisplay(0); 
        };

        // --- Gestionnaires d'Événements (inchangés) ---

        // Drag and Drop Timeline 
        referencePastille.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', e.target.id);
            e.dataTransfer.effectAllowed = 'copy';
        });

        timeline.addEventListener('dragover', (e) => e.preventDefault());
        timeline.addEventListener('drop', (e) => {
            e.preventDefault();
            const id = e.dataTransfer.getData('text/plain');
            const draggedElement = document.getElementById(id);

            const rect = timeline.getBoundingClientRect();
            const x = e.clientX - rect.left + timeline.scrollLeft;
            const y = e.clientY - rect.top + timeline.scrollTop;

            if (draggedElement && draggedElement.id === 'reference-pastille') {
                createPastille(x, y); 
                updateAndDrawMarkers(); // Ajout pour s'assurer qu'une nouvelle pastille est triée
            } else if (draggedElement && draggedElement.classList.contains('pastille')) {
                draggedElement.style.left = `${x}px`;
                draggedElement.style.top = `${y}px`;
            }
        });

        // Boutons de l'éditeur
        okEditorBtn.addEventListener('click', () => {
            if (!activePastille) return;
            const getMs = (type) => timeToMilliseconds(
                document.getElementById(`${type}-h`).value, document.getElementById(`${type}-m`).value,
                document.getElementById(`${type}-s`).value, document.getElementById(`${type}-ms`).value
            );
            
            const newAxis = editorAxisSelector.value;
            activePastille.dataset.startTimeMs = getMs('start');
            activePastille.dataset.endTimeMs = getMs('end');
            activePastille.dataset.axis = newAxis;
            activePastille.dataset.startValue = startValueInput.value;
            activePastille.dataset.endValue = endValueInput.value;
            
            const newColor = getAxisColor(newAxis);
            activePastille.style.setProperty('background-color', newColor);
            activePastille.style.setProperty('box-shadow', `0 0 8px ${newColor}, 0 0 15px ${newColor}`);

            curvePoints.forEach((cp, index) => {
                activePastille.dataset[`curveP${index}Left`] = cp.style.left;
                activePastille.dataset[`curveP${index}Top`] = cp.style.top;
            });
            
            timeEditor.style.display = 'none';
            updateAndDrawMarkers(); // Doit être appelé pour trier après la mise à jour des temps
            activePastille = null;
        });

        closeEditorBtn.addEventListener('click', () => {
            if (activePastille && confirm("Voulez-vous supprimer cette animation ?")) {
                activePastille.remove();
                updateAndDrawMarkers();
                activePastille = null;
            }
            timeEditor.style.display = 'none';
        });

        // Gestionnaires de la Simulation
        playBtn.addEventListener('click', () => {
            if (totalTimelineDuration === 0) {
                alert("Veuillez créer et configurer au moins une pastille d'animation !");
                return;
            }
            previewCard.style.display = 'flex';
            previewObject.style.transform = ''; 
            previewObject.style.transition = 'none'; 
            animationFrame = requestAnimationFrame(animateTimeline);
        });

        closePreviewBtn.addEventListener('click', stopAnimation);

        // Initialisation
        updateCanvasSize();
        updateAndDrawMarkers();
        
    });
    </script>
</body>
</html>
