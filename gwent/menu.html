<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pile de Cartes 3D - Blanc & Gris avec Toggle Bicolore</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
<style>
:root {
    --card-width: 100px;
    --card-height: 140px;
    --z-gap: 1px;
    --bg-green: #bff5bf;
    --bg-blue: #c9e5ff;
    --bg-orange: #ffe5b0;
    --bg-white: #ffffff;
    --bg-darkgrey: #777777;
    --border-dark: #333;
    --counter-bg: #e67e22;
    --text-dark: #333;
}

body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    background: #d3f3d2;
    font-family: 'Fredoka One', cursive, Arial, sans-serif;
    overflow: hidden;
}

.scene {
    perspective: 1000px;
    position: relative;
}

/* ðŸ”¹ Compteur au-dessus de la pile */
.card-counter {
    position: absolute;
    bottom: calc(85% + var(--card-height) / 2 + 30px); 
    left: 75%; 
    transform: translateX(-50%);
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: var(--counter-bg);
    border: 3px solid var(--border-dark);
    color: white;
    font-size: 20px;
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    box-shadow: 0 4px 8px rgba(0,0,0,0.4);
}

/* ðŸ”¹ Pastille toggle bicolore sous la pile */
.toggle-indicator {
    position: absolute;
    top: calc(15% + var(--card-height) / 2 + 10px); 
    left: 75%; 
    transform: translateX(-50%);
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: 5px solid #444;
    display: none; /* cachÃ©e par dÃ©faut */
    cursor: pointer;
    transition: transform 0.2s ease, background 0.3s ease;
    z-index: 500;
}
.toggle-indicator:hover {
    transform: translateX(-50%) scale(1.1);
}

.card-stack {
    position: relative;
    width: var(--card-width);
    height: var(--card-height);
    transform-style: preserve-3d;
    top: 35%; 
    left: 60%; 
    /* Transformation de base. Ajoutez une transition pour les rebonds */
    transition: transform 0.2s ease-out; 
    transform: translate(-50%, -50%) rotateX(10deg);
}

/* ðŸŒŸ NOUVELLES CLASSES POUR L'EFFET DE REBOND DE LA PILE ðŸŒŸ */
.card-stack.bounce-x {
    /* Mouvement lÃ©ger sur l'axe X pour simuler un coup de cÃ´tÃ© */
    transform: translate(calc(-50% + 5px), -50%) rotateX(10deg); 
    transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}
.card-stack.bounce-y {
    /* Mouvement lÃ©ger sur l'axe Y pour simuler un coup de haut en bas */
    transform: translate(-50%, calc(-50% + 5px)) rotateX(10deg); 
    transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}
/* RÃ©initialisation de la transition aprÃ¨s le rebond pour un retour propre */
.card-stack:not(.bounce-x):not(.bounce-y) {
    transition: transform 0.25s ease-out;
}

.card {
    position: absolute;
    width: var(--card-width);
    height: var(--card-height);
    border: 2px solid var(--border-dark);
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    font-size: 30px;
    font-weight: bold;
    color: var(--text-dark);
    cursor: grab;
    user-select: none;
    touch-action: none;
    transition: transform 0.25s ease-out, box-shadow 0.25s ease-out, background-color 0.3s ease;
    box-shadow: 0 3px 4px rgba(0,0,0,0.25);
}
.card .card-count {
    font-size: 16px;
    background: rgba(255,255,255,0.7);
    border-radius: 5px;
    padding: 2px 8px;
    border: 1px solid var(--border-dark);
}

.card.is-dragging {
    box-shadow: 6px 6px 15px rgba(0,0,0,0.5);
}

/* ðŸ’¥ STYLE MIS Ã€ JOUR POUR LE HALO FIN, FLUO ET ESPACÃ‰ ðŸ’¥ */
.card.highlight-halo {
    box-shadow: 
        /* CrÃ©e l'espace : une ombre noire (ou de couleur de fond) sans flou, avec un petit spread */
        0 0 0 5px rgba(0, 0, 0, 0), /* Simule une marge invisible */
        /* DÃ©but du halo fluo */
        0 0 5px 6px currentColor,  /* Lueur intÃ©rieure fine (Spread 6px) */
        0 0 10px 8px currentColor, /* Lueur extÃ©rieure floue et intense (Spread 8px) */
        0 4px 8px rgba(0,0,0,0.4); /* Conserve l'ombre de profondeur */
    /* La couleur est dÃ©finie par JS sur la couleur de fond de la carte (currentColor) */
}


.card.cycle-out {
    z-index: -1;
    transition: transform 0.25s cubic-bezier(0.68,-0.55,0.265,1.55);
    transform: translateZ(-200px) translateY(-100px) scale(0.8);
}
.card.remove-left, .card.remove-right {
    z-index: 100;
    transition: transform 0.3s cubic-bezier(0.68,-0.55,0.265,1.55), opacity 0.3s ease-in;
    opacity: 0; pointer-events: none;
}
.card.remove-left { transform: translateX(-400px) rotateZ(-15deg) translateZ(-50px); }
.card.remove-right { transform: translateX(400px) rotateZ(15deg) translateZ(-50px); }
.card.bounce-back {
    transition: transform 0.5s cubic-bezier(0.68,-0.75,0.265,1.75);
}
</style>
</head>
<body>

<div class="scene">
    <div class="card-counter">0</div>
    <div class="card-stack"></div>
    <div class="toggle-indicator" id="colorToggle"></div>
</div>

<script>
const stackEl = document.querySelector('.card-stack');
const counterEl = document.querySelector('.card-counter');
const toggleEl = document.getElementById('colorToggle');

const COLORS = {
    green: '#bff5bf',
    blue: '#c9e5ff',
    orange: '#ffe5b0',
    white: '#ffffff',
    darkgrey: '#777777'
};

const CARD_COUNT = 12;
const Z_GAP = 1;
const SWIPE_THRESHOLD = 80;

let topCard = null;
let isDragging = false;
let startX = 0, startY = 0, currentX = 0, currentY = 0;
let currentToggleColor = null;
let togglePair = null; // { left, right }

function randomColorGroup(i) {
    const groups = ['green','blue','orange','white','darkgrey'];
    return groups[i % groups.length];
}

function initializeStack() {
    stackEl.innerHTML = '';
    for (let i = 0; i < CARD_COUNT; i++) {
        const group = randomColorGroup(i);
        const card = document.createElement('div');
        card.className = 'card';
        card.dataset.group = group;
        card.style.backgroundColor = COLORS[group];
        card.innerHTML = `
            <div class="card-icon">${group === 'orange' ? 'ðŸ”¥' : group === 'blue' ? 'ðŸ’§' : group === 'green' ? 'ðŸŒ¿' : group === 'darkgrey' ? 'â¬›' : 'âšª'}</div>
            <div class="card-count">${group}</div>
        `;
        stackEl.appendChild(card);
    }
    updateTopCardReference();
    updateCardIndices();
    updateCounter();
}

function updateTopCardReference() {
    if (topCard) {
        topCard.removeEventListener('mousedown', startDrag);
        topCard.removeEventListener('touchstart', startDrag);
        topCard.classList.remove('highlight-halo'); 
    }
    topCard = stackEl.firstElementChild;
    if (!topCard) return;

    if (topCard.dataset.group !== 'white' && topCard.dataset.group !== 'darkgrey') {
        topCard.removeAttribute('data-is-toggled');
    }

    topCard.addEventListener('mousedown', startDrag);
    topCard.addEventListener('touchstart', startDrag);

    if (topCard.dataset.group === 'white') {
        currentToggleColor = null; 
        togglePair = { left: 'green', right: 'blue' };
        showToggle();
    } else if (topCard.dataset.group === 'darkgrey') {
        currentToggleColor = null; 
        togglePair = { left: 'green', right: 'orange' };
        showToggle();
    } else {
        toggleEl.style.display = 'none';
        togglePair = null;
    }
}

function showToggle() {
    toggleEl.style.display = 'flex';
    toggleEl.style.background = `linear-gradient(90deg, ${COLORS[togglePair.left]} 50%, ${COLORS[togglePair.right]} 50%)`;
}

function updateCounter() {
    counterEl.textContent = stackEl.children.length;
}

function updateCardIndices() {
    const cards = Array.from(stackEl.children);
    cards.forEach((card, index) => {
        const zPos = -index * Z_GAP;
        card.style.transform = `translateZ(${zPos}px)`;
        card.style.color = 'var(--text-dark)'; 
    });
}

function bounceStack(axis = 'x') {
    const className = `bounce-${axis}`;
    stackEl.classList.add(className);
    
    setTimeout(() => {
        stackEl.classList.remove(className);
        stackEl.style.transform = 'translate(-50%, -50%) rotateX(10deg)'; 
    }, 250); 
}

function startDrag(e) {
    if (!topCard || isDragging) return;
    isDragging = true;
    const client = e.touches ? e.touches[0] : e;
    startX = client.clientX;
    startY = client.clientY;
    topCard.classList.add('is-dragging');
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchmove', drag, { passive: false });
    document.addEventListener('touchend', endDrag);
}

function drag(e) {
    if (!isDragging) return;
    const client = e.touches ? e.touches[0] : e;
    currentX = client.clientX - startX;
    currentY = client.clientY - startY;
    const rotation = currentX / 20;
    
    const cards = Array.from(stackEl.children);

    cards.forEach((card, index) => {
        const zPos = -index * Z_GAP;
        const scaleFactor = Math.pow(0.5, index);
        const translateX = currentX * scaleFactor;
        const translateY = currentY * scaleFactor;
        const rotateZ = rotation * scaleFactor * 0.3; 

        card.style.transform = `translateX(${translateX}px) translateY(${translateY}px) rotateZ(${rotateZ}deg) translateZ(${zPos}px)`;
    });

    const absX = Math.abs(currentX);
    const absY = Math.abs(currentY);
    const cardGroup = topCard.dataset.group;
    const isSpecialCard = cardGroup === 'white' || cardGroup === 'darkgrey';
    const isToggledToNewColor = isSpecialCard && topCard.dataset.isToggled === 'true';

    const isPotentialRemoval = absX > SWIPE_THRESHOLD && absX > absY && (!isSpecialCard || isToggledToNewColor);

    if (isPotentialRemoval) {
        // DÃ©finit currentColor = backgroundColor pour que le halo utilise la bonne teinte
        topCard.style.color = topCard.style.backgroundColor;
        topCard.classList.add('highlight-halo');
    } else {
        topCard.classList.remove('highlight-halo');
        topCard.style.color = 'var(--text-dark)'; 
    }

    if (e.cancelable) e.preventDefault();
}

function endDrag() {
    if (!isDragging) return;
    isDragging = false;
    topCard.classList.remove('is-dragging');
    topCard.classList.remove('highlight-halo'); 
    topCard.style.color = 'var(--text-dark)'; 
    
    const absX = Math.abs(currentX);
    const absY = Math.abs(currentY);
    const cardGroup = topCard.dataset.group;

    const isSpecialCard = cardGroup === 'white' || cardGroup === 'darkgrey';
    const isToggledToNewColor = isSpecialCard && topCard.dataset.isToggled === 'true'; 

    let actionTaken = false;

    if (absX > SWIPE_THRESHOLD && absX > absY) {
        // DÃ©tection de glissement horizontal (gauche/droite)
        if (isSpecialCard && !isToggledToNewColor) { 
            handleCycle(true); // Rebond X
            actionTaken = true;
        } else {
            handleRemoval(currentX > 0 ? 'right' : 'left');
            actionTaken = true;
        }
    } else if (absY > SWIPE_THRESHOLD && absY > absX) {
        // DÃ©tection de glissement vertical (haut/bas)
        handleCycle(false, true); // Rebond Y
        actionTaken = true;
    }

    if (!actionTaken) {
        // Rebond si la carte est relÃ¢chÃ©e dans la zone morte
        if (absX > absY) bounceStack('x');
        else bounceStack('y');
        handleReset();
    }

    document.removeEventListener('mousemove', drag);
    document.removeEventListener('mouseup', endDrag);
    document.removeEventListener('touchmove', drag);
    document.removeEventListener('touchend', endDrag);
}

function handleReset() {
    currentX = currentY = 0;
    updateCardIndices(); 
}

function handleCycle(bounceX = false, bounceY = false) {
    topCard.style.transform = `translateZ(0px)`;
    topCard.classList.remove('highlight-halo'); 
    topCard.style.color = 'var(--text-dark)'; 
    topCard.classList.add('cycle-out');

    if (bounceX) bounceStack('x');
    if (bounceY) bounceStack('y');
    
    setTimeout(() => {
        topCard.classList.remove('cycle-out');
        stackEl.removeChild(topCard);
        
        if (topCard.dataset.group === 'white' || topCard.dataset.group === 'darkgrey') {
            topCard.style.backgroundColor = COLORS[topCard.dataset.group];
            topCard.innerHTML = `<div class="card-icon">${topCard.dataset.group === 'white' ? 'âšª' : 'â¬›'}</div><div class="card-count">${topCard.dataset.group}</div>`;
            topCard.removeAttribute('data-is-toggled'); 
        }
        
        stackEl.appendChild(topCard);
        updateCardIndices();
        updateTopCardReference();
    }, 250);
}

function handleRemoval(direction) {
    topCard.classList.remove('highlight-halo'); 
    topCard.style.color = 'var(--text-dark)'; 

    topCard.classList.add(`remove-${direction}`);
    
    // LÃ©ger rebond opposÃ© Ã  la direction de la suppression
    if (direction === 'left') bounceStack('x');
    else bounceStack('x');

    setTimeout(() => {
        stackEl.removeChild(topCard);
        updateCardIndices();
        updateCounter();
        updateTopCardReference();
        if (stackEl.children.length === 0) setTimeout(initializeStack, 500);
    }, 300);
}

// ðŸ”¹ Clique sur pastille => change la teinte
toggleEl.addEventListener('click', () => {
    if (!topCard || !togglePair) return;

    currentToggleColor = (currentToggleColor === togglePair.left) ? togglePair.right : togglePair.left;
    const chosenColor = COLORS[currentToggleColor];
    const chosenText = `teinte: ${currentToggleColor}`;
    const icon = currentToggleColor === 'green' ? 'ðŸŒ¿' :
                 currentToggleColor === 'blue' ? 'ðŸ’§' : 'ðŸ”¥';
    
    topCard.style.backgroundColor = chosenColor;
    topCard.innerHTML = `
        <div class="card-icon">${icon}</div>
        <div class="card-count">${chosenText}</div>
    `;
    
    topCard.dataset.isToggled = 'true'; 
});

document.addEventListener('DOMContentLoaded', initializeStack);
</script>

</body>
</html>
