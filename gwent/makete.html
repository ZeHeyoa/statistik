<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gwent CSS3D Demo - Menu 100% CSS & Mobile Pan Y</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        /* ======================================================= */
        /* === STYLES DU PLATEAU 3D (makete.html) === */
        /* ======================================================= */

        /* CONSTANTES DE COULEURS POUR LES LIGNES */
        .C_MELEE_COLOR { background-color: #A8E61D; color: #333; } 
        .C_RANGE_COLOR { background-color: #FFD700; color: #333; } 
        .C_SIEGE_COLOR { background-color: #B0E0E6; color: #333; } 

        /* BASE & BACKGROUND */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #AEEA9C; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* FIX: Suppression de perspective: 1000px; */
            touch-action: none; 
        }

        /* PROGRESS BAR HUD */
        .progress-bar-hud {
            display:none;
            position: fixed;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px; 
            z-index: 1000;
        }

        .progress-bar {
            width: 100%; 
            height: 4px; 
            background: rgba(120, 0, 255, 0.3);
            border-radius: 4px; 
        }
        .progress-fill {
            height: 50%;
            background: #00ffff;
            border-radius: 4px;
            transition: height 1s ease;
        }

        /* ======================================================= */
        /* === CONTENEUR DE D√âFILEMENT (HUD Principal) === */
        /* ======================================================= */
        /* Conteneur pour Joueur B (Top-Left) */
        #scroll-hud-container {
            position: fixed;
            top: 0;
            left: 0; 
            width: 25%; 
            height: auto; /* Adapt√© au contenu de B */
            z-index: 1100;
            overflow-y: auto; 
            overflow-x: hidden;
            pointer-events: all; 
            padding-right: 10px; 
            display: flex; 
            flex-direction: column;
        }
        
        /* NOUVEAU CONTENEUR POUR LE HUD DU JOUEUR A (Bottom-Right) */
        #player-a-hud-container {
            position: fixed;
            top: unset; 
            bottom: 0; 
            right: 0; 
            width: 25%; 
            height: auto; 
            z-index: 1100;
            pointer-events: all; 
            display: flex; 
            flex-direction: column;
            align-items: flex-end; /* Align the content to the right */
        }
        
        /* NOUVEAUX √âL√âMENTS DE SCORE HUD (A et B) */
        .score-hud-container {
            display: flex;
            flex-direction: column; 
            align-items: flex-start; /* Alignment par d√©faut pour Player B (Left) */
            font-family: 'Fredoka One', cursive, Arial, sans-serif;
            min-height: auto; 
            padding: 10px 0 10px 10px; 
            box-sizing: border-box;
            gap: 15px; 
            width: 100%; /* S'assurer qu'il prend toute la largeur du conteneur parent */
        }
        
        /* Style pour le conteneur de score sur la droite (Player A) */
        #player-a-hud-container .score-hud-container {
            padding: 10px 10px 10px 0; /* Padding √† droite */
            align-items: flex-end; /* Alignement √† droite des scores A */
        }

        /* Conteneur pour Joueur A (Score + Menu) - Aligne horizontalement */
        #player-a-group {
            display: flex; 
            align-items: flex-end; 
            gap: 15px; 
        }
        
        /* Inverser l'ordre des √©l√©ments pour l'affichage Player A (Total √† droite, Lignes √† gauche) */
        #player-a-hud-container #player-a-group {
            flex-direction: row-reverse; 
            align-items: flex-end; 
            gap: 15px; 
        }

        .score-total {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #111;
            color: #DDDDDD; 
            font-size: 36px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0; 
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5), 0 0 10px rgba(255, 255, 255, 0.5); 
            border: 2px solid #555;
            transition: all 0.5s ease;
        }

        .line-scores {
            display: flex;
            flex-direction: column; 
            align-items: center; 
            transition: transform 0.5s ease;
        }
        
        /* Aligner les scores de ligne du joueur A √† droite */
        #player-a-hud-container .line-scores {
            align-items: flex-end;
        }

        .line-score {
            width: 50px;
            height: 50px;
            border-radius: 8px; 
            font-size: 20px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 4px 0; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4), 0 0 5px rgba(255, 255, 255, 0.3);
            color: #333; 
            border: 2px solid #333;
            transition: all 0.5s ease;
        }

        /* CARTES PLATEAU (Style align√© aux .line-score) */
        .card.A, .card.B { 
            width: 350px;
            height: 400px; 
            border: 2px solid #333; 
            border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4), 0 0 5px rgba(255, 255, 255, 0.3); 
            display: flex;
            flex-direction: column;
            justify-content: space-between; 
            align-items: center;
            font-size: 40px; 
            font-weight: bold;
            text-shadow: none;
            cursor: pointer;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            position: relative;
            overflow: hidden;
            transition: opacity 0.3s ease;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
        }

        .card-power {
            font-size: 60px;
            line-height: 1;
            margin-bottom: 5px;
            z-index: 2;
        }

        .card-type-label {
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
            z-index: 2;
        }

        .card.melee { background-color: #A8E61D; } 
        .card.range { background-color: #FFD700; } 
        .card.siege { background-color: #B0E0E6; } 

        .card.melee .card-power, .card.range .card-power, .card.siege .card-power {
            color: #333; 
            text-shadow: 1px 1px 0 rgba(255,255,255,0.3);
        }

        .card.off-board {
            opacity: 0.2;
            filter: grayscale(80%);
            border-color: #333333;
            box-shadow: none;
        }

        .board-area {
            background: #AEEA9C; 
            overflow: auto;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.1); 
            opacity: 1;
        }

        /* ======================================================= */
        /* === STYLES DE LA PILE (Menu 100% CSS) === */
        /* ======================================================= */
        :root {
            --card-width-menu: 120px;
            --card-height-menu: 200px;
            --z-gap: 1px;
            --bg-green: #bff5bf;
            --bg-blue: #c9e5ff;
            --bg-orange: #ffe5b0;
            --bg-white: #ffffff;
            --bg-darkgrey: #777777;
            --border-dark: #333;
            --counter-bg: #e67e22;
            --text-dark: #333;
        }

        /* FIX: Centrage parfait en bas de l'√©cran */
        .scene-menu { 
            width: var(--card-width-menu);     
            height: var(--card-height-menu);    
            pointer-events: all; 
            
            position: fixed;            /* Doit √™tre fix√© au viewport */
            left: 50%;                  /* D√©part au centre horizontal */
            bottom: 20px;               /* Position √† 20px du bas */
            transform: translateX(-50%); /* D√©calage pour centrer la bo√Æte */
            
            perspective: 500px; 
            z-index: 1200; 
            margin-top: 0; /* Suppression de la r√®gle inutile */
        }
        /* ======================================================= */

        /* Pastille compteur */
        .card-counter {
            position: absolute;
            bottom: 78%; 
            left: 43%; 
            transform: translateX(-50%);
            width: 39.5px; 
            height: 39.5px; 
            border-radius: 50%;
            background-color: var(--counter-bg);
            border: 1px solid var(--border-dark); 
            color: white;
            font-size: 13px; 
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            pointer-events: none; 
        }

        /* Pastille toggle */
        .toggle-indicator {
            position: absolute;
            top: 25%; 
            left: 123%; 
            transform: translateX(-50%);
            width: 26px; 
            height: 26px; 
            border-radius: 50%;
            border: 2.6px solid #444; 
            display: none; 
            cursor: pointer;
            transition: transform 0.2s ease, background 0.3s ease;
            z-index: 500;
        }
        .toggle-indicator:hover {
            transform: translateX(-50%) scale(1.1);
        }

        .card-stack {
            position: absolute; 
            width: var(--card-width-menu);
            height: var(--card-height-menu);
            transform-style: preserve-3d;
            /* FIX: Centr√© dans .scene-menu */
            top: 50%; 
            left: 50%; 
            transition: transform 0.2s ease-out; 
            transform: translate(-50%, -50%); 
        }

        .card-stack.bounce-x {
            transform: translate(calc(-50% + 5px), -50%); 
            transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .card-stack.bounce-y {
            transform: translate(-50%, calc(-50% + 5px)); 
            transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .card-stack:not(.bounce-x):not(.bounce-y) {
            transition: transform 0.25s ease-out;
        }

        .card.menu-card {
            position: absolute;
            width: var(--card-width-menu);
            height: var(--card-height-menu);
            border: 2px solid var(--border-dark);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            font-size: 30px;
            font-weight: bold;
            color: var(--text-dark);
            cursor: grab;
            user-select: none;
            touch-action: none;
            /* La transition est g√©r√©e par JS pendant le drag, puis r√©initialis√©e ici apr√®s */
            transition: transform 0.25s ease-out, box-shadow 0.25s ease-out, background-color 0.3s ease;
            box-shadow: 0 3px 4px rgba(0,0,0,0.25);
            font-family: 'Fredoka One', cursive, Arial, sans-serif;

            /* Styles pour la manipulation (drag) */
            will-change: transform, left, top; 
        }

        /* NOUVEAU: Style pour la carte temporairement d√©tach√©e */
        .card.menu-card.detached {
            position: fixed; 
            top: 0;
            left: 0;
            transform-style: flat !important; 
            transform: none !important; 
            z-index: 99999; 
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: none; /* D√©sactiver les transitions pendant le drag */
        }
        /* FIN NOUVEAU */

        .card.menu-card .card-count {
            font-size: 16px;
            background: rgba(255,255,255,0.7);
            border-radius: 5px;
            padding: 2px 8px;
            border: 1px solid var(--border-dark);
        }

        .card.menu-card.is-dragging {
            cursor: grabbing;
        }
        .card.menu-card.highlight-halo {
            box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.8), 0 3px 4px rgba(0,0,0,0.25);
        }

        .card.menu-card.cycle-out {
            transform: translateX(-150%) translateY(0) rotateZ(-30deg) !important;
            opacity: 0;
            transition: transform 0.3s ease-in, opacity 0.3s ease-in;
        }
        .card.menu-card.remove-right {
            transform: translateX(300px) translateY(0) rotateZ(30deg) !important;
            opacity: 0;
            transition: transform 0.3s ease-in, opacity 0.3s ease-in;
        }
        .card.menu-card.remove-left {
            transform: translateX(-300px) translateY(0) rotateZ(-30deg) !important;
            opacity: 0;
            transition: transform 0.3s ease-in, opacity 0.3s ease-in;
        }
        
        /* NOUVEAU: Style pour le retrait vers le haut */
        .card.menu-card.remove-up {
            transform: translateY(-300px) translateX(0) rotateZ(0deg) !important; 
            opacity: 0;
            transition: transform 0.3s ease-in, opacity 0.3s ease-in;
        }
        /* FIN NOUVEAU */

        /* ------------------------------------------- */
        /* === Suppression des effets de survol magn√©tiques === */
        /* ------------------------------------------- */
        
        /* La logique de suivi des cartes est maintenant g√©r√©e par le JS `dragMenu` */
        
        /* ======================================================= */
        /* === RESPONSIVE STYLES (Mobile < 768px) === */
        /* ======================================================= */
        @media (max-width: 768px) {
            /* Score HUD Adjustments - General */
            .score-hud-container {
                padding: 5px 0 5px 5px; 
                gap: 10px; 
                width: 100%; 
            }
            #player-a-group {
                gap: 5px; 
            }
            .score-total {
                width: 55px;
                height: 55px;
                font-size: 24px;
                margin: 5px 0;
            }
            .line-score {
                width: 35px;
                height: 35px;
                font-size: 14px;
                margin: 2px 0;
            }

            /* Adjustments for Player A HUD (Right side) on mobile */
            #player-a-hud-container {
                width: 30%; 
            }
            #player-a-hud-container .score-hud-container {
                padding: 5px 5px 5px 0; /* Align content to the right edge */
            }

            /* Menu & Pile Adjustments (taille mobile) */
            .scene-menu {
                width: 80px;     
                height: 135px;
                /* Centrage d√©j√† g√©r√© par les r√®gles principales */
            }
            .card-stack {
                width: 80px; 
                height: 135px; 
            }
            .card.menu-card {
                width: 80px; 
                height: 135px;
                padding: 5px; 
                font-size: 20px;
            }
            .card.menu-card .card-count {
                font-size: 12px;
                padding: 1px 4px;
            }
            .card-counter {
                width: 40px; 
                height: 40px; 
                font-size: 10px;
                bottom: -10%; 
                left: -0%;
            }
            .toggle-indicator {
                width: 35px; 
                height: 35px; 
                border-width: 2px;
            top: 80%; 
            left: 120%
            }
        }
    
/* ======================================================= */
/* === MODE PAYSAGE : ADAPTATION MOBILE VS GRAND √âCRAN === */
/* ======================================================= */

/* 1Ô∏è‚É£ Landscape sur petits √©crans (mobiles/tablettes) */
@media screen and (orientation: landscape) and (max-width: 900px) {
  .scene-menu {
    width: 60px;
    height: 100px;
    bottom: -5%;
  }

  .card.menu-card {
    width: 60px;
    height: 100px;
    font-size: 16px;
  }

  .score-total {
    width: 50px;
    height: 50px;
    font-size: 20px;
  }

  .line-score {
    width: 30px;
    height: 30px;
    font-size: 12px;
  }

  #scroll-hud-container,
  #player-a-hud-container {
    width: 20%;
  }
    
               .card-counter {
                width: 35px; 
                height: 35px; 
                font-size: 10px;
                bottom: 25%; 
                left: -45%;
            }
            .toggle-indicator {
                width: 30px; 
                height: 30px; 
                border-width: 2px;
            top: 40%; 
            left: 90%
            }
    
}

/* 2Ô∏è‚É£ Landscape sur grands √©crans (PC, tablettes larges) */
@media screen and (orientation: landscape) and (min-width: 901px) {
  .scene-menu {
    width: var(--card-width-menu);
    height: var(--card-height-menu);
    bottom: 20px;
  }

  .card.menu-card {
    width: var(--card-width-menu);
    height: var(--card-height-menu);
    font-size: 30px;
  }

  .score-total {
    width: 80px;
    height: 80px;
    font-size: 36px;
  }

  .line-score {
    width: 50px;
    height: 50px;
    font-size: 20px;
  }

  #scroll-hud-container,
  #player-a-hud-container {
    width: 25%;
  }
}

</style>
</head>
<body>
    

    <div id="scroll-hud-container"> 
        <div class="score-hud-container">
            <div class="top-left">
                <div class="score-total" id="scoreTotalB">0</div>
                <div class="line-scores">  
               <div class="line-score C_SIEGE_COLOR" id="scoreSiegeB">0</div>
                      
                     <div class="line-score C_RANGE_COLOR" id="scoreRangeB">0</div>
                    <div class="line-score C_MELEE_COLOR" id="scoreMeleeB">0</div> 
                      
                </div>
            </div>
            </div>
    </div>

    <div id="player-a-hud-container">
        <div class="score-hud-container">
            <div id="player-a-group"> 
                <div class="bottom-left">
                      <div class="line-scores">
                        <div class="line-score C_MELEE_COLOR" id="scoreMeleeA">0</div>
                        <div class="line-score C_RANGE_COLOR" id="scoreRangeA">0</div>
                        <div class="line-score C_SIEGE_COLOR" id="scoreSiegeA">0</div>
                    </div>
                    <div class="score-total" id="scoreTotalA">0</div>
                  
                </div>
            </div>
        </div>
    </div>

    <div class="scene-menu" id="menu-fixed">
        <div class="card-counter">0</div>
        <div class="card-stack"></div>
        <div class="toggle-indicator" id="colorToggle"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script>
        /* ======================================================= */
        /* === LOGIQUE THREE.JS (Plateau 3D) === */
        /* ======================================================= */
        const cardWidth = 350; 
        const cardHeight = 400; 
        const halfCardHeight = cardHeight / 2;
        const gap = 1; 
        const PLATEAU_Z = 0;

        const CARD_SPACING = 20; 
        const ROW_SPACING = cardHeight + 40; 

        const VERTICAL_OFFSET_10_PERCENT = cardHeight * 0.1;

        const CARD_PLACEMENT_SAFE_FACTOR = 0.8;

        let fixedPlacementRange = 0; 
        const initialPlacementCenter = 0; 

        // NOUVELLES VARIABLES POUR LA LARGEUR ADAPTATIVE
        let minXBoundary = 0;
        let maxXBoundary = 0;
        const BOARD_X_MARGIN = 400; 
        let boardWidth = 1000; 

        let scene, camera, renderer;
        let boardGroup, progressBar3D, boardArea, scoreFillA, boardBorder;
        let a_cards = [];
        let b_cards = [];

        let scoreA = 0;
        let scoreB = 0;
        let scoreA_melee = 0;
        let scoreA_range = 0;
        let scoreA_siege = 0;
        let scoreB_melee = 0;
        let scoreB_range = 0;
        let scoreB_siege = 0;

        let a_card_positions = [];
        let b_card_positions = [];

        let currentBarY = 0; 

        const cardTypes = ['melee', 'range', 'siege'];

        const BOARD_TOTAL_HEIGHT = 12000; 

        const bottomY = -BOARD_TOTAL_HEIGHT / 2; 
        const topY = BOARD_TOTAL_HEIGHT / 2;     
        const margin = 100; 

        const defaultCameraDistance = 2000; 
        const minCameraDistance = 1000;
        const maxCameraDistance = 3000;
        let cameraDistance = defaultCameraDistance * 1.2; 

        const FOUNDATION_COLOR_LIGHT = '#444444'; 
        const SCORE_FILL_COLOR_A = 'rgba(0, 0, 0, 0.2)'; 

        const ENTRY_OFFSET = 2000; 
        const STACK_FACTOR = 0.5;            

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let panFactor = 1; 
        let initialPinchDistance = null;

        function getVisibleSceneWidth() {
            const distance = camera.position.z;
            const vFOV = camera.fov * Math.PI / 180;
            const viewHeight = 2 * Math.tan(vFOV / 2) * distance;
            const aspectRatio = camera.aspect;
            const viewWidth = viewHeight * aspectRatio;
            return viewWidth;
        }

        function updateBoardDimensions(newBoardWidth, newBoardCenterX, animate = true) {
            if (newBoardWidth < 1000) newBoardWidth = 1000; 

            boardWidth = newBoardWidth;
            const duration = animate ? 1 : 0;

            // D√©place le groupe entier pour centrer le contenu du plateau (newBoardCenterX) √† l'√©cran (X=0)
            gsap.to(boardGroup.position, { x: -newBoardCenterX, duration: duration, ease: "power2.out" });

            // Met √† jour la largeur des √©l√©ments 2D du plateau
            const elementsToResize = [boardBorder.element.style, boardArea.element.style, progressBar3D.element.style, scoreFillA.element.style];

            elementsToResize.forEach(style => {
                gsap.to(style, { width: `${boardWidth}px`, duration: duration, ease: "power2.out" });
            });
        }


        function init() {
            scene = new THREE.Scene();
            currentBarY = 0; 

            camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 0, cameraDistance); 
            camera.lookAt(0, 0, 0); 

            renderer = new THREE.CSS3DRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = 0;

            renderer.domElement.style.touchAction = 'none'; 
            renderer.domElement.style.zIndex = '1';

            document.body.appendChild(renderer.domElement);

            boardGroup = new THREE.Group();
            scene.add(boardGroup);

            // Initialisation de la largeur bas√©e sur la vue
            boardWidth = getVisibleSceneWidth() * 1.5; 

            // Construction du plateau 3D
            const borderDiv = document.createElement('div');
            borderDiv.className = 'border-area';
            borderDiv.style.width = `${boardWidth}px`;
            borderDiv.style.height = `${BOARD_TOTAL_HEIGHT}px`;
            borderDiv.style.backgroundColor = 'transparent'; 
            boardBorder = new THREE.CSS3DObject(borderDiv);
            boardBorder.position.set(0, -500, -50); 
            boardGroup.add(boardBorder);

            const areaDiv = document.createElement('div');
            areaDiv.className = 'board-area';
            areaDiv.style.width = `${boardWidth}px`;
            areaDiv.style.height = `${BOARD_TOTAL_HEIGHT}px`;
            boardArea = new THREE.CSS3DObject(areaDiv);
            boardArea.position.set(0, 0, -45); 
            boardGroup.add(boardArea);

            const scoreFillDivA = document.createElement('div');
            scoreFillDivA.className = 'score-fill-A';
            scoreFillDivA.style.width = `${boardWidth}px`;
            scoreFillDivA.style.backgroundColor = SCORE_FILL_COLOR_A;
            scoreFillDivA.style.boxShadow = `none`; 
            scoreFillDivA.style.opacity = '0'; 
            scoreFillA = new THREE.CSS3DObject(scoreFillDivA);
            scoreFillA.position.set(0, 0, -40); 
            boardGroup.add(scoreFillA);

            const barDiv = document.createElement('div');
            barDiv.style.width = `${boardWidth}px`;
            barDiv.style.height = '22px'; 
            barDiv.style.background = `linear-gradient(90deg, #333333, #666666, #333333)`; 
            barDiv.style.borderRadius = '16px';
            barDiv.style.boxShadow = `0 0 60px ${FOUNDATION_COLOR_LIGHT}, inset 0 0 20px rgba(255,255,255,0.1)`;
            barDiv.style.opacity = '0'; 
            progressBar3D = new THREE.CSS3DObject(barDiv);
            progressBar3D.position.set(0, 0, 20); 
            boardGroup.add(progressBar3D);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            const initialViewWidth = getVisibleSceneWidth();
            fixedPlacementRange = initialViewWidth * CARD_PLACEMENT_SAFE_FACTOR;

            renderer.domElement.addEventListener('mousedown', handleMouseDown, false);
            renderer.domElement.addEventListener('mousemove', handleMouseMove, false);
            window.addEventListener('mouseup', handleMouseUp, false); 
            renderer.domElement.addEventListener('touchstart', handleTouchStartPan, false);
            renderer.domElement.addEventListener('touchmove', handleTouchMovePan, false);
            renderer.domElement.addEventListener('touchend', handleTouchEndPan, false);
            window.addEventListener('wheel', handleMouseWheel, { passive: false });
            window.addEventListener('touchstart', handleTouchStartPinch, { passive: false });
            window.addEventListener('touchmove', handleTouchMovePinch, { passive: false });
            window.addEventListener('touchend', handleTouchEndPinch, { passive: false });

            updatePanFactor(); 
            updateBar(currentBarY, false);

            initializeMenu(); 

            animate();
            startGame();
        }

        function updatePanFactor() {
            const vFOV = camera.fov * Math.PI / 180;
            const height = 2 * Math.tan(vFOV / 2) * camera.position.z;
            panFactor = height / window.innerHeight;
        }

        function panCamera(deltaX, deltaY) {
            camera.position.x -= deltaX * panFactor;
            camera.position.y += deltaY * panFactor;
            camera.lookAt(camera.position.x, camera.position.y, 0);
        }

        function handleMouseDown(event) {
            if (event.button === 0 && !isDraggingMenu) { 
                isDragging = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
                event.preventDefault(); 
            }
        }

        function handleMouseMove(event) {
            if (!isDragging || isDraggingMenu) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            panCamera(deltaX, deltaY); 

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function handleMouseUp() {
            isDragging = false;
        }

        function handleTouchStartPan(event) {
            // S'assure que le menu ne g√®re pas le pan 3D
            if (event.touches.length === 1 && !isDraggingMenu) {
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
                event.stopPropagation();
            }
        }

        // FIX: Permet le d√©placement sur l'axe Y sur mobile seulement
        function handleTouchMovePan(event) {
            if (isDragging && event.touches.length === 1 && !isDraggingMenu) {
                event.preventDefault();
                event.stopPropagation(); 

                const deltaX = event.touches[0].clientX - previousMousePosition.x;
                const deltaY = event.touches[0].clientY - previousMousePosition.y;

                // Pan Y seulement (deltaX est ignor√© pour la cam√©ra)
                panCamera(deltaX, deltaY); 

                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function handleTouchEndPan(event) { 
            if (event.touches.length === 0) {
                 isDragging = false;
            }
        }

        function handleMouseWheel(event) {
            event.preventDefault(); 
            const zoomSpeed = 200; 
            const zoomAmount = event.deltaY > 0 ? zoomSpeed : -zoomSpeed;
            updateCameraDistance(camera.position.z + zoomAmount);
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function handleTouchStartPinch(event) {
            if (event.touches.length === 2 && !isDraggingMenu) {
                initialPinchDistance = getPinchDistance(event.touches);
            }
            isDragging = false; 
        }

        function handleTouchMovePinch(event) {
            if (event.touches.length === 2 && !isDraggingMenu) {
                event.preventDefault(); 
                const currentPinchDistance = getPinchDistance(event.touches);

                if (initialPinchDistance) {
                    const delta = currentPinchDistance - initialPinchDistance;
                    const zoomFactor = -delta * 5; 
                    updateCameraDistance(camera.position.z + zoomFactor);
                    initialPinchDistance = currentPinchDistance; 
                }
            }
        }

        function handleTouchEndPinch(event) {
            initialPinchDistance = null;
            if (event.touches.length === 1 && !isDraggingMenu) {
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function updateCameraDistance(newZ) {
            const clampedZ = Math.max(minCameraDistance, Math.min(maxCameraDistance, newZ));
            camera.position.z = clampedZ;
            cameraDistance = clampedZ; 
            updatePanFactor();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function createCard(player) {
            const power = Math.floor(Math.random() * 10) + 1;
            const type = cardTypes[Math.floor(Math.random() * cardTypes.length)];

            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${player} ${type}`; 

            let typeLabel;
            switch(type) {
                case 'melee': typeLabel = 'M√™l√©e'; break;
                case 'range': typeLabel = 'Distance'; break;
                case 'siege': typeLabel = 'Si√®ge'; break;
                default: typeLabel = '';
            }

            cardDiv.innerHTML = `
                <div class="card-type-label">${typeLabel}</div>
                <div class="card-power">${power}</div>
            `;
            cardDiv.style.transform = 'translateZ(10px)'; 
            cardDiv.style.opacity = '0';

            const cardObj = new THREE.CSS3DObject(cardDiv);
            cardObj.position.set(0, 0, PLATEAU_Z);
            cardObj.scale.set(0.1, 0.1, 0.1);

            return { obj: cardObj, power, type, element: cardDiv };
        }

        function getNextAvailableX(teamPositions) {
            const CARD_FULL_WIDTH = cardWidth + CARD_SPACING;
            const maxCardsPerRow = Math.floor(fixedPlacementRange / CARD_FULL_WIDTH);
            if (maxCardsPerRow < 1) return initialPlacementCenter; 

            const cardIndex = teamPositions.length; 

            const rowCardIndex = cardIndex % maxCardsPerRow; 

            let newX;
            if (rowCardIndex === 0) {
                newX = initialPlacementCenter;
            } else {
                const offsetMultiplier = Math.ceil(rowCardIndex / 2); 
                const direction = (rowCardIndex % 2 !== 0) ? 1 : -1; 

                newX = initialPlacementCenter + (direction * offsetMultiplier * CARD_FULL_WIDTH);
            }

            return newX;
        }

        function updateCardsVerticalPositions(barY) {
            const cardTargets = [];

            const CARD_FULL_WIDTH = cardWidth + CARD_SPACING;
            const maxCardsPerRow = Math.floor(fixedPlacementRange / CARD_FULL_WIDTH);
            if (maxCardsPerRow < 1) return []; 

            const halfCardHeightWithGap = halfCardHeight + gap;

            // --- Joueur A (descend √† partir de la barre) ---
            let base_Y_A = barY - halfCardHeightWithGap;
            a_cards.forEach((card, i) => {
                const row = Math.floor(i / maxCardsPerRow); 
                const rowCardIndex = i % maxCardsPerRow;    

                const baseTargetY = base_Y_A - (row * ROW_SPACING); 

                const offset = rowCardIndex * VERTICAL_OFFSET_10_PERCENT; 
                const targetY = baseTargetY - offset; 

                const isOnBoard = targetY - halfCardHeight > bottomY;

                cardTargets.push({ card: card.obj.position, y: targetY });

                card.obj.position.x = a_card_positions[i];
                card.obj.position.z = PLATEAU_Z + i * 5; 
                card.element.classList[isOnBoard ? 'remove' : 'add']('off-board');
            });

            // --- Joueur B (monte √† partir de la barre) ---
            let base_Y_B = barY + halfCardHeightWithGap;
            b_cards.forEach((card, i) => {
                const row = Math.floor(i / maxCardsPerRow); 
                const rowCardIndex = i % maxCardsPerRow;    

                const baseTargetY = base_Y_B + (row * ROW_SPACING);

                const offset = rowCardIndex * VERTICAL_OFFSET_10_PERCENT; 
                const targetY = baseTargetY + offset;

                const isOnBoard = targetY + halfCardHeight < topY;

                cardTargets.push({ card: card.obj.position, y: targetY });

                card.obj.position.x = b_card_positions[i];
                card.obj.position.z = PLATEAU_Z + i * 5;
                card.element.classList[isOnBoard ? 'remove' : 'add']('off-board');
            });

            return cardTargets;
        }

        function updateBar(barY, animate = true) {
            currentBarY = barY;

            const duration = animate ? 1 : 0;

            gsap.to(progressBar3D.position, { y: barY, duration: duration, ease: "power2.out" });


            const heightA = barY - bottomY;
            const centerA = bottomY + (heightA / 2); 

            gsap.to(scoreFillA.element.style, { height: `${heightA}px`, duration: duration, ease: "power2.out" });
            gsap.to(scoreFillA.position, { y: centerA, duration: duration, ease: "power2.out" });

            if (animate || heightA > 0) {
                gsap.to(scoreFillA.element.style, { opacity: 1, duration: 0.5 }, 0); 
            } else {
                gsap.to(scoreFillA.element.style, { opacity: 0, duration: 0.5 });
            }

            const total = scoreA + scoreB || 1;
            const progressPercent = (scoreA / total) * 100;
            gsap.to('#progressFill', { height: `${progressPercent}%`, duration: 1 });

            document.getElementById('scoreTotalA').textContent = scoreA;
            document.getElementById('scoreMeleeA').textContent = scoreA_melee;
            document.getElementById('scoreRangeA').textContent = scoreA_range;
            document.getElementById('scoreSiegeA').textContent = scoreA_siege;

            document.getElementById('scoreTotalB').textContent = scoreB;
            document.getElementById('scoreMeleeB').textContent = scoreB_melee;
            document.getElementById('scoreRangeB').textContent = scoreB_range;
            document.getElementById('scoreSiegeB').textContent = scoreB_siege;
        }

        async function addTurn(turn) {

            const isPlayerA = turn % 2 === 0;
            const player = isPlayerA ? 'A' : 'B';
            const newCard = createCard(player);
            const teamPositions = isPlayerA ? a_card_positions : b_card_positions;

            const newX = getNextAvailableX(teamPositions);

            if (isPlayerA) {
                a_card_positions.push(newX);
                a_cards.push(newCard);
                scoreA += newCard.power;
                if (newCard.type === 'melee') scoreA_melee += newCard.power;
                else if (newCard.type === 'range') scoreA_range += newCard.power;
                else if (newCard.type === 'siege') scoreA_siege += newCard.power;
            } else {
                b_card_positions.push(newX);
                b_cards.push(newCard);
                scoreB += newCard.power;
                if (newCard.type === 'melee') scoreB_melee += newCard.power;
                else if (newCard.type === 'range') scoreB_range += newCard.power;
                else if (newCard.type === 'siege') scoreB_siege += newCard.power;
            }

            // LOGIQUE DE DIMENSIONNEMENT ADAPTATIF
            const cardLeft = newX - cardWidth / 2;
            const cardRight = newX + cardWidth / 2;

            const currentMinX = minXBoundary;
            const currentMaxX = maxXBoundary;

            minXBoundary = Math.min(currentMinX, cardLeft);
            maxXBoundary = Math.max(currentMaxX, cardRight);

            const requiredWidth = maxXBoundary - minXBoundary + BOARD_X_MARGIN * 2;

            if (requiredWidth > boardWidth + 10) { 
                const newBoardCenterX = (minXBoundary + maxXBoundary) / 2;
                updateBoardDimensions(requiredWidth, newBoardCenterX, true);
            }
            // FIN LOGIQUE DE DIMENSIONNEMENT ADAPTATIF

            const total = scoreA + scoreB;
            const newBarY = bottomY + (scoreA / total) * BOARD_TOTAL_HEIGHT; 

            const entryY = isPlayerA ? newBarY - ENTRY_OFFSET : newBarY + ENTRY_OFFSET;

            const newCardIndex = (isPlayerA ? a_cards.length : b_cards.length) - 1;
            newCard.obj.position.set(newX, entryY, PLATEAU_Z + newCardIndex * 5); 

            boardGroup.add(newCard.obj);

            const cardTargets = updateCardsVerticalPositions(newBarY); 

            const mainTimeline = gsap.timeline();
            const cardDuration = 1.2; 
            const barDuration = 1;
            const oldCardsStartTime = 0.1; 

            if (turn === 1) {
                const overflowBarY = topY; 
                updateBar(overflowBarY, false); 
                currentBarY = overflowBarY;     
                progressBar3D.element.style.opacity = '1';
                scoreFillA.element.style.opacity = '1';
            }

            updateBar(newBarY, true); 

            const newCardTarget = cardTargets.find(t => t.card === newCard.obj.position);
            mainTimeline.to(newCard.obj.position, { y: newCardTarget.y, duration: cardDuration, ease: "power2.out" }, 0); 

            mainTimeline.fromTo(newCard.obj.scale, 
                { x: 0.1, y: 0.1, z: 0.1 },
                { x: 1, y: 1, z: 1, duration: cardDuration, ease: "back.out(1.7)" }, 0
            );
            mainTimeline.to(newCard.element, { opacity: 1, duration: 0.8 }, 0.4);

            const oldCardTargets = cardTargets.filter(t => t.card !== newCard.obj.position);

            oldCardTargets.forEach(target => {
                 mainTimeline.to(target.card, { y: target.y, duration: barDuration, ease: "power2.out"}, oldCardsStartTime);
            });

            await new Promise(resolve => mainTimeline.eventCallback("onComplete", resolve));
            await new Promise(resolve => setTimeout(resolve, 200)); 
        }

        async function startGame() {
            const firstCard = createCard('A');
            const firstX = getNextAvailableX([]); 
            a_card_positions.push(firstX);
            firstCard.obj.scale.set(0.1, 0.1, 0.1);
            firstCard.element.style.opacity = '0';
            a_cards.push(firstCard);

            scoreA += firstCard.power;
            if (firstCard.type === 'melee') scoreA_melee += firstCard.power;
            else if (firstCard.type === 'range') scoreA_range += firstCard.power;
            else if (firstCard.type === 'siege') scoreA_siege += firstCard.power;

            // D√âFINITION INITIALE DES LIMITES DU PLATEAU
            const cardLeft = firstX - cardWidth / 2;
            const cardRight = firstX + cardWidth / 2;
            minXBoundary = cardLeft;
            maxXBoundary = cardRight;
            const initialWidth = maxXBoundary - minXBoundary + BOARD_X_MARGIN * 2;
            const initialCenter = (minXBoundary + maxXBoundary) / 2;

            updateBoardDimensions(initialWidth, initialCenter, false);

            const initialBarY = topY; 
            const entryY = initialBarY - ENTRY_OFFSET; 

            firstCard.obj.position.set(firstX, entryY, PLATEAU_Z);
            boardGroup.add(firstCard.obj);

            const cardTargets = updateCardsVerticalPositions(initialBarY);
            const firstCardTarget = cardTargets.find(t => t.card === firstCard.obj.position);

            const initialTimeline = gsap.timeline();
            const initialDuration = 1.2;

            updateBar(initialBarY, true);

            firstCard.obj.position.y = entryY; 

            initialTimeline.to(firstCard.obj.position, { y: firstCardTarget.y, duration: initialDuration, ease: "power2.out" }, 0);

            initialTimeline.fromTo(firstCard.obj.scale, 
                { x: 0.1, y: 0.1, z: 0.1 },
                { x: 1, y: 1, z: 1, duration: initialDuration, ease: "back.out(1.7)" }, 0
            );
            initialTimeline.to(firstCard.element, { opacity: 1, duration: 0.8 }, 0.4);

            await new Promise(resolve => initialTimeline.eventCallback("onComplete", resolve));
            await new Promise(resolve => setTimeout(resolve, 1000));

            for (let turn = 1; turn < 120; turn++) {
                await addTurn(turn);
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Redimensionnement de la zone de placement
            const newViewWidth = getVisibleSceneWidth();
            fixedPlacementRange = newViewWidth * CARD_PLACEMENT_SAFE_FACTOR;

            // Mise √† jour de la largeur et du centrage (sans animation sur resize)
            const requiredWidth = maxXBoundary - minXBoundary + BOARD_X_MARGIN * 2;
            const newBoardCenterX = (minXBoundary + maxXBoundary) / 2;
            updateBoardDimensions(requiredWidth, newBoardCenterX, false); 

            updateBar(currentBarY, false);
            updateCardsVerticalPositions(currentBarY);

            updatePanFactor();
        });

        /* ======================================================= */
        /* === LOGIQUE DE PILE (Menu 100% CSS) === */
        /* ======================================================= */
        const stackEl = document.querySelector('.card-stack');
        const counterEl = document.querySelector('.card-counter');
        const toggleEl = document.getElementById('colorToggle');

        const COLORS = {
            green: '#bff5bf',
            blue: '#c9e5ff',
            orange: '#ffe5b0',
            white: '#ffffff',
            darkgrey: '#777777'
        };

        const CARD_COUNT_MENU = 12; 
        const Z_GAP = 1;
        const SWIPE_THRESHOLD = 80;

        let topCard = null;
        let isDraggingMenu = false; 
        let startX = 0, startY = 0; 
        let initialCardRect = null; 
        let currentToggleColor = null; 
        let togglePair = null;

        function randomColorGroup(i) {
            const groups = ['green','blue','orange','white','darkgrey'];
            return groups[i % groups.length];
        }

        function initializeMenu() {
            stackEl.innerHTML = '';
            for (let i = 0; i < CARD_COUNT_MENU; i++) {
                const group = randomColorGroup(i);
                const card = document.createElement('div');
                card.className = 'card menu-card'; 
                card.dataset.group = group;
                card.style.backgroundColor = COLORS[group];
                card.innerHTML = `
                    <div class="card-icon">${group === 'orange' ? 'üî•' : group === 'blue' ? 'üíß' : group === 'green' ? 'üåø' : group === 'darkgrey' ? '‚¨õ' : '‚ö™'}</div>
                    <div class="card-count">${group}</div>
                `;
                stackEl.appendChild(card);
            }
            updateTopCardReference();
            updateCardIndices();
            updateCounter();
        }

        function updateTopCardReference() {
            if (topCard) {
                topCard.removeEventListener('mousedown', startDragMenu);
                topCard.removeEventListener('touchstart', startDragMenu);
                topCard.classList.remove('highlight-halo'); 
            }
            topCard = stackEl.firstElementChild;
            if (!topCard) {
                 toggleEl.style.display = 'none';
                 return;
            }

            if (topCard.dataset.group !== 'white' && topCard.dataset.group !== 'darkgrey') {
                topCard.removeAttribute('data-is-toggled');
            }

            topCard.addEventListener('mousedown', startDragMenu);
            topCard.addEventListener('touchstart', startDragMenu);

            if (topCard.dataset.group === 'white') {
                currentToggleColor = null; 
                togglePair = { left: 'green', right: 'blue' };
                showToggle();
            } else if (topCard.dataset.group === 'darkgrey') {
                currentToggleColor = null; 
                togglePair = { left: 'green', right: 'orange' };
                showToggle();
            } else {
                toggleEl.style.display = 'none';
                togglePair = null;
            }
        }

        function showToggle() {
            toggleEl.style.display = 'flex';
            toggleEl.style.background = `linear-gradient(90deg, ${COLORS[togglePair.left]} 50%, ${COLORS[togglePair.right]} 50%)`;
        }

        function updateCounter() {
            counterEl.textContent = stackEl.children.length;
        }

        function updateCardIndices() {
            const cards = Array.from(stackEl.children);
            cards.forEach((card, index) => {
                const zPos = -index * Z_GAP;
                // R√©initialise la transformation apr√®s un drag (enl√®ve les X/Y/RotateZ de l'effet magn√©tique)
                card.style.transform = `translateZ(${zPos}px)`; 
                card.style.color = 'var(--text-dark)'; 
                // R√©initialise la transition √† la vitesse normale apr√®s un drag rapide
                card.style.transition = 'transform 0.25s ease-out, box-shadow 0.25s ease-out, background-color 0.3s ease';
            });
        }

        function bounceStack(axis = 'x') {
            const className = `bounce-${axis}`;
            stackEl.classList.add(className);

            setTimeout(() => {
                stackEl.classList.remove(className);
                stackEl.style.transform = 'translate(-50%, -50%)';
            }, 250); 
        }

        function startDragMenu(e) {
            if (!topCard || isDraggingMenu) return;
            isDraggingMenu = true;
            const client = e.touches ? e.touches[0] : e;
            startX = client.clientX;
            startY = client.clientY;

            // R√©cup√©rer la position et d√©tacher
            initialCardRect = topCard.getBoundingClientRect();
            topCard.style.left = `${initialCardRect.left}px`;
            topCard.style.top = `${initialCardRect.top}px`;

            stackEl.removeChild(topCard);
            document.body.appendChild(topCard);
            topCard.classList.add('is-dragging', 'detached');
            
            document.addEventListener('mousemove', dragMenu);
            document.addEventListener('mouseup', endDragMenu);
            document.addEventListener('touchmove', dragMenu, { passive: false });
            document.addEventListener('touchend', endDragMenu);
        }

        function dragMenu(e) {
            if (!isDraggingMenu) return;
            const client = e.touches ? e.touches[0] : e;
            const currentX = client.clientX - startX;
            const currentY = client.clientY - startY;
            const rotation = currentX / 20;

            // 1. Mettre √† jour la position de la carte d√©tach√©e (Top Card)
            topCard.style.left = `${initialCardRect.left + currentX}px`;
            topCard.style.top = `${initialCardRect.top + currentY}px`;
            topCard.style.transform = `rotateZ(${rotation * 0.3}deg)`;

            const absX = Math.abs(currentX);
            const absY = Math.abs(currentY);
            const cardGroup = topCard.dataset.group;
            const isSpecialCard = cardGroup === 'white' || cardGroup === 'darkgrey';
            const isToggledToNewColor = isSpecialCard && topCard.dataset.isToggled === 'true';

            // Mise en surbrillance si un retrait est possible (Glissement vers le haut)
            const isPotentialRemoval = absY > SWIPE_THRESHOLD && currentY < 0 && absY >= absX && (!isSpecialCard || isToggledToNewColor);

            if (isPotentialRemoval) {
                topCard.style.color = topCard.style.backgroundColor;
                topCard.classList.add('highlight-halo');
            } else {
                topCard.classList.remove('highlight-halo');
                topCard.style.color = 'var(--text-dark)'; 
            }
            
            // 2. NOUVEAU: Effet Aimant√© pour les cartes suivantes
            const followerCards = Array.from(stackEl.children);
            const baseDrag = { x: currentX, y: currentY };

            followerCards.forEach((card, index) => {
                // index 0 est la 2e carte de la pile d'origine
                const maxFollowFactor = 0.4;
                const decayRate = 0.1;
                // Calcul du facteur de suivi : 0.4, 0.3, 0.2, 0.1, 0.05, 0.05...
                let followFactor = maxFollowFactor - (index * decayRate); 
                if (followFactor <= 0) {
                    followFactor = 0.05; 
                }

                // Applique 30% du d√©placement de la carte du dessus, multipli√© par le facteur de d√©croissance
                const offsetX = baseDrag.x * followFactor * 0.3; 
                const offsetY = baseDrag.y * followFactor * 0.3; 
                
                // Petite rotation en fonction du d√©calage X
                const offsetRotationZ = baseDrag.x * followFactor * 0.005; 

                // Re-calcul de la position Z (elle est bas√©e sur l'index actuel dans stackEl)
                const baseZ = -index * Z_GAP;

                // Application de la transformation combin√©e (X/Y/RotateZ de l'effet magn√©tique + Z de la pile)
                card.style.transform = `translateX(${offsetX}px) translateY(${offsetY}px) translateZ(${baseZ}px) rotateZ(${offsetRotationZ}deg)`;
                
                // Transition tr√®s rapide pendant le drag pour un effet r√©actif mais non instantan√©
                card.style.transition = 'transform 0.05s linear'; 
            });
            // ----------------------------------------------------

            if (e.cancelable) e.preventDefault();
        }

        function endDragMenu() {
            if (!isDraggingMenu) return;
            isDraggingMenu = false;

            const currentX = topCard.getBoundingClientRect().left - initialCardRect.left;
            const currentY = topCard.getBoundingClientRect().top - initialCardRect.top;

            topCard.classList.remove('is-dragging', 'detached');
            topCard.classList.remove('highlight-halo'); 
            topCard.style.color = 'var(--text-dark)'; 

            // R√©int√©gration de la carte dans la pile pour l'animation de fin
            document.body.removeChild(topCard);
            stackEl.insertBefore(topCard, stackEl.firstChild);

            // Appliquer la translation de fin de drag pour que l'animation de retour fonctionne
            const zPos = 0;
            topCard.style.left = '';
            topCard.style.top = '';
            topCard.style.transform = `translateX(${currentX}px) translateY(${currentY}px) translateZ(${zPos}px)`;
            // R√©tablir la transition pour l'animation de retour
            topCard.style.transition = 'transform 0.25s ease-out, box-shadow 0.25s ease-out, background-color 0.3s ease';

            const absX = Math.abs(currentX);
            const absY = Math.abs(currentY);
            const cardGroup = topCard.dataset.group;

            const isSpecialCard = cardGroup === 'white' || cardGroup === 'darkgrey';
            const isToggledToNewColor = isSpecialCard && topCard.dataset.isToggled === 'true'; 

            let actionTaken = false;

            // NOUVELLE LOGIQUE : Seul le glissement vers le haut (currentY n√©gatif) retire la carte
            // Condition : glissement vertical suffisant ET vers le haut ET principalement vertical
            if (absY > SWIPE_THRESHOLD && currentY < 0 && absY >= absX) {
                // Les cartes sp√©ciales non "toggled" cyclent sur un glissement
                if (isSpecialCard && !isToggledToNewColor) {
                    handleCycle(false, true); // Cycle avec rebond Y
                    actionTaken = true;
                } else {
                    // Les cartes normales ou toggled sont retir√©es
                    handleRemoval('up');
                    actionTaken = true;
                }
            } 
            
            // Tous les autres cas (Down, Left, Right, ou pas assez loin) deviennent un cycle
            if (!actionTaken) {
                let bounceX = absX > SWIPE_THRESHOLD && absX > absY;
                let bounceY = absY > SWIPE_THRESHOLD && absY >= absX;
                
                // Si aucun glissement majeur, on fait un bounce selon la plus grande translation pour un meilleur feedback
                if (!bounceX && !bounceY && (absX > 0 || absY > 0)) {
                    if (absX > absY) bounceX = true;
                    else bounceY = true;
                }
                
                handleCycle(bounceX, bounceY);
            }

            document.removeEventListener('mousemove', dragMenu);
            document.removeEventListener('mouseup', endDragMenu);
            document.removeEventListener('touchmove', dragMenu);
            document.removeEventListener('touchend', endDragMenu);
        }

        function handleReset() {
            updateCardIndices(); // R√©initialise les transform et les transitions
        }

        function handleCycle(bounceX = false, bounceY = false) {
            // R√©initialise d'abord la position manuelle forc√©e par le drag
            topCard.style.transform = `translateZ(0px)`;
            topCard.classList.remove('highlight-halo'); 
            topCard.style.color = 'var(--text-dark)'; 
            topCard.classList.add('cycle-out');

            if (bounceX) bounceStack('x');
            if (bounceY) bounceStack('y');

            setTimeout(() => {
                topCard.classList.remove('cycle-out');
                stackEl.removeChild(topCard);

                if (topCard.dataset.group === 'white' || topCard.dataset.group === 'darkgrey') {
                    topCard.style.backgroundColor = COLORS[topCard.dataset.group];
                    topCard.innerHTML = `<div class="card-icon">${topCard.dataset.group === 'white' ? '‚ö™' : '‚¨õ'}</div><div class="card-count">${topCard.dataset.group}</div>`;
                    topCard.removeAttribute('data-is-toggled'); 
                }

                // IMPORTANT: R√©initialiser le transform apr√®s l'animation "cycle-out" avant l'insertion
                topCard.style.transform = ''; 

                stackEl.appendChild(topCard);
                updateCardIndices();
                updateTopCardReference();
            }, 250);
        }

        function handleRemoval(direction) {
            topCard.classList.remove('highlight-halo'); 
            topCard.style.color = 'var(--text-dark)'; 

            // Utilise 'remove-up' si la direction est 'up', sinon utilise l'ancienne logique pour 'left'/'right'
            const removeClass = direction === 'up' ? 'remove-up' : `remove-${direction}`;
            topCard.classList.add(removeClass);

            // Rebondit sur l'axe Y pour un retrait vertical, X pour horizontal
            const bounceAxis = direction === 'up' ? 'y' : 'x'; 
            bounceStack(bounceAxis);

            setTimeout(() => {
                stackEl.removeChild(topCard);
                updateCardIndices();
                updateCounter();
                updateTopCardReference();
                if (stackEl.children.length === 0) setTimeout(initializeMenu, 500);
            }, 300);
        }

        toggleEl.addEventListener('click', () => {
            if (!topCard || !togglePair) return;

            currentToggleColor = (currentToggleColor === togglePair.left) ? togglePair.right : togglePair.left;
            const chosenColor = COLORS[currentToggleColor];
            const chosenText = `teinte: ${currentToggleColor}`;
            const icon = currentToggleColor === 'green' ? 'üåø' :
                         currentToggleColor === 'blue' ? 'üíß' : 'üî•';

            topCard.style.backgroundColor = chosenColor;
            topCard.innerHTML = `
                <div class="card-icon">${icon}</div>
                <div class="card-count">${chosenText}</div>
            `;

            topCard.dataset.isToggled = 'true'; 
        });


        // Lancement de l'initialisation de Three.js
        window.addEventListener('load', init); 
    </script>
</body>
</html>
