<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gwent CSS3D Demo - Fusion avec Pile de Cartes</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        /* ======================================================= */
        /* === STYLES DU PLATEAU 3D (makete.html) === */
        /* ======================================================= */

        /* CONSTANTES DE COULEURS POUR LES LIGNES */
        .C_MELEE_COLOR { background-color: #A8E61D; color: #333; } 
        .C_RANGE_COLOR { background-color: #FFD700; color: #333; } 
        .C_SIEGE_COLOR { background-color: #B0E0E6; color: #333; } 

        /* BASE & BACKGROUND */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #C7D8C2; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            perspective: 1000px;
            touch-action: none; 
        }

        /* PROGRESS BAR HUD */
        .progress-bar-hud {
            position: fixed;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px; 
            z-index: 1000;
        }

        .progress-bar {
            width: 100%; 
            height: 4px; 
            background: rgba(120, 0, 255, 0.3);
            border-radius: 4px; 
        }
        .progress-fill {
            height: 50%;
            background: #00ffff;
            border-radius: 4px;
            transition: height 1s ease;
        }

        /* NOUVEAUX ÉLÉMENTS DE SCORE HUD (A et B) */
        .score-hud-container {
            position: fixed;
            z-index: 1100; 
            right: 0; 
            display: flex;
            flex-direction: column; 
            align-items: flex-end; 
            font-family: 'Fredoka One', cursive, Arial, sans-serif;
            height: 100vh; 
            justify-content: space-between; 
            padding: 15px 15px; 
            box-sizing: border-box;
        }

        /* Joueur B - Haut Droite */
        .top-right {
            /* Gardé vide, car 'right: 0' est dans le parent */
        }

        /* Joueur A - Bas Droite */
        .bottom-right {
            /* Gardé vide */
        }

        .score-total {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #111;
            color: #DDDDDD; 
            font-size: 36px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0; 
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5), 0 0 10px rgba(255, 255, 255, 0.5); 
            border: 2px solid #555;
            transition: all 0.5s ease;
        }

        .line-scores {
            display: flex;
            flex-direction: column; 
            align-items: center; 
            /* Rétablissement des styles initiaux */
            transition: transform 0.5s ease;
        }

        /* Rétablissement des styles initiaux */
        .top-right .line-scores {
            /* Pas de transformation (annule le -10vh) */ 
        }

        /* Rétablissement des styles initiaux */
        .bottom-right .line-scores {
            order: 1; 
            /* Pas de transformation (annule le -10vh) */
        }

        .line-score {
            width: 50px;
            height: 50px;
            border-radius: 8px; 
            font-size: 20px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 4px 0; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4), 0 0 5px rgba(255, 255, 255, 0.3);
            color: #333; 
            border: 2px solid #333;
            transition: all 0.5s ease;
        }

        /* Inversion de l'ordre pour le joueur A (Bas Droite) */
        .bottom-right .score-total {
            order: 2;
        }

        /* CARTES PLATEAU (inchangé) */
        .card.A, .card.B { 
            width: 150px;
            height: 180px; 
            border: 2px solid rgba(0,0,0,0.5); 
            border-radius: 10px; 
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3); 
            display: flex;
            flex-direction: column;
            justify-content: space-between; 
            align-items: center;
            font-size: 40px; 
            font-weight: bold;
            text-shadow: none;
            cursor: pointer;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            position: relative;
            overflow: hidden;
            transition: opacity 0.3s ease;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
        }

        .card.A:hover, .card.B:hover {
            transform: translateZ(15px);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 2px 2px 4px rgba(0,0,0,0.3);
            z-index: 10;
        }
        .card-power {
            font-size: 60px;
            line-height: 1;
            margin-bottom: 5px;
            z-index: 2;
        }

        .card-type-label {
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
            z-index: 2;
        }
        .card.melee { background-color: #A8E61D; } 
        .card.range { background-color: #FFD700; } 
        .card.siege { background-color: #B0E0E6; } 

        .card.melee .card-power, .card.range .card-power, .card.siege .card-power {
            color: #333; 
            text-shadow: 1px 1px 0 rgba(255,255,255,0.3);
        }

        .card.off-board {
            opacity: 0.2;
            filter: grayscale(80%);
            border-color: #333333;
            box-shadow: none;
        }

        .board-area {
            background: #AEEA9C; 
            overflow: auto;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.1); 
            opacity: 1;
        }

        /* ======================================================= */
        /* === STYLES DE LA PILE (menu.html) - TAILLE ET PASTILLES AJUSTÉES === */
        /* ======================================================= */
        :root {
            --card-width-menu: 100px;
            --card-height-menu: 140px;
            --z-gap: 1px;
            --bg-green: #bff5bf;
            --bg-blue: #c9e5ff;
            --bg-orange: #ffe5b0;
            --bg-white: #ffffff;
            --bg-darkgrey: #777777;
            --border-dark: #333;
            --counter-bg: #e67e22;
            --text-dark: #333;
        }

        /* Le conteneur 3D est réduit (50%) */
        .scene-menu { 
            position: absolute; 
            width: 100px;     
            height: 150px;    
            pointer-events: none; 
        }

        .scene-menu > * {
            pointer-events: auto; 
        }

        /* Pastille compteur (15px * 1.3 = 19.5px, 10px * 1.3 = 13px) */
        .card-counter {
            position: absolute;
            bottom: 50%; 
            left: 55%; 
            transform: translateX(-50%);
            width: 19.5px; 
            height: 19.5px; 
            border-radius: 50%;
            background-color: var(--counter-bg);
            border: 1px solid var(--border-dark); 
            color: white;
            font-size: 13px; 
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }

        /* Pastille toggle (20px * 1.3 = 26px, 2px * 1.3 = 2.6px) */
        .toggle-indicator {
            position: absolute;
            top: 65%; 
            left: 55%; 
            transform: translateX(-50%);
            width: 26px; 
            height: 26px; 
            border-radius: 50%;
            border: 2.6px solid #444; 
            display: none; 
            cursor: pointer;
            transition: transform 0.2s ease, background 0.3s ease;
            z-index: 500;
        }
        .toggle-indicator:hover {
            transform: translateX(-50%) scale(1.1);
        }

        .card-stack {
            position: absolute; 
            width: var(--card-width-menu);
            height: var(--card-height-menu);
            transform-style: preserve-3d;
            top: 50%; 
            left: 50%; 
            transition: transform 0.2s ease-out; 
            transform: translate(-50%, -50%) rotateX(10deg);
        }
        .card-stack.bounce-x {
            transform: translate(calc(-50% + 5px), -50%) rotateX(10deg); 
            transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .card-stack.bounce-y {
            transform: translate(-50%, calc(-50% + 5px)) rotateX(10deg); 
            transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .card-stack:not(.bounce-x):not(.bounce-y) {
            transition: transform 0.25s ease-out;
        }

        .card.menu-card {
            position: absolute;
            width: var(--card-width-menu);
            height: var(--card-height-menu);
            border: 2px solid var(--border-dark);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            font-size: 30px;
            font-weight: bold;
            color: var(--text-dark);
            cursor: grab;
            user-select: none;
            touch-action: none;
            transition: transform 0.25s ease-out, box-shadow 0.25s ease-out, background-color 0.3s ease;
            box-shadow: 0 3px 4px rgba(0,0,0,0.25);
            font-family: 'Fredoka One', cursive, Arial, sans-serif;
        }
        .card.menu-card .card-count {
            font-size: 16px;
            background: rgba(255,255,255,0.7);
            border-radius: 5px;
            padding: 2px 8px;
            border: 1px solid var(--border-dark);
        }

        .card.menu-card.is-dragging {
            box-shadow: 6px 6px 15px rgba(0,0,0,0.5);
        }
        .card.menu-card.highlight-halo {
            box-shadow: 
                0 0 0 5px rgba(0, 0, 0, 0), 
                0 0 5px 6px currentColor,  
                0 0 10px 8px currentColor, 
                0 4px 8px rgba(0,0,0,0.4); 
        }

        .card.menu-card.cycle-out {
            z-index: -1;
            transition: transform 0.25s cubic-bezier(0.68,-0.55,0.265,1.55);
            transform: translateZ(-200px) translateY(-100px) scale(0.8);
        }
        .card.menu-card.remove-left, .card.menu-card.remove-right {
            z-index: 100;
            transition: transform 0.3s cubic-bezier(0.68,-0.55,0.265,1.55), opacity 0.3s ease-in;
            opacity: 0; pointer-events: none;
        }
        .card.menu-card.remove-left { transform: translateX(-400px) rotateZ(-15deg) translateZ(-50px); }
        .card.menu-card.remove-right { transform: translateX(400px) rotateZ(15deg) translateZ(-50px); }
    </style>
</head>
<body>
    <div class="progress-bar-hud">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>

    <div class="score-hud-container">

        <div class="top-right">
            <div class="score-total" id="scoreTotalB">0</div>
            <div class="line-scores">
                <div class="line-score C_MELEE_COLOR" id="scoreMeleeB">0</div> 
                <div class="line-score C_RANGE_COLOR" id="scoreRangeB">0</div>
                <div class="line-score C_SIEGE_COLOR" id="scoreSiegeB">0</div>
            </div>
        </div>

        <div class="bottom-right">
            <div class="line-scores">
                <div class="line-score C_MELEE_COLOR" id="scoreMeleeA">0</div>
                <div class="line-score C_RANGE_COLOR" id="scoreRangeA">0</div>
                <div class="line-score C_SIEGE_COLOR" id="scoreSiegeA">0</div>
            </div>
            <div class="score-total" id="scoreTotalA">0</div>
        </div>
    </div>

    <div class="scene-menu">
        <div class="card-counter">0</div>
        <div class="card-stack"></div>
        <div class="toggle-indicator" id="colorToggle"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script>
        /* ======================================================= */
        /* === LOGIQUE THREE.JS (makete.html) === */
        /* ======================================================= */
        const cardWidth = 150; 
        const cardHeight = 180; 
        const halfCardHeight = cardHeight / 2;
        const gap = 10; 
        const PLATEAU_Z = 0;

        // NOUVELLES CONSTANTES POUR LE PLACEMENT EN MODE BRIQUE
        const CARD_SPACING = 20; // Espacement horizontal entre les cartes
        const ROW_SPACING = cardHeight + 40; // Espacement vertical entre les rangées (cardHeight + marge)
        
        // 💡 NOUVELLE CONSTANTE : 10% de la hauteur de la carte
        const VERTICAL_OFFSET_10_PERCENT = cardHeight * 0.1;
        
        // FACTEUR DE PLACEMENT SÛR (ex: 90% de la largeur visible)
        const CARD_PLACEMENT_SAFE_FACTOR = 0.9;
        
        // 💡 VARIABLES GLOBALES FIXES POUR LE PLACEMENT
        let fixedPlacementRange = 0; 
        const initialPlacementCenter = 0; // Le centre du plateau (et la caméra au départ)

        let scene, camera, renderer;
        let boardGroup, progressBar3D, boardArea, scoreFillA, boardBorder;
        let a_cards = [];
        let b_cards = [];

        // VARIABLES DE SCORE PAR LIGNE
        let scoreA = 0;
        let scoreB = 0;
        let scoreA_melee = 0;
        let scoreA_range = 0;
        let scoreA_siege = 0;
        let scoreB_melee = 0;
        let scoreB_range = 0;
        let scoreB_siege = 0;

        let a_card_positions = [];
        let b_card_positions = [];
        let menuObject; 

        let currentBarY = 0; 

        const cardTypes = ['melee', 'range', 'siege'];

        const BOARD_TOTAL_HEIGHT = 4400; 
        let boardWidth = 7200; 

        const bottomY = -BOARD_TOTAL_HEIGHT / 2; 
        const topY = BOARD_TOTAL_HEIGHT / 2;     
        const margin = 100; 

        const defaultCameraDistance = 2000; 
        const minCameraDistance = 1000;
        const maxCameraDistance = 3000;
        // RECUL DE LA CAMÉRA DE 20%
        let cameraDistance = defaultCameraDistance * 1.2; // 2000 * 1.2 = 2400

        const FOUNDATION_COLOR_LIGHT = '#444444'; 
        const SCORE_FILL_COLOR_A = 'rgba(0, 0, 0, 0.2)'; 

        const ENTRY_OFFSET = 2000; 
        const STACK_FACTOR = 0.5;            

        // PARAMÈTRES DE LA PILE (RÉDUITS DE 50%)
        const MENU_CONTAINER_WIDTH = 100;  
        const MENU_CONTAINER_HEIGHT = 150; 
        const MENU_SCALE = 3.0;            

        /**
         * Calcule la largeur de la scène visible en unités 3D.
         */
        function getVisibleSceneWidth() {
            const distance = camera.position.z;
            const vFOV = camera.fov * Math.PI / 180;
            const viewHeight = 2 * Math.tan(vFOV / 2) * distance;
            const aspectRatio = camera.aspect;
            const viewWidth = viewHeight * aspectRatio;
            return viewWidth;
        }

        /**
         * Calcule la position X dans l'espace 3D pour centrer le menu au milieu de la vue.
         */
        function getMenuXPosition() {
            return camera.position.x;
        }

        /**
         * Calcule la position Y dans l'espace 3D pour aligner verticalement le centre de la pile
         * légèrement au-dessus du bas de l'écran (position fixe sur le viewport).
         */
        function getMenuYPosition() {
            const vFOV = camera.fov * Math.PI / 180;
            const viewHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;
            const unitsPerPixel = viewHeight / window.innerHeight;

            const menuHeight3D = MENU_CONTAINER_HEIGHT * MENU_SCALE;
            const BOTTOM_MARGIN_PIXELS = 50; // Marge de 50px au-dessus du bord inférieur
            const bottomMargin3D = BOTTOM_MARGIN_PIXELS * unitsPerPixel;

            const viewBottomEdgeY = camera.position.y - (viewHeight / 2);

            // Centre Y du menu = Bord Inférieur Vue + Marge + Moitié Hauteur Menu
            const targetCenterY = viewBottomEdgeY + bottomMargin3D + (menuHeight3D / 2);
            
            return targetCenterY;
        }

        /**
         * Met à jour la position du menu Object (X et Y) dans la scène 3D.
         */
        function updateMenuPosition() {
            if (!menuObject) return;

            const targetX = getMenuXPosition();
            const targetY = getMenuYPosition();

            menuObject.position.set(targetX, targetY, 0); 
            menuObject.scale.set(MENU_SCALE, MENU_SCALE, MENU_SCALE);
        }

        function init() {
            scene = new THREE.Scene();
            currentBarY = 0; 

            camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 0, cameraDistance); // Utilise la nouvelle cameraDistance (2400)
            camera.lookAt(0, 0, 0); 

            renderer = new THREE.CSS3DRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = 0;
            
            renderer.domElement.style.touchAction = 'none'; 
            renderer.domElement.style.zIndex = '1';
            
            document.body.appendChild(renderer.domElement);

            boardGroup = new THREE.Group();
            scene.add(boardGroup);

            // ... (Construction du plateau 3D)

            const borderDiv = document.createElement('div');
            borderDiv.className = 'border-area';
            borderDiv.style.width = `${boardWidth}px`;
            borderDiv.style.height = `${BOARD_TOTAL_HEIGHT}px`;
            borderDiv.style.backgroundColor = 'transparent'; 
            boardBorder = new THREE.CSS3DObject(borderDiv);
            boardBorder.position.set(0, -500, -50); 
            boardGroup.add(boardBorder);

            const areaDiv = document.createElement('div');
            areaDiv.className = 'board-area';
            areaDiv.style.width = `${boardWidth}px`;
            areaDiv.style.height = `${BOARD_TOTAL_HEIGHT}px`;
            boardArea = new THREE.CSS3DObject(areaDiv);
            boardArea.position.set(0, 0, -45); 
            boardGroup.add(boardArea);

            const scoreFillDivA = document.createElement('div');
            scoreFillDivA.className = 'score-fill-A';
            scoreFillDivA.style.width = `${boardWidth}px`;
            scoreFillDivA.style.backgroundColor = SCORE_FILL_COLOR_A;
            scoreFillDivA.style.boxShadow = `none`; 
            scoreFillDivA.style.opacity = '0'; 
            scoreFillA = new THREE.CSS3DObject(scoreFillDivA);
            scoreFillA.position.set(0, 0, -40); 
            boardGroup.add(scoreFillA);

            const barDiv = document.createElement('div');
            barDiv.style.width = `${boardWidth}px`;
            barDiv.style.height = '22px'; 
            barDiv.style.background = `linear-gradient(90deg, #333333, #666666, #333333)`; 
            barDiv.style.borderRadius = '16px';
            barDiv.style.boxShadow = `0 0 60px ${FOUNDATION_COLOR_LIGHT}, inset 0 0 20px rgba(255,255,255,0.1)`;
            barDiv.style.opacity = '0'; 
            progressBar3D = new THREE.CSS3DObject(barDiv);
            progressBar3D.position.set(0, 0, 20); 
            boardGroup.add(progressBar3D);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            // === INTÉGRATION DE LA PILE (SCENE MENU) DANS CSS3DRenderer ===
            const menuEl = document.querySelector('.scene-menu');
            menuObject = new THREE.CSS3DObject(menuEl);
            scene.add(menuObject);

            updateMenuPosition(); // Initialisation de la position

            // 💡 Calculer la borne de placement FIXE (basée sur l'initialisation)
            const initialViewWidth = getVisibleSceneWidth();
            fixedPlacementRange = initialViewWidth * CARD_PLACEMENT_SAFE_FACTOR;
            
            renderer.domElement.addEventListener('mousedown', handleMouseDown, false);
            renderer.domElement.addEventListener('mousemove', handleMouseMove, false);
            window.addEventListener('mouseup', handleMouseUp, false); 
            renderer.domElement.addEventListener('touchstart', handleTouchStartPan, false);
            renderer.domElement.addEventListener('touchmove', handleTouchMovePan, false);
            renderer.domElement.addEventListener('touchend', handleTouchEndPan, false);
            window.addEventListener('wheel', handleMouseWheel, { passive: false });
            window.addEventListener('touchstart', handleTouchStartPinch, { passive: false });
            window.addEventListener('touchmove', handleTouchMovePinch, { passive: false });
            window.addEventListener('touchend', handleTouchEndPinch, { passive: false });

            updatePanFactor(); 
            updateBar(currentBarY, false);

            initializeMenu(); 

            animate();
            startGame();
        }

        // ... (Fonctions de Panning/Zoom - conservées) ...

        function updatePanFactor() {
            const vFOV = camera.fov * Math.PI / 180;
            const height = 2 * Math.tan(vFOV / 2) * camera.position.z;
            panFactor = height / window.innerHeight;
        }

        function panCamera(deltaX, deltaY) {
            camera.position.x -= deltaX * panFactor;
            camera.position.y += deltaY * panFactor;
            camera.lookAt(camera.position.x, camera.position.y, 0);

            updateMenuPosition(); 
        }

        function handleMouseDown(event) {
            if (event.button === 0 && !isDraggingMenu) { 
                isDragging = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
                event.preventDefault(); 
            }
        }

        function handleMouseMove(event) {
            if (!isDragging || isDraggingMenu) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            panCamera(deltaX, deltaY);

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function handleMouseUp() {
            isDragging = false;
        }

        function handleTouchStartPan(event) {
            if (event.touches.length === 1 && !isDraggingMenu) {
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
                event.stopPropagation();
            }
        }

        function handleTouchMovePan(event) {
            if (isDragging && event.touches.length === 1 && !isDraggingMenu) {
                event.preventDefault();
                event.stopPropagation(); 

                const deltaX = event.touches[0].clientX - previousMousePosition.x;
                const deltaY = event.touches[0].clientY - previousMousePosition.y;

                panCamera(deltaX, deltaY);

                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function handleTouchEndPan(event) { 
            if (event.touches.length === 0) {
                 isDragging = false;
            }
        }

        function handleMouseWheel(event) {
            event.preventDefault(); 
            const zoomSpeed = 200; 
            const zoomAmount = event.deltaY > 0 ? zoomSpeed : -zoomSpeed;
            updateCameraDistance(camera.position.z + zoomAmount);
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function handleTouchStartPinch(event) {
            if (event.touches.length === 2 && !isDraggingMenu) {
                initialPinchDistance = getPinchDistance(event.touches);
            }
            isDragging = false; 
        }

        function handleTouchMovePinch(event) {
            if (event.touches.length === 2 && !isDraggingMenu) {
                event.preventDefault(); 
                const currentPinchDistance = getPinchDistance(event.touches);

                if (initialPinchDistance) {
                    const delta = currentPinchDistance - initialPinchDistance;
                    const zoomFactor = -delta * 5; 
                    updateCameraDistance(camera.position.z + zoomFactor);
                    initialPinchDistance = currentPinchDistance; 
                }
            }
        }

        function handleTouchEndPinch(event) {
            initialPinchDistance = null;
            if (event.touches.length === 1 && !isDraggingMenu) {
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function updateCameraDistance(newZ) {
            const clampedZ = Math.max(minCameraDistance, Math.min(maxCameraDistance, newZ));
            camera.position.z = clampedZ;
            cameraDistance = clampedZ; 
            updatePanFactor();

            updateMenuPosition(); 
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function createCard(player) {
            const power = Math.floor(Math.random() * 10) + 1;
            const type = cardTypes[Math.floor(Math.random() * cardTypes.length)];

            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${player} ${type}`; 

            let typeLabel;
            switch(type) {
                case 'melee': typeLabel = 'Mêlée'; break;
                case 'range': typeLabel = 'Distance'; break;
                case 'siege': typeLabel = 'Siège'; break;
                default: typeLabel = '';
            }

            cardDiv.innerHTML = `
                <div class="card-type-label">${typeLabel}</div>
                <div class="card-power">${power}</div>
            `;
            cardDiv.style.transform = 'translateZ(10px)'; 
            cardDiv.style.opacity = '0';

            const cardObj = new THREE.CSS3DObject(cardDiv);
            cardObj.position.set(0, 0, PLATEAU_Z);
            cardObj.scale.set(0.1, 0.1, 0.1);

            return { obj: cardObj, power, type, element: cardDiv };
        }

        /**
         * LOGIQUE : Placement en Briques Symétriques (Horizontal).
         * La 1ère carte est au centre, puis les suivantes s'accolent alternativement à droite et à gauche.
         */
        function getNextAvailableX(teamPositions) {
            const CARD_FULL_WIDTH = cardWidth + CARD_SPACING;
            const maxCardsPerRow = Math.floor(fixedPlacementRange / CARD_FULL_WIDTH);
            if (maxCardsPerRow < 1) return initialPlacementCenter; 

            const cardIndex = teamPositions.length; 
            
            // Détermine l'index de la carte au sein de sa rangée (0 à maxCardsPerRow - 1)
            const rowCardIndex = cardIndex % maxCardsPerRow; 

            let newX;
            if (rowCardIndex === 0) {
                // La première carte de la rangée: Centre
                newX = initialPlacementCenter;
            } else {
                // Placement symétrique: 1 -> +1, 2 -> -1, 3 -> +2, 4 -> -2, ...
                
                const offsetMultiplier = Math.ceil(rowCardIndex / 2); 
                const direction = (rowCardIndex % 2 !== 0) ? 1 : -1; 

                // Calcule la position X
                newX = initialPlacementCenter + (direction * offsetMultiplier * CARD_FULL_WIDTH);
            }
            
            return newX;
        }

        /**
         * LOGIQUE CLÉ MISE À JOUR : Placement en Briques Verticales (avec offset 10% progressif).
         */
        function updateCardsVerticalPositions(barY) {
            const cardTargets = [];

            const CARD_FULL_WIDTH = cardWidth + CARD_SPACING;
            const maxCardsPerRow = Math.floor(fixedPlacementRange / CARD_FULL_WIDTH);
            if (maxCardsPerRow < 1) return []; // Évite la division par zéro

            const halfCardHeightWithGap = halfCardHeight + gap;

            // --- Joueur A (descend à partir de la barre) ---
            let base_Y_A = barY - halfCardHeightWithGap;
            a_cards.forEach((card, i) => {
                const row = Math.floor(i / maxCardsPerRow); // Détermine le numéro de rangée
                const rowCardIndex = i % maxCardsPerRow;    // Index dans la rangée (0, 1, 2...)
                
                // 1. Base Y de la rangée
                const baseTargetY = base_Y_A - (row * ROW_SPACING); 

                // 2. Décalage vertical progressif de 10% de la hauteur de la carte (vers le bas)
                const offset = rowCardIndex * VERTICAL_OFFSET_10_PERCENT; 
                const targetY = baseTargetY - offset; 

                const isOnBoard = targetY - halfCardHeight > bottomY;

                cardTargets.push({ card: card.obj.position, y: targetY });

                card.obj.position.x = a_card_positions[i];
                card.obj.position.z = PLATEAU_Z + i * 5; 
                card.element.classList[isOnBoard ? 'remove' : 'add']('off-board');
            });

            // --- Joueur B (monte à partir de la barre) ---
            let base_Y_B = barY + halfCardHeightWithGap;
            b_cards.forEach((card, i) => {
                const row = Math.floor(i / maxCardsPerRow); // Détermine le numéro de rangée
                const rowCardIndex = i % maxCardsPerRow;    // Index dans la rangée (0, 1, 2...)

                // 1. Base Y de la rangée
                const baseTargetY = base_Y_B + (row * ROW_SPACING);

                // 2. Décalage vertical progressif de 10% de la hauteur de la carte (vers le haut)
                const offset = rowCardIndex * VERTICAL_OFFSET_10_PERCENT; 
                const targetY = baseTargetY + offset;

                const isOnBoard = targetY + halfCardHeight < topY;

                cardTargets.push({ card: card.obj.position, y: targetY });

                card.obj.position.x = b_card_positions[i];
                card.obj.position.z = PLATEAU_Z + i * 5;
                card.element.classList[isOnBoard ? 'remove' : 'add']('off-board');
            });

            return cardTargets;
        }

        function updateBar(barY, animate = true) {
            currentBarY = barY;

            const duration = animate ? 1 : 0;

            gsap.to(progressBar3D.position, { y: barY, duration: duration, ease: "power2.out" });

            gsap.to(boardBorder.element.style, { width: `${boardWidth}px`, height: `${BOARD_TOTAL_HEIGHT}px`, duration: duration, ease: "power2.out" });
            boardBorder.position.set(0, 0, -50); 

            gsap.to(boardArea.element.style, { width: `${boardWidth}px`, height: `${BOARD_TOTAL_HEIGHT}px`, duration: duration, ease: "power2.out" });
            boardArea.position.set(0, 0, -45); 

            const heightA = barY - bottomY;
            const centerA = bottomY + (heightA / 2); 

            gsap.to(scoreFillA.element.style, { height: `${heightA}px`, duration: duration, ease: "power2.out" });
            gsap.to(scoreFillA.position, { y: centerA, duration: duration, ease: "power2.out" });

            if (animate || heightA > 0) {
                gsap.to(scoreFillA.element.style, { opacity: 1, duration: 0.5 }, 0); 
            } else {
                gsap.to(scoreFillA.element.style, { opacity: 0, duration: 0.5 });
            }

            // MISE À JOUR DES NOUVEAUX SCORES HUD
            const total = scoreA + scoreB || 1;
            const progressPercent = (scoreA / total) * 100;
            gsap.to('#progressFill', { height: `${progressPercent}%`, duration: 1 });

            // Scores Joueur A
            document.getElementById('scoreTotalA').textContent = scoreA;
            document.getElementById('scoreMeleeA').textContent = scoreA_melee;
            document.getElementById('scoreRangeA').textContent = scoreA_range;
            document.getElementById('scoreSiegeA').textContent = scoreA_siege;

            // Scores Joueur B
            document.getElementById('scoreTotalB').textContent = scoreB;
            document.getElementById('scoreMeleeB').textContent = scoreB_melee;
            document.getElementById('scoreRangeB').textContent = scoreB_range;
            document.getElementById('scoreSiegeB').textContent = scoreB_siege;
        }

        async function addTurn(turn) {

            const isPlayerA = turn % 2 === 0;
            const player = isPlayerA ? 'A' : 'B';
            const newCard = createCard(player);
            const teamPositions = isPlayerA ? a_card_positions : b_card_positions;
            
            // Utilise la logique de placement en briques symétriques (X)
            const newX = getNextAvailableX(teamPositions);

            // LOGIQUE DE SCORE MISE À JOUR
            if (isPlayerA) {
                a_card_positions.push(newX);
                a_cards.push(newCard);
                scoreA += newCard.power;
                if (newCard.type === 'melee') scoreA_melee += newCard.power;
                else if (newCard.type === 'range') scoreA_range += newCard.power;
                else if (newCard.type === 'siege') scoreA_siege += newCard.power;
            } else {
                b_card_positions.push(newX);
                b_cards.push(newCard);
                scoreB += newCard.power;
                if (newCard.type === 'melee') scoreB_melee += newCard.power;
                else if (newCard.type === 'range') scoreB_range += newCard.power;
                else if (newCard.type === 'siege') scoreB_siege += newCard.power;
            }

            const total = scoreA + scoreB;
            const newBarY = bottomY + (scoreA / total) * BOARD_TOTAL_HEIGHT; 

            const entryY = isPlayerA ? newBarY - ENTRY_OFFSET : newBarY + ENTRY_OFFSET;

            const newCardIndex = (isPlayerA ? a_cards.length : b_cards.length) - 1;
            newCard.obj.position.set(newX, entryY, PLATEAU_Z + newCardIndex * 5); 

            boardGroup.add(newCard.obj);

            const cardTargets = updateCardsVerticalPositions(newBarY); 

            const mainTimeline = gsap.timeline();
            const cardDuration = 1.2; 
            const barDuration = 1;
            const oldCardsStartTime = 0.1; 

            if (turn === 1) {
                const overflowBarY = topY; 
                updateBar(overflowBarY, false); 
                currentBarY = overflowBarY;     
                progressBar3D.element.style.opacity = '1';
                scoreFillA.element.style.opacity = '1';
            }

            updateBar(newBarY, true); 

            const newCardTarget = cardTargets.find(t => t.card === newCard.obj.position);
            mainTimeline.to(newCard.obj.position, { y: newCardTarget.y, duration: cardDuration, ease: "power2.out" }, 0); 

            mainTimeline.fromTo(newCard.obj.scale, 
                { x: 0.1, y: 0.1, z: 0.1 },
                { x: 1, y: 1, z: 1, duration: cardDuration, ease: "back.out(1.7)" }, 0
            );
            mainTimeline.to(newCard.element, { opacity: 1, duration: 0.8 }, 0.4);

            const oldCardTargets = cardTargets.filter(t => t.card !== newCard.obj.position);

            oldCardTargets.forEach(target => {
                 mainTimeline.to(target.card, { y: target.y, duration: barDuration, ease: "power2.out"}, oldCardsStartTime);
            });

            await new Promise(resolve => mainTimeline.eventCallback("onComplete", resolve));
            await new Promise(resolve => setTimeout(resolve, 200)); 
        }

        async function startGame() {
            const firstCard = createCard('A');
            // Utilise la logique de placement en briques symétriques (X)
            const firstX = getNextAvailableX([]); 
            a_card_positions.push(firstX);
            firstCard.obj.scale.set(0.1, 0.1, 0.1);
            firstCard.element.style.opacity = '0';
            a_cards.push(firstCard);

            // LOGIQUE DE SCORE MISE À JOUR
            scoreA += firstCard.power;
            if (firstCard.type === 'melee') scoreA_melee += firstCard.power;
            else if (firstCard.type === 'range') scoreA_range += firstCard.power;
            else if (firstCard.type === 'siege') scoreA_siege += firstCard.power;

            const initialBarY = topY; 
            const entryY = initialBarY - ENTRY_OFFSET; 

            firstCard.obj.position.set(firstX, entryY, PLATEAU_Z);
            boardGroup.add(firstCard.obj);

            const cardTargets = updateCardsVerticalPositions(initialBarY);
            const firstCardTarget = cardTargets.find(t => t.card === firstCard.obj.position);

            const initialTimeline = gsap.timeline();
            const initialDuration = 1.2;

            updateBar(initialBarY, true);

            firstCard.obj.position.y = entryY; 

            initialTimeline.to(firstCard.obj.position, { y: firstCardTarget.y, duration: initialDuration, ease: "power2.out" }, 0);

            initialTimeline.fromTo(firstCard.obj.scale, 
                { x: 0.1, y: 0.1, z: 0.1 },
                { x: 1, y: 1, z: 1, duration: initialDuration, ease: "back.out(1.7)" }, 0
            );
            initialTimeline.to(firstCard.element, { opacity: 1, duration: 0.8 }, 0.4);

            await new Promise(resolve => initialTimeline.eventCallback("onComplete", resolve));
            await new Promise(resolve => setTimeout(resolve, 1000));

            for (let turn = 1; turn < 20; turn++) {
                await addTurn(turn);
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            boardArea.element.style.width = `${boardWidth}px`;
            boardBorder.element.style.width = `${boardWidth}px`;
            progressBar3D.element.style.width = `${boardWidth}px`;
            scoreFillA.element.style.width = `${boardWidth}px`; 

            // IMPORTANT: Le redimensionnement de la fenêtre recalcule la borne FIXE.
            const newViewWidth = getVisibleSceneWidth();
            fixedPlacementRange = newViewWidth * CARD_PLACEMENT_SAFE_FACTOR;
            
            updateBar(currentBarY, false);
            updateCardsVerticalPositions(currentBarY);

            updatePanFactor();
            updateMenuPosition(); 
        });

        /* ======================================================= */
        /* === LOGIQUE DE PILE (menu.html - inchangée) === */
        /* ======================================================= */
        const stackEl = document.querySelector('.card-stack');
        const counterEl = document.querySelector('.card-counter');
        const toggleEl = document.getElementById('colorToggle');

        const COLORS = {
            green: '#bff5bf',
            blue: '#c9e5ff',
            orange: '#ffe5b0',
            white: '#ffffff',
            darkgrey: '#777777'
        };

        const CARD_COUNT_MENU = 12; 
        const Z_GAP = 1;
        const SWIPE_THRESHOLD = 80;

        let topCard = null;
        let isDraggingMenu = false; 
        let startX = 0, startY = 0, currentX = 0, currentY = 0;
        let currentToggleColor = null;
        let togglePair = null; 

        function randomColorGroup(i) {
            const groups = ['green','blue','orange','white','darkgrey'];
            return groups[i % groups.length];
        }

        function initializeMenu() {
            stackEl.innerHTML = '';
            for (let i = 0; i < CARD_COUNT_MENU; i++) {
                const group = randomColorGroup(i);
                const card = document.createElement('div');
                card.className = 'card menu-card'; 
                card.dataset.group = group;
                card.style.backgroundColor = COLORS[group];
                card.innerHTML = `
                    <div class="card-icon">${group === 'orange' ? '🔥' : group === 'blue' ? '💧' : group === 'green' ? '🌿' : group === 'darkgrey' ? '⬛' : '⚪'}</div>
                    <div class="card-count">${group}</div>
                `;
                stackEl.appendChild(card);
            }
            updateTopCardReference();
            updateCardIndices();
            updateCounter();
        }

        function updateTopCardReference() {
            if (topCard) {
                topCard.removeEventListener('mousedown', startDragMenu);
                topCard.removeEventListener('touchstart', startDragMenu);
                topCard.classList.remove('highlight-halo'); 
            }
            topCard = stackEl.firstElementChild;
            if (!topCard) {
                 toggleEl.style.display = 'none';
                 return;
            }

            if (topCard.dataset.group !== 'white' && topCard.dataset.group !== 'darkgrey') {
                topCard.removeAttribute('data-is-toggled');
            }

            topCard.addEventListener('mousedown', startDragMenu);
            topCard.addEventListener('touchstart', startDragMenu);

            if (topCard.dataset.group === 'white') {
                currentToggleColor = null; 
                togglePair = { left: 'green', right: 'blue' };
                showToggle();
            } else if (topCard.dataset.group === 'darkgrey') {
                currentToggleColor = null; 
                togglePair = { left: 'green', right: 'orange' };
                showToggle();
            } else {
                toggleEl.style.display = 'none';
                togglePair = null;
            }
        }

        function showToggle() {
            toggleEl.style.display = 'flex';
            toggleEl.style.background = `linear-gradient(90deg, ${COLORS[togglePair.left]} 50%, ${COLORS[togglePair.right]} 50%)`;
        }

        function updateCounter() {
            counterEl.textContent = stackEl.children.length;
        }

        function updateCardIndices() {
            const cards = Array.from(stackEl.children);
            cards.forEach((card, index) => {
                const zPos = -index * Z_GAP;
                card.style.transform = `translateZ(${zPos}px)`;
                card.style.color = 'var(--text-dark)'; 
            });
        }

        function bounceStack(axis = 'x') {
            const className = `bounce-${axis}`;
            stackEl.classList.add(className);

            setTimeout(() => {
                stackEl.classList.remove(className);
                stackEl.style.transform = 'translate(-50%, -50%) rotateX(10deg)'; 
            }, 250); 
        }

        function startDragMenu(e) {
            if (!topCard || isDraggingMenu) return;
            isDraggingMenu = true;
            const client = e.touches ? e.touches[0] : e;
            startX = client.clientX;
            startY = client.clientY;
            topCard.classList.add('is-dragging');
            document.addEventListener('mousemove', dragMenu);
            document.addEventListener('mouseup', endDragMenu);
            document.addEventListener('touchmove', dragMenu, { passive: false });
            document.addEventListener('touchend', endDragMenu);
        }

        function dragMenu(e) {
            if (!isDraggingMenu) return;
            const client = e.touches ? e.touches[0] : e;
            currentX = client.clientX - startX;
            currentY = client.clientY - startY;
            const rotation = currentX / 20;

            const cards = Array.from(stackEl.children);

            cards.forEach((card, index) => {
                const zPos = -index * Z_GAP;
                const scaleFactor = Math.pow(0.5, index);
                const translateX = currentX * scaleFactor;
                const translateY = currentY * scaleFactor;
                const rotateZ = rotation * scaleFactor * 0.3; 

                card.style.transform = `translateX(${translateX}px) translateY(${translateY}px) rotateZ(${rotateZ}deg) translateZ(${zPos}px)`;
            });

            const absX = Math.abs(currentX);
            const absY = Math.abs(currentY);
            const cardGroup = topCard.dataset.group;
            const isSpecialCard = cardGroup === 'white' || cardGroup === 'darkgrey';
            const isToggledToNewColor = isSpecialCard && topCard.dataset.isToggled === 'true';

            const isPotentialRemoval = absX > SWIPE_THRESHOLD && absX > absY && (!isSpecialCard || isToggledToNewColor);

            if (isPotentialRemoval) {
                topCard.style.color = topCard.style.backgroundColor;
                topCard.classList.add('highlight-halo');
            } else {
                topCard.classList.remove('highlight-halo');
                topCard.style.color = 'var(--text-dark)'; 
            }

            if (e.cancelable) e.preventDefault();
        }

        function endDragMenu() {
            if (!isDraggingMenu) return;
            isDraggingMenu = false;
            topCard.classList.remove('is-dragging');
            topCard.classList.remove('highlight-halo'); 
            topCard.style.color = 'var(--text-dark)'; 

            const absX = Math.abs(currentX);
            const absY = Math.abs(currentY);
            const cardGroup = topCard.dataset.group;

            const isSpecialCard = cardGroup === 'white' || cardGroup === 'darkgrey';
            const isToggledToNewColor = isSpecialCard && topCard.dataset.isToggled === 'true'; 

            let actionTaken = false;

            if (absX > SWIPE_THRESHOLD && absX > absY) {
                if (isSpecialCard && !isToggledToNewColor) { 
                    handleCycle(true); 
                    actionTaken = true;
                } else {
                    handleRemoval(currentX > 0 ? 'right' : 'left');
                    actionTaken = true;
                }
            } else if (absY > SWIPE_THRESHOLD && absY > absX) {
                handleCycle(false, true); 
                actionTaken = true;
            }

            if (!actionTaken) {
                if (absX > absY) bounceStack('x');
                else bounceStack('y');
                handleReset();
            }

            document.removeEventListener('mousemove', dragMenu);
            document.removeEventListener('mouseup', endDragMenu);
            document.removeEventListener('touchmove', dragMenu);
            document.removeEventListener('touchend', endDragMenu);
        }

        function handleReset() {
            currentX = currentY = 0;
            updateCardIndices(); 
        }

        function handleCycle(bounceX = false, bounceY = false) {
            topCard.style.transform = `translateZ(0px)`;
            topCard.classList.remove('highlight-halo'); 
            topCard.style.color = 'var(--text-dark)'; 
            topCard.classList.add('cycle-out');

            if (bounceX) bounceStack('x');
            if (bounceY) bounceStack('y');

            setTimeout(() => {
                topCard.classList.remove('cycle-out');
                stackEl.removeChild(topCard);

                if (topCard.dataset.group === 'white' || topCard.dataset.group === 'darkgrey') {
                    topCard.style.backgroundColor = COLORS[topCard.dataset.group];
                    topCard.innerHTML = `<div class="card-icon">${topCard.dataset.group === 'white' ? '⚪' : '⬛'}</div><div class="card-count">${topCard.dataset.group}</div>`;
                    topCard.removeAttribute('data-is-toggled'); 
                }

                stackEl.appendChild(topCard);
                updateCardIndices();
                updateTopCardReference();
            }, 250);
        }

        function handleRemoval(direction) {
            topCard.classList.remove('highlight-halo'); 
            topCard.style.color = 'var(--text-dark)'; 

            topCard.classList.add(`remove-${direction}`);

            if (direction === 'left') bounceStack('x');
            else bounceStack('x');

            setTimeout(() => {
                stackEl.removeChild(topCard);
                updateCardIndices();
                updateCounter();
                updateTopCardReference();
                if (stackEl.children.length === 0) setTimeout(initializeMenu, 500);
            }, 300);
        }

        toggleEl.addEventListener('click', () => {
            if (!topCard || !togglePair) return;

            currentToggleColor = (currentToggleColor === togglePair.left) ? togglePair.right : togglePair.left;
            const chosenColor = COLORS[currentToggleColor];
            const chosenText = `teinte: ${currentToggleColor}`;
            const icon = currentToggleColor === 'green' ? '🌿' :
                         currentToggleColor === 'blue' ? '💧' : '🔥';

            topCard.style.backgroundColor = chosenColor;
            topCard.innerHTML = `
                <div class="card-icon">${icon}</div>
                <div class="card-count">${chosenText}</div>
            `;

            topCard.dataset.isToggled = 'true'; 
        });


        // Lancement de l'initialisation de Three.js
        window.addEventListener('load', init); 
    </script>
</body>
</html>
