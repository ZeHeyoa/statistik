<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gwent CSS3D Demo - Menu 100% CSS & Mobile Pan Y</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        /* ======================================================= */
        /* === STYLES DU PLATEAU 3D (makete.html) === */
        /* ======================================================= */

        /* CONSTANTES DE COULEURS POUR LES LIGNES */
        .C_MELEE_COLOR { background-color: #A8E61D; color: #333; }
        .C_RANGE_COLOR { background-color: #FFD700; color: #333; }
        .C_SIEGE_COLOR { background-color: #B0E0E6; color: #333; }

        /* BASE & BACKGROUND */
        body {
            margin: 0;
            overflow: hidden;
            background: #AEEA9C;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        /* PROGRESS BAR HUD */
        .progress-bar-hud {
            display:none;
            position: fixed;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            z-index: 1000;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(120, 0, 255, 0.3);
            border-radius: 4px;
        }
        .progress-fill {
            height: 50%;
            background: #00ffff;
            border-radius: 4px;
            transition: height 1s ease;
        }

        /* ======================================================= */
        /* === CONTENEUR DE DÉFILEMENT (HUD Principal) === */
        /* ======================================================= */
        /* Conteneur pour Joueur B (Top-Left) */
        #scroll-hud-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 25%;
            height: auto;
            z-index: 1100;
            overflow-y: auto;
            overflow-x: hidden;
            pointer-events: all;
            padding-right: 10px;
            display: flex;
            flex-direction: column;
        }

        /* NOUVEAU CONTENEUR POUR LE HUD DU JOUEUR A (Bottom-Right) */
        #player-a-hud-container {
            position: fixed;
            top: unset;
            bottom: 0;
            right: 0;
            width: 25%;
            height: auto;
            z-index: 1100;
            pointer-events: all;
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Align the content to the right */
        }

        /* NOUVEAUX ÉLÉMENTS DE SCORE HUD (A et B) */
        .score-hud-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* Alignment par défaut pour Player B (Left) */
            font-family: 'Fredoka One', cursive, Arial, sans-serif;
            min-height: auto;
            padding: 10px 0 10px 10px;
            box-sizing: border-box;
            gap: 15px;
            width: 100%;
        }

        /* Style pour le conteneur de score sur la droite (Player A) */
        #player-a-hud-container .score-hud-container {
            padding: 10px 10px 10px 0; /* Padding à droite */
            align-items: flex-end; /* Alignement à droite des scores A */
        }

        /* Conteneur pour Joueur A (Score + Menu) - Aligne horizontalement */
        #player-a-group {
            display: flex;
            align-items: flex-end;
            gap: 15px;
        }

        /* Inverser l'ordre des éléments pour l'affichage Player A (Total à droite, Lignes à gauche) */
        #player-a-hud-container #player-a-group {
            flex-direction: row-reverse;
            align-items: flex-end;
            gap: 15px;
        }

        .score-total {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #111;
            color: #DDDDDD;
            font-size: 36px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5), 0 0 10px rgba(255, 255, 255, 0.5);
            border: 2px solid #555;
            transition: all 0.5s ease;
        }

        .line-scores {
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.5s ease;
            position: relative; /* Ajout pour positionner la pastille d'éjection */
        }

        /* Aligner les scores de ligne du joueur A à droite */
        #player-a-hud-container .line-scores {
            align-items: flex-end;
        }

        .line-score {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 4px 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4), 0 0 5px rgba(255, 255, 255, 0.3);
            color: #333;
            border: 2px solid #333;
            transition: all 0.5s ease;
        }

        /* CARTES PLATEAU (Style aligné aux .line-score) */
        .card.A, .card.B {
            width: 350px;
            height: 400px;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4), 0 0 5px rgba(255, 255, 255, 0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-size: 40px;
            font-weight: bold;
            text-shadow: none;
            cursor: pointer;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            position: relative;
            overflow: hidden;
            transition: opacity 0.3s ease;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
        }

        .card-power {
            font-size: 60px;
            line-height: 1;
            margin-bottom: 5px;
            z-index: 2;
        }

        .card-type-label {
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
            z-index: 2;
        }

        .card.melee { background-color: #A8E61D; }
        .card.range { background-color: #FFD700; }
        .card.siege { background-color: #B0E0E6; }

        .card.melee .card-power, .card.range .card-power, .card.siege .card-power {
            color: #333;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.3);
        }

        .card.off-board {
            opacity: 0.2;
            filter: grayscale(80%);
            border-color: #333333;
            box-shadow: none;
        }

        .board-area {
            background: #AEEA9C;
            overflow: auto;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.1);
            opacity: 1;
        }

        /* ======================================================= */
        /* === STYLES DE LA PILE (Menu 100% CSS) === */
        /* ======================================================= */
        :root {
            --card-width-menu: 120px;
            --card-height-menu: 200px;
            --z-gap: 1px;
            --bg-green: #bff5bf;
            --bg-blue: #c9e5ff;
            --bg-orange: #ffe5b0;
            --bg-white: #ffffff;
            --bg-darkgrey: #777777;
            --border-dark: #333;
            --counter-bg: #e67e22;
            --text-dark: #333;
        }

        /* FIX: Centrage parfait en bas de l'écran */
        .scene-menu {
            width: var(--card-width-menu);
            height: var(--card-height-menu);
            pointer-events: all;

            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);

            perspective: 500px;
            z-index: 1200;
            margin-top: 0;
        }
        /* ======================================================= */

        /* Pastille compteur */
        .card-counter {
            position: fixed; 
            bottom: 20px;    /* Positionné en bas à gauche de l'écran */
            left: 20px;      /* Positionné en bas à gauche de l'écran */
            right: unset;
            transform: none;
            width: 39.5px;
            height: 39.5px;
            border-radius: 50%;
            background-color: var(--counter-bg);
            border: 1px solid var(--border-dark);
            color: white;
            font-size: 13px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1201; /* Doit être au-dessus de .scene-menu */
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            pointer-events: none;
        }

        /* Pastille toggle */
        .toggle-indicator {
            position: absolute;
            top: 25%;
            left: 123%;
            transform: translateX(-50%);
            width: 26px;
            height: 26px;
            border-radius: 50%;
            border: 2.6px solid #444;
            display: none;
            cursor: pointer;
            transition: transform 0.2s ease, background 0.3s ease;
            z-index: 500;
        }
        .toggle-indicator:hover {
            transform: translateX(-50%) scale(1.1);
        }

        .card-stack {
            position: absolute;
            width: var(--card-width-menu);
            height: var(--card-height-menu);
            transform-style: preserve-3d;
            top: 50%;
            left: 50%;
            transition: transform 0.2s ease-out;
            transform: translate(-50%, -50%);
        }

        .card-stack.bounce-x {
            transform: translate(calc(-50% + 5px), -50%);
            transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .card-stack.bounce-y {
            transform: translate(-50%, calc(-50% + 5px));
            transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .card-stack:not(.bounce-x):not(.bounce-y) {
            transition: transform 0.25s ease-out;
        }

        .card.menu-card {
            position: absolute;
            width: var(--card-width-menu);
            height: var(--card-height-menu);
            border: 2px solid var(--border-dark);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            font-size: 30px;
            font-weight: bold;
            color: var(--text-dark);
            cursor: grab;
            user-select: none;
            touch-action: none;
            transition: transform 0.25s ease-out, box-shadow 0.25s ease-out, background-color 0.3s ease;
            box-shadow: 0 3px 4px rgba(0,0,0,0.25);
            font-family: 'Fredoka One', cursive, Arial, sans-serif;
            will-change: transform, left, top;
        }

        .card.menu-card.detached {
            position: fixed;
            top: 0;
            left: 0;
            transform-style: flat !important;
            transform: none !important;
            z-index: 99999;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: none;
        }

        .card.menu-card .card-count {
            font-size: 16px;
            background: rgba(255,255,255,0.7);
            border-radius: 5px;
            padding: 2px 8px;
            border: 1px solid var(--border-dark);
        }

        .card.menu-card.is-dragging {
            cursor: grabbing;
        }
        .card.menu-card.highlight-halo {
            box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.8), 0 3px 4px rgba(0,0,0,0.25);
        }

        .card.menu-card.cycle-out {
            transform: translateX(-150%) translateY(0) rotateZ(-30deg) !important;
            opacity: 0;
            transition: transform 0.3s ease-in, opacity 0.3s ease-in;
        }
        .card.menu-card.remove-right {
            transform: translateX(300px) translateY(0) rotateZ(30deg) !important;
            opacity: 0;
            transition: transform 0.3s ease-in, opacity 0.3s ease-in;
        }
        .card.menu-card.remove-left {
            transform: translateX(-300px) translateY(0) rotateZ(-30deg) !important;
            opacity: 0;
            transition: transform 0.3s ease-in, opacity 0.3s ease-in;
        }

        .card.menu-card.remove-up {
            transform: translateY(-300px) translateX(0) rotateZ(0deg) !important;
            opacity: 0;
            transition: transform 0.3s ease-in, opacity 0.3s ease-in;
        }

        /* NOUVEAU: Animation d'éjection vers l'avant */
        .card.menu-card.eject-forward {
            /* L'animation est gérée par GSAP, mais la classe sert de sélecteur */
            opacity: 0;
            transition: opacity 0.4s ease-in; /* Transition pour le fade out */
        }


        @media (max-width: 768px) {
            .score-hud-container {
                padding: 5px 0 5px 5px;
                gap: 10px;
                width: 100%;
            }
            #player-a-group {
                gap: 5px;
            }
            .score-total {
                width: 55px;
                height: 55px;
                font-size: 24px;
                margin: 5px 0;
            }
            .line-score {
                width: 35px;
                height: 35px;
                font-size: 14px;
                margin: 2px 0;
            }

            #player-a-hud-container {
                width: 30%;
            }
            #player-a-hud-container .score-hud-container {
                padding: 5px 5px 5px 0;
            }

            .scene-menu {
                width: 80px;
                height: 135px;
            }
            .card-stack {
                width: 80px;
                height: 135px;
            }
            .card.menu-card {
                width: 80px;
                height: 135px;
                padding: 5px;
                font-size: 20px;
            }
            .card.menu-card .card-count {
                font-size: 12px;
                padding: 1px 4px;
            }
            .card-counter {
                width: 55px;
                height: 55px;
                font-size: 20px;
                bottom: 10px; /* Ajusté pour mobile */
                left: 10px;   /* Ajusté pour mobile */
                right: unset;
                font-family: 'Fredoka One', cursive, Arial, sans-serif;
      
            }
            .toggle-indicator {
                width: 35px;
                height: 35px;
                border-width: 2px;
                top: -10%;
                left: 120%
            }
            .card.zoomed {
                width: 90vw;
                height: calc(90vw * 1.666);
            }
        }

        @media screen and (orientation: landscape) and (max-width: 900px) {
          .scene-menu {
            width: 60px;
            height: 100px;
            bottom: -5%;
          }

          .card.menu-card {
            width: 60px;
            height: 100px;
            font-size: 16px;
          }

          .score-total {
            width: 50px;
            height: 50px;
            font-size: 20px;
          }

          .line-score {
            width: 30px;
            height: 30px;
            font-size: 12px;
          }

          #scroll-hud-container,
          #player-a-hud-container {
            width: 20%;
          }

           .card-counter {
                width: 35px;
                height: 35px;
                font-size: 10px;
                bottom: 10px; /* Ajusté pour paysage mobile */
                left: 10px;   /* Ajusté pour paysage mobile */
                right: unset;
            }
            .toggle-indicator {
                width: 30px;
                height: 30px;
                border-width: 2px;
                top: 50%;
                left: 50%
            }
        }

        @media screen and (orientation: landscape) and (min-width: 901px) {
          .scene-menu {
            width: var(--card-width-menu);
            height: var(--card-height-menu);
            bottom: 20px;
          }

          .card.menu-card {
            width: var(--card-width-menu);
            height: var(--card-height-menu);
            font-size: 30px;
          }

          .score-total {
            width: 80px;
            height: 80px;
            font-size: 36px;
          }

          .line-score {
            width: 50px;
            height: 50px;
            font-size: 20px;
          }

          #scroll-hud-container,
          #player-a-hud-container {
            width: 25%;
          }
        }

        /* ======================================================= */
        /* === STYLES DES PASTILLES DE CONTRÔLE === */
        /* ======================================================= */

        .control-pill {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 1250;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
            font-size: 20px;
            font-family: 'Fredoka One', cursive;
            transition: transform 0.2s ease, opacity 0.3s ease;
            background-color: var(--counter-bg);
            border: 1px solid var(--border-dark);
            color: white;
            font-weight: bold;
            user-select: none;
        }
        .control-pill:hover {
           transform: scale(1.1);
        }

        .zoom-in-pill {
            background-color: rgba(55, 55,55, 0.85);
            border: 1px solid var(--border-dark);
            bottom: 50%;
            left: 60%;
            transform: translateX(-50%) scale(1);
            color: #333;
            z-index: 1300;
            display: none; /* Pastille de zoom rendue obsolète */
        }
        .zoom-in-pill:hover {
            transform: translateX(-50%) scale(1.1);
        }

        .paginate-pill {
            top: 95%;
            transform: translateY(-50%) scale(1);
            width: 40px;
            height: 40px;
            font-size: 18px;
            background-color: rgba(0, 0, 0, 0.6);
        }
        .paginate-pill:hover {
            transform: translateY(-50%) scale(1.15);
        }

        #paginate-left {
            left: -45px;
        }

        #paginate-right {
            right: -58px;
        }

        /* NOUVEAU: Pastille d'éjection de carte */
        #eject-card-pill {
            width: 50px;
            height: 50px;
            font-size: 42px;
            line-height: 1; /* Centre la flèche verticalement */
            background-color: rgba(0, 0, 0, 0.6); /* Bleu pour la différencier */
            position: absolute;
            top: 20%; /* Au-dessus du premier score de ligne (mêlée) */
            right: -90%; /* Alignée avec le score */
            transform: scale(1); /* Pour le hover */
        }
        #eject-card-pill:hover {
            transform: scale(1.15);
        }

        /* ======================================================= */
        /* === STYLES DE LA MODALE DE ZOOM === */
        /* ======================================================= */

        #card-zoom-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1500;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease-out;
            justify-content: center;
            align-items: center;
        }
        #card-zoom-modal.active {
            display: flex;
            opacity: 1;
        }

        #card-zoom-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        #card-zoom-content {
            position: relative;
            z-index: 1501;
        }

        .card.zoomed {
            width: 300px;
            height: 500px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.8);
            z-index: 1502;
            transition: all 0.3s ease-out;
            position: relative !important;
            transform: none !important;
            font-size: 40px;
            padding: 20px;
        }
        .card.zoomed .card-count {
            font-size: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
        }

        .close-zoom-pill {
            background-color: #E74C3C;
            color: white;
            font-size: 18px;
            position: absolute;
            top: -20px;
            right: -20px;
            width: 40px;
            height: 40px;
            border: 2px solid white;
            z-index: 1503;
        }

    </style>
</head>
<body>


    <div id="scroll-hud-container">
        <div class="score-hud-container">
            <div class="top-left">
                <div class="score-total" id="scoreTotalB">0</div>
                <div class="line-scores">
               <div class="line-score C_SIEGE_COLOR" id="scoreSiegeB">0</div>

                     <div class="line-score C_RANGE_COLOR" id="scoreRangeB">0</div>
                    <div class="line-score C_MELEE_COLOR" id="scoreMeleeB">0</div>

                </div>
                </div>
            </div>
    </div>
    
    <div class="card-counter">0</div>


    <div id="player-a-hud-container">
        <div class="score-hud-container">
            <div id="player-a-group">
                <div class="bottom-left">
                      <div class="line-scores">
                         <div class="line-score C_MELEE_COLOR" id="scoreMeleeA">0</div>
                        <div class="line-score C_RANGE_COLOR" id="scoreRangeA">0</div>
                        <div class="line-score C_SIEGE_COLOR" id="scoreSiegeA">0</div>
                    </div>
                    <div class="score-total" id="scoreTotalA">0</div>

                </div>
            </div>
        </div>
    </div>

    <div class="scene-menu" id="menu-fixed">
        
        <div class="control-pill paginate-pill" id="paginate-left">❮</div>
        <div class="control-pill paginate-pill" id="paginate-right">❯</div>
        <div class="card-stack"></div>
        <div class="toggle-indicator" id="colorToggle"></div>
        <div class="control-pill" id="eject-card-pill">↑</div>
                       
    </div>

    <div id="card-zoom-modal">
        <div id="card-zoom-backdrop"></div>
        <div id="card-zoom-content">
        </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script>
        /* ======================================================= */
        /* === LOGIQUE THREE.JS (Plateau 3D) [INCHANGÉE] === */
        /* ======================================================= */
        const cardWidth = 350;
        const cardHeight = 400;
        const halfCardHeight = cardHeight / 2;
        const gap = 1;
        const PLATEAU_Z = 0;
        const CARD_SPACING = 20;
        const ROW_SPACING = cardHeight + 40;

        const VERTICAL_OFFSET_10_PERCENT = cardHeight * 0.1;
        const CARD_PLACEMENT_SAFE_FACTOR = 0.8;

        let fixedPlacementRange = 0;
        const initialPlacementCenter = 0;

        let minXBoundary = 0;
        let maxXBoundary = 0;
        const BOARD_X_MARGIN = 400;
        let boardWidth = 1000;

        let scene, camera, renderer;
        let boardGroup, progressBar3D, boardArea, scoreFillA, boardBorder;
        let a_cards = [];
        let b_cards = [];

        let scoreA = 0, scoreB = 0;
        let scoreA_melee = 0, scoreA_range = 0, scoreA_siege = 0;
        let scoreB_melee = 0, scoreB_range = 0, scoreB_siege = 0;

        let a_card_positions = [];
        let b_card_positions = [];

        let currentBarY = 0;

        const cardTypes = ['melee', 'range', 'siege'];
        const BOARD_TOTAL_HEIGHT = 12000;

        const bottomY = -BOARD_TOTAL_HEIGHT / 2;
        const topY = BOARD_TOTAL_HEIGHT / 2;
        const margin = 100;

        const defaultCameraDistance = 2000;
        const minCameraDistance = 1000;
        const maxCameraDistance = 3000;
        let cameraDistance = defaultCameraDistance * 1.2;

        const FOUNDATION_COLOR_LIGHT = '#444444';
        const SCORE_FILL_COLOR_A = 'rgba(0, 0, 0, 0.2)';

        const ENTRY_OFFSET = 2000;
        const STACK_FACTOR = 0.5;

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let panFactor = 1;
        let initialPinchDistance = null;

        function getVisibleSceneWidth() {
            const distance = camera.position.z;
            const vFOV = camera.fov * Math.PI / 180;
            const viewHeight = 2 * Math.tan(vFOV / 2) * distance;
            const aspectRatio = camera.aspect;
            return viewHeight * aspectRatio;
        }

        function updateBoardDimensions(newBoardWidth, newBoardCenterX, animate = true) {
            if (newBoardWidth < 1000) newBoardWidth = 1000;

            boardWidth = newBoardWidth;
            const duration = animate ? 1 : 0;

            gsap.to(boardGroup.position, { x: -newBoardCenterX, duration: duration, ease: "power2.out" });

            const elementsToResize = [boardBorder.element.style, boardArea.element.style, progressBar3D.element.style, scoreFillA.element.style];
            elementsToResize.forEach(style => {
                gsap.to(style, { width: `${boardWidth}px`, duration: duration, ease: "power2.out" });
            });
        }

        function init() {
            scene = new THREE.Scene();
            currentBarY = 0;

            camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 0, cameraDistance);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.CSS3DRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = 0;
            renderer.domElement.style.touchAction = 'none';
            renderer.domElement.style.zIndex = '1';
            document.body.appendChild(renderer.domElement);

            boardGroup = new THREE.Group();
            scene.add(boardGroup);

            boardWidth = getVisibleSceneWidth() * 1.5;

            const borderDiv = document.createElement('div');
            borderDiv.className = 'border-area';
            borderDiv.style.width = `${boardWidth}px`;
            borderDiv.style.height = `${BOARD_TOTAL_HEIGHT}px`;
            borderDiv.style.backgroundColor = 'transparent';
            boardBorder = new THREE.CSS3DObject(borderDiv);
            boardBorder.position.set(0, -500, -50);
            boardGroup.add(boardBorder);

            const areaDiv = document.createElement('div');
            areaDiv.className = 'board-area';
            areaDiv.style.width = `${boardWidth}px`;
            areaDiv.style.height = `${BOARD_TOTAL_HEIGHT}px`;
            boardArea = new THREE.CSS3DObject(areaDiv);
            boardArea.position.set(0, 0, -45);
            boardGroup.add(boardArea);

            const scoreFillDivA = document.createElement('div');
            scoreFillDivA.className = 'score-fill-A';
            scoreFillDivA.style.width = `${boardWidth}px`;
            scoreFillDivA.style.backgroundColor = SCORE_FILL_COLOR_A;
            scoreFillDivA.style.opacity = '0';
            scoreFillA = new THREE.CSS3DObject(scoreFillDivA);
            scoreFillA.position.set(0, 0, -40);
            boardGroup.add(scoreFillA);

            const barDiv = document.createElement('div');
            barDiv.style.width = `${boardWidth}px`;
            barDiv.style.height = '22px';
            barDiv.style.background = `linear-gradient(90deg, #333333, #666666, #333333)`;
            barDiv.style.borderRadius = '16px';
            barDiv.style.boxShadow = `0 0 60px ${FOUNDATION_COLOR_LIGHT}, inset 0 0 20px rgba(255,255,255,0.1)`;
            barDiv.style.opacity = '0';
            progressBar3D = new THREE.CSS3DObject(barDiv);
            progressBar3D.position.set(0, 0, 20);
            boardGroup.add(progressBar3D);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            fixedPlacementRange = getVisibleSceneWidth() * CARD_PLACEMENT_SAFE_FACTOR;

            renderer.domElement.addEventListener('mousedown', handleMouseDown, false);
            renderer.domElement.addEventListener('mousemove', handleMouseMove, false);
            window.addEventListener('mouseup', handleMouseUp, false);
            renderer.domElement.addEventListener('touchstart', handleTouchStartPan, false);
            renderer.domElement.addEventListener('touchmove', handleTouchMovePan, false);
            renderer.domElement.addEventListener('touchend', handleTouchEndPan, false);
            window.addEventListener('wheel', handleMouseWheel, { passive: false });
            window.addEventListener('touchstart', handleTouchStartPinch, { passive: false });
            window.addEventListener('touchmove', handleTouchMovePinch, { passive: false });
            window.addEventListener('touchend', handleTouchEndPinch, { passive: false });

            updatePanFactor();
            updateBar(currentBarY, false);
            initializeMenu();
            animate();
            startGame();
        }

        function updatePanFactor() {
            const vFOV = camera.fov * Math.PI / 180;
            const height = 2 * Math.tan(vFOV / 2) * camera.position.z;
            panFactor = height / window.innerHeight;
        }

        function panCamera(deltaX, deltaY) {
            camera.position.x -= deltaX * panFactor;
            camera.position.y += deltaY * panFactor;
            camera.lookAt(camera.position.x, camera.position.y, 0);
        }

        function handleMouseDown(event) {
            if (event.button === 0 && !isDraggingMenu) {
                isDragging = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
                event.preventDefault();
            }
        }

        function handleMouseMove(event) {
            if (!isDragging || isDraggingMenu) return;
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            panCamera(deltaX, deltaY);
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function handleMouseUp() { isDragging = false; }

        function handleTouchStartPan(event) {
            if (event.touches.length === 1 && !isDraggingMenu) {
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
                event.stopPropagation();
            }
        }

        function handleTouchMovePan(event) {
            if (isDragging && event.touches.length === 1 && !isDraggingMenu) {
                event.preventDefault();
                event.stopPropagation();
                const deltaX = event.touches[0].clientX - previousMousePosition.x;
                const deltaY = event.touches[0].clientY - previousMousePosition.y;
                panCamera(deltaX, deltaY);
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function handleTouchEndPan(event) {
            if (event.touches.length === 0) isDragging = false;
        }

        function handleMouseWheel(event) {
            event.preventDefault();
            const zoomSpeed = 200;
            const zoomAmount = event.deltaY > 0 ? zoomSpeed : -zoomSpeed;
            updateCameraDistance(camera.position.z + zoomAmount);
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function handleTouchStartPinch(event) {
            if (event.touches.length === 2 && !isDraggingMenu) {
                initialPinchDistance = getPinchDistance(event.touches);
            }
            isDragging = false;
        }

        function handleTouchMovePinch(event) {
            if (event.touches.length === 2 && !isDraggingMenu) {
                event.preventDefault();
                const currentPinchDistance = getPinchDistance(event.touches);
                if (initialPinchDistance) {
                    const delta = currentPinchDistance - initialPinchDistance;
                    updateCameraDistance(camera.position.z - delta * 5);
                    initialPinchDistance = currentPinchDistance;
                }
            }
        }

        function handleTouchEndPinch(event) {
            initialPinchDistance = null;
            if (event.touches.length === 1 && !isDraggingMenu) {
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function updateCameraDistance(newZ) {
            const clampedZ = Math.max(minCameraDistance, Math.min(maxCameraDistance, newZ));
            camera.position.z = clampedZ;
            cameraDistance = clampedZ;
            updatePanFactor();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function createCard(player) {
            const power = Math.floor(Math.random() * 10) + 1;
            const type = cardTypes[Math.floor(Math.random() * cardTypes.length)];

            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${player} ${type}`;
            cardDiv.innerHTML = `<div class="card-type-label">${type === 'melee' ? 'Mêlée' : type === 'range' ? 'Distance' : 'Siège'}</div><div class="card-power">${power}</div>`;
            cardDiv.style.transform = 'translateZ(10px)';
            cardDiv.style.opacity = '0';

            const cardObj = new THREE.CSS3DObject(cardDiv);
            cardObj.position.set(0, 0, PLATEAU_Z);
            cardObj.scale.set(0.1, 0.1, 0.1);

            return { obj: cardObj, power, type, element: cardDiv };
        }

        function getNextAvailableX(teamPositions) {
            const CARD_FULL_WIDTH = cardWidth + CARD_SPACING;
            const maxCardsPerRow = Math.floor(fixedPlacementRange / CARD_FULL_WIDTH);
            if (maxCardsPerRow < 1) return initialPlacementCenter;

            const cardIndex = teamPositions.length;
            const rowCardIndex = cardIndex % maxCardsPerRow;
            if (rowCardIndex === 0) return initialPlacementCenter;

            const offsetMultiplier = Math.ceil(rowCardIndex / 2);
            const direction = (rowCardIndex % 2 !== 0) ? 1 : -1;
            return initialPlacementCenter + (direction * offsetMultiplier * CARD_FULL_WIDTH);
        }

        function updateCardsVerticalPositions(barY) {
            const cardTargets = [];
            const CARD_FULL_WIDTH = cardWidth + CARD_SPACING;
            const maxCardsPerRow = Math.floor(fixedPlacementRange / CARD_FULL_WIDTH);
            if (maxCardsPerRow < 1) return [];

            const halfCardHeightWithGap = halfCardHeight + gap;

            let base_Y_A = barY - halfCardHeightWithGap;
            a_cards.forEach((card, i) => {
                const row = Math.floor(i / maxCardsPerRow);
                const rowCardIndex = i % maxCardsPerRow;
                const targetY = base_Y_A - (row * ROW_SPACING) - (rowCardIndex * VERTICAL_OFFSET_10_PERCENT);
                cardTargets.push({ card: card.obj.position, y: targetY });
                card.obj.position.x = a_card_positions[i];
                card.obj.position.z = PLATEAU_Z + i * 5;
                card.element.classList[targetY - halfCardHeight > bottomY ? 'remove' : 'add']('off-board');
            });

            let base_Y_B = barY + halfCardHeightWithGap;
            b_cards.forEach((card, i) => {
                const row = Math.floor(i / maxCardsPerRow);
                const rowCardIndex = i % maxCardsPerRow;
                const targetY = base_Y_B + (row * ROW_SPACING) + (rowCardIndex * VERTICAL_OFFSET_10_PERCENT);
                cardTargets.push({ card: card.obj.position, y: targetY });
                card.obj.position.x = b_card_positions[i];
                card.obj.position.z = PLATEAU_Z + i * 5;
                card.element.classList[targetY + halfCardHeight < topY ? 'remove' : 'add']('off-board');
            });
            return cardTargets;
        }

        function updateBar(barY, animate = true) {
            currentBarY = barY;
            const duration = animate ? 1 : 0;
            gsap.to(progressBar3D.position, { y: barY, duration: duration, ease: "power2.out" });

            const heightA = barY - bottomY;
            const centerA = bottomY + heightA / 2;
            gsap.to(scoreFillA.element.style, { height: `${heightA}px`, duration: duration, ease: "power2.out" });
            gsap.to(scoreFillA.position, { y: centerA, duration: duration, ease: "power2.out" });

            gsap.to(scoreFillA.element.style, { opacity: (animate || heightA > 0) ? 1 : 0, duration: 0.5 });

            document.getElementById('scoreTotalA').textContent = scoreA;
            document.getElementById('scoreMeleeA').textContent = scoreA_melee;
            document.getElementById('scoreRangeA').textContent = scoreA_range;
            document.getElementById('scoreSiegeA').textContent = scoreA_siege;

            document.getElementById('scoreTotalB').textContent = scoreB;
            document.getElementById('scoreMeleeB').textContent = scoreB_melee;
            document.getElementById('scoreRangeB').textContent = scoreB_range;
            document.getElementById('scoreSiegeB').textContent = scoreB_siege;
        }

        async function addTurn(turn) {
            const isPlayerA = turn % 2 === 0;
            const player = isPlayerA ? 'A' : 'B';
            const newCard = createCard(player);
            const teamPositions = isPlayerA ? a_card_positions : b_card_positions;
            const newX = getNextAvailableX(teamPositions);

            if (isPlayerA) {
                a_card_positions.push(newX);
                a_cards.push(newCard);
                scoreA += newCard.power;
                if (newCard.type === 'melee') scoreA_melee += newCard.power;
                else if (newCard.type === 'range') scoreA_range += newCard.power;
                else scoreA_siege += newCard.power;
            } else {
                b_card_positions.push(newX);
                b_cards.push(newCard);
                scoreB += newCard.power;
                if (newCard.type === 'melee') scoreB_melee += newCard.power;
                else if (newCard.type === 'range') scoreB_range += newCard.power;
                else scoreB_siege += newCard.power;
            }

            const cardLeft = newX - cardWidth / 2;
            const cardRight = newX + cardWidth / 2;
            minXBoundary = Math.min(minXBoundary, cardLeft);
            maxXBoundary = Math.max(maxXBoundary, cardRight);
            const requiredWidth = maxXBoundary - minXBoundary + BOARD_X_MARGIN * 2;
            if (requiredWidth > boardWidth + 10) {
                updateBoardDimensions(requiredWidth, (minXBoundary + maxXBoundary) / 2, true);
            }

            const total = scoreA + scoreB;
            const newBarY = bottomY + (scoreA / total) * BOARD_TOTAL_HEIGHT;
            const entryY = isPlayerA ? newBarY - ENTRY_OFFSET : newBarY + ENTRY_OFFSET;
            const newCardIndex = (isPlayerA ? a_cards.length : b_cards.length) - 1;
            newCard.obj.position.set(newX, entryY, PLATEAU_Z + newCardIndex * 5);
            boardGroup.add(newCard.obj);

            const cardTargets = updateCardsVerticalPositions(newBarY);
            const mainTimeline = gsap.timeline();

            if (turn === 1) {
                updateBar(topY, false);
                currentBarY = topY;
                progressBar3D.element.style.opacity = '1';
                scoreFillA.element.style.opacity = '1';
            }

            updateBar(newBarY, true);

            const newCardTarget = cardTargets.find(t => t.card === newCard.obj.position);
            mainTimeline.to(newCard.obj.position, { y: newCardTarget.y, duration: 1.2, ease: "power2.out" }, 0);
            mainTimeline.fromTo(newCard.obj.scale, { x: 0.1, y: 0.1, z: 0.1 }, { x: 1, y: 1, z: 1, duration: 1.2, ease: "back.out(1.7)" }, 0);
            mainTimeline.to(newCard.element, { opacity: 1, duration: 0.8 }, 0.4);

            cardTargets.filter(t => t.card !== newCard.obj.position).forEach(target => {
                 mainTimeline.to(target.card, { y: target.y, duration: 1, ease: "power2.out"}, 0.1);
            });

            await new Promise(resolve => mainTimeline.eventCallback("onComplete", resolve));
            await new Promise(resolve => setTimeout(resolve, 200));
        }

        async function startGame() {
            const firstCard = createCard('A');
            const firstX = getNextAvailableX([]);
            a_card_positions.push(firstX);
            a_cards.push(firstCard);
            scoreA += firstCard.power;
            if (firstCard.type === 'melee') scoreA_melee += firstCard.power;
            else if (firstCard.type === 'range') scoreA_range += firstCard.power;
            else scoreA_siege += firstCard.power;

            minXBoundary = firstX - cardWidth / 2;
            maxXBoundary = firstX + cardWidth / 2;
            updateBoardDimensions(maxXBoundary - minXBoundary + BOARD_X_MARGIN * 2, (minXBoundary + maxXBoundary) / 2, false);

            const initialBarY = topY;
            const entryY = initialBarY - ENTRY_OFFSET;
            firstCard.obj.position.set(firstX, entryY, PLATEAU_Z);
            boardGroup.add(firstCard.obj);

            const cardTargets = updateCardsVerticalPositions(initialBarY);
            const firstCardTarget = cardTargets.find(t => t.card === firstCard.obj.position);

            const initialTimeline = gsap.timeline();
            updateBar(initialBarY, true);
            initialTimeline.to(firstCard.obj.position, { y: firstCardTarget.y, duration: 1.2, ease: "power2.out" }, 0);
            initialTimeline.fromTo(firstCard.obj.scale, { x: 0.1, y: 0.1, z: 0.1 }, { x: 1, y: 1, z: 1, duration: 1.2, ease: "back.out(1.7)" }, 0);
            initialTimeline.to(firstCard.element, { opacity: 1, duration: 0.8 }, 0.4);

            await new Promise(resolve => initialTimeline.eventCallback("onComplete", resolve));
            await new Promise(resolve => setTimeout(resolve, 1000));

            for (let turn = 1; turn < 120; turn++) {
                await addTurn(turn);
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            fixedPlacementRange = getVisibleSceneWidth() * CARD_PLACEMENT_SAFE_FACTOR;
            const requiredWidth = maxXBoundary - minXBoundary + BOARD_X_MARGIN * 2;
            updateBoardDimensions(requiredWidth, (minXBoundary + maxXBoundary) / 2, false);
            updateBar(currentBarY, false);
            updateCardsVerticalPositions(currentBarY);
            updatePanFactor();
        });

        /* ======================================================= */
        /* === LOGIQUE DE PILE (Menu 100% CSS) === */
        /* ======================================================= */
        const stackEl = document.querySelector('.card-stack');
        const counterEl = document.querySelector('.card-counter');
        const toggleEl = document.getElementById('colorToggle');
        const paginateLeftBtn = document.getElementById('paginate-left');
        const paginateRightBtn = document.getElementById('paginate-right');
        const ejectCardPill = document.getElementById('eject-card-pill');

        const COLORS = {
            green: '#bff5bf', blue: '#c9e5ff', orange: '#ffe5b0',
            white: '#ffffff', darkgrey: '#777777'
        };

        const CARD_COUNT_MENU = 12;
        const Z_GAP = 1;
        const SWIPE_THRESHOLD = 80;

        let topCard = null;
        let isDraggingMenu = false;
        let startX = 0, startY = 0;
        let initialCardRect = null;
        let currentToggleColor = null;
        let togglePair = null;

        // NOUVELLES VARIABLES POUR LA DÉTECTION DE CLIC/TAP
        let dragStartTime = 0;
        const dragDistanceThreshold = 10; // Pixels (marge d'erreur)
        const dragTimeThreshold = 250; // Millisecondes (temps max pour un "clic")

        function randomColorGroup(i) {
            const groups = ['green','blue','orange','white','darkgrey'];
            return groups[i % groups.length];
        }

        function initializeMenu() {
            stackEl.innerHTML = '';
            for (let i = 0; i < CARD_COUNT_MENU; i++) {
                const group = randomColorGroup(i);
                const card = document.createElement('div');
                card.className = 'card menu-card';
                card.dataset.group = group;
                card.style.backgroundColor = COLORS[group];
                const icon = group === 'orange' ? '🔥' : group === 'blue' ? '💧' : group === 'green' ? '🌿' : group === 'darkgrey' ? '⬛' : '⚪';
                card.innerHTML = `<div class="card-icon">${icon}</div><div class="card-count">${group}</div>`;
                stackEl.appendChild(card);
            }
            updateTopCardReference();
            updateCardIndices();
            updateCounter();

            paginateLeftBtn.addEventListener('click', () => handleCycleReverse(true));
            paginateRightBtn.addEventListener('click', () => handleCycle(true, false));
            ejectCardPill.addEventListener('click', handleEject);
        }

        function updateTopCardReference() {
            if (topCard) {
                topCard.removeEventListener('mousedown', startDragMenu);
                topCard.removeEventListener('touchstart', startDragMenu);
            }
            topCard = stackEl.firstElementChild;
            const hasCards = !!topCard;

            toggleEl.style.display = 'none';
            // zoomInPill.style.display = hasCards ? 'flex' : 'none'; // Rendu obsolète
            paginateLeftBtn.style.display = hasCards ? 'flex' : 'none';
            paginateRightBtn.style.display = hasCards ? 'flex' : 'none';
            ejectCardPill.style.display = hasCards ? 'flex' : 'none';

            if (!hasCards) return;

            topCard.removeAttribute('data-is-toggled');
            topCard.addEventListener('mousedown', startDragMenu);
            topCard.addEventListener('touchstart', startDragMenu);

            if (topCard.dataset.group === 'white') {
                togglePair = { left: 'green', right: 'blue' };
                showToggle();
            } else if (topCard.dataset.group === 'darkgrey') {
                togglePair = { left: 'green', right: 'orange' };
                showToggle();
            }
        }

        function showToggle() {
            toggleEl.style.display = 'flex';
            toggleEl.style.background = `linear-gradient(90deg, ${COLORS[togglePair.left]} 50%, ${COLORS[togglePair.right]} 50%)`;
        }

        function updateCounter() {
            counterEl.textContent = stackEl.children.length;
        }

        function updateCardIndices() {
            Array.from(stackEl.children).forEach((card, index) => {
                card.style.transform = `translateZ(${-index * Z_GAP}px)`;
                card.style.color = 'var(--text-dark)';
                card.style.transition = 'transform 0.25s ease-out, box-shadow 0.25s ease-out, background-color 0.3s ease';
            });
        }

        function bounceStack(axis = 'x') {
            const className = `bounce-${axis}`;
            stackEl.classList.add(className);
            setTimeout(() => {
                stackEl.classList.remove(className);
                stackEl.style.transform = 'translate(-50%, -50%)';
            }, 250);
        }

        function startDragMenu(e) {
            if (!topCard || isDraggingMenu) return;
            isDraggingMenu = true;
            
            dragStartTime = Date.now(); // NOUVEAU: Enregistrer le temps de départ
            
            const client = e.touches ? e.touches[0] : e;
            startX = client.clientX;
            startY = client.clientY;

            initialCardRect = topCard.getBoundingClientRect();
            topCard.style.left = `${initialCardRect.left}px`;
            topCard.style.top = `${initialCardRect.top}px`;

            stackEl.removeChild(topCard);
            document.body.appendChild(topCard);
            topCard.classList.add('is-dragging', 'detached');

            document.addEventListener('mousemove', dragMenu);
            document.addEventListener('mouseup', endDragMenu);
            document.addEventListener('touchmove', dragMenu, { passive: false });
            document.addEventListener('touchend', endDragMenu);
        }

        function dragMenu(e) {
            if (!isDraggingMenu) return;
            const client = e.touches ? e.touches[0] : e;
            const currentX = client.clientX - startX;
            const currentY = client.clientY - startY;
            const rotation = currentX / 20;

            topCard.style.left = `${initialCardRect.left + currentX}px`;
            topCard.style.top = `${initialCardRect.top + currentY}px`;
            topCard.style.transform = `rotateZ(${rotation * 0.3}deg)`;

            const absX = Math.abs(currentX), absY = Math.abs(currentY);
            const cardGroup = topCard.dataset.group;
            const isSpecialCard = cardGroup === 'white' || cardGroup === 'darkgrey';
            const isToggledToNewColor = isSpecialCard && topCard.dataset.isToggled === 'true';

            const isPotentialRemoval = absY > SWIPE_THRESHOLD && currentY < 0 && absY >= absX && (!isSpecialCard || isToggledToNewColor);
            topCard.classList.toggle('highlight-halo', isPotentialRemoval);
            topCard.style.color = isPotentialRemoval ? topCard.style.backgroundColor : 'var(--text-dark)';

            const followerCards = Array.from(stackEl.children);
            followerCards.forEach((card, index) => {
                const followFactor = Math.max(0.05, 0.4 - (index * 0.1));
                const offsetX = currentX * followFactor * 0.3;
                const offsetY = currentY * followFactor * 0.3;
                const offsetRotationZ = currentX * followFactor * 0.005;
                const baseZ = -index * Z_GAP;
                card.style.transform = `translateX(${offsetX}px) translateY(${offsetY}px) translateZ(${baseZ}px) rotateZ(${offsetRotationZ}deg)`;
                card.style.transition = 'transform 0.05s linear';
            });

            if (e.cancelable) e.preventDefault();
        }

        // --- FONCTION endDragMenu() ENTIÈREMENT MISE À JOUR ---
        function endDragMenu() {
            if (!isDraggingMenu) return;
            isDraggingMenu = false;

            // NOUVEAU: Calculer la durée et la distance
            const dragEndTime = Date.now();
            const dragDuration = dragEndTime - dragStartTime;
            const currentX = topCard.getBoundingClientRect().left - initialCardRect.left;
            const currentY = topCard.getBoundingClientRect().top - initialCardRect.top;
            const dragDistance = Math.sqrt(currentX * currentX + currentY * currentY);

            // --- Nettoyage (se produit dans tous les cas) ---
            topCard.classList.remove('is-dragging', 'detached', 'highlight-halo');
            topCard.style.color = 'var(--text-dark)';

            document.body.removeChild(topCard);
            stackEl.insertBefore(topCard, stackEl.firstChild);

            topCard.style.left = '';
            topCard.style.top = '';
            topCard.style.transition = 'transform 0.25s ease-out, box-shadow 0.25s ease-out, background-color 0.3s ease';
            
            // NOUVEAU: Vérifier si c'est un clic
            if (dragDuration < dragTimeThreshold && dragDistance < dragDistanceThreshold) {
                // C'EST UN CLIC: Zoomer
                handleZoomIn();
                // Réinitialiser la transformation (au cas où il y aurait un micro-mouvement)
                topCard.style.transform = `translateZ(0px)`;
                // Assure que les cartes en dessous sont bien alignées
                updateCardIndices(); 
            } else {
                // C'EST UN DRAG: Logique de swipe/cycle existante
                topCard.style.transform = `translateX(${currentX}px) translateY(${currentY}px) translateZ(0px)`;
                
                const absX = Math.abs(currentX), absY = Math.abs(currentY);
                const cardGroup = topCard.dataset.group;
                const isSpecialCard = cardGroup === 'white' || cardGroup === 'darkgrey';
                const isToggledToNewColor = isSpecialCard && topCard.dataset.isToggled === 'true';

                let actionTaken = false;
                if (absY > SWIPE_THRESHOLD && currentY < 0 && absY >= absX) {
                    if (isSpecialCard && !isToggledToNewColor) {
                        handleCycle(false, true);
                    } else {
                        handleRemoval('up');
                    }
                    actionTaken = true;
                }

                if (!actionTaken) {
                    let bounceX = absX > SWIPE_THRESHOLD && absX > absY;
                    let bounceY = absY > SWIPE_THRESHOLD && absY >= absX;
                    if (!bounceX && !bounceY && (absX > 0 || absY > 0)) {
                        if (absX > absY) bounceX = true; else bounceY = true;
                    }
                    handleCycle(bounceX, bounceY);
                }
            }
            
            // --- Nettoyage des listeners (se produit dans tous les cas) ---
            document.removeEventListener('mousemove', dragMenu);
            document.removeEventListener('mouseup', endDragMenu);
            document.removeEventListener('touchmove', dragMenu);
            document.removeEventListener('touchend', endDragMenu);
        }
        // --- FIN DE LA FONCTION endDragMenu() MISE À JOUR ---


        function handleCycle(bounceX = false, bounceY = false) {
            if (!topCard) return;
            topCard.style.transform = `translateZ(0px)`;
            topCard.classList.add('cycle-out');
            if (bounceX) bounceStack('x');
            if (bounceY) bounceStack('y');

            setTimeout(() => {
                topCard.classList.remove('cycle-out');
                stackEl.removeChild(topCard);
                resetSpecialCard(topCard);
                stackEl.appendChild(topCard);
                updateCardIndices();
                updateTopCardReference();
            }, 250);
        }

        function handleCycleReverse(bounceX = false) {
            if (stackEl.children.length < 2) return;
            const lastCard = stackEl.lastElementChild;
            lastCard.classList.add('cycle-out');
            if (bounceX) bounceStack('x');

            setTimeout(() => {
                lastCard.classList.remove('cycle-out');
                stackEl.removeChild(lastCard);
                resetSpecialCard(lastCard);
                stackEl.insertBefore(lastCard, stackEl.firstChild);
                updateCardIndices();
                updateTopCardReference();
            }, 250);
        }
        
        // NOUVEAU: Logique pour l'éjection de la carte
        function handleEject() {
            if (!topCard) return;

            // La carte doit être "toggled" pour être éjectée si c'est une carte spéciale
            const cardGroup = topCard.dataset.group;
            const isSpecialCard = cardGroup === 'white' || cardGroup === 'darkgrey';
            const isToggled = topCard.dataset.isToggled === 'true';

            if (isSpecialCard && !isToggled) {
                bounceStack('y'); // Rebond pour indiquer une action non permise
                return;
            }

            const cardToEject = topCard;

            // Animation avec GSAP
            gsap.to(cardToEject, {
                translateZ: 150, // Avance la carte
                duration: 0.2,
                ease: 'power2.out',
                onComplete: () => {
                    // Une fois avancée, anime vers le haut
                    gsap.to(cardToEject, {
                        y: -400, // Bouge vers le haut
                        duration: 0.3,
                        ease: 'power2.in'
                    });
                }
            });
            
            // Ajoute la classe pour le fade out et gère le retrait
            cardToEject.classList.add('eject-forward');
            bounceStack('y');

            setTimeout(() => {
                if (stackEl.contains(cardToEject)) {
                    stackEl.removeChild(cardToEject);
                }
                updateCardIndices();
                updateCounter();
                updateTopCardReference();
                if (stackEl.children.length === 0) setTimeout(initializeMenu, 500);
            }, 400); // Délai légèrement ajusté pour l'animation
        }


        function handleRemoval(direction) {
            const removeClass = `remove-${direction}`;
            topCard.classList.add(removeClass);
            bounceStack(direction === 'up' ? 'y' : 'x');
            setTimeout(() => {
                if (stackEl.contains(topCard)) stackEl.removeChild(topCard);
                updateCardIndices();
                updateCounter();
                updateTopCardReference();
                if (stackEl.children.length === 0) setTimeout(initializeMenu, 500);
            }, 300);
        }

        function resetSpecialCard(card) {
            if (card.dataset.group === 'white' || card.dataset.group === 'darkgrey') {
                card.style.backgroundColor = COLORS[card.dataset.group];
                const icon = card.dataset.group === 'white' ? '⚪' : '⬛';
                card.innerHTML = `<div class="card-icon">${icon}</div><div class="card-count">${card.dataset.group}</div>`;
                card.removeAttribute('data-is-toggled');
            }
             card.style.transform = '';
        }

        toggleEl.addEventListener('click', () => {
            if (!topCard || !togglePair) return;
            currentToggleColor = (currentToggleColor === togglePair.left) ? togglePair.right : togglePair.left;
            const icon = currentToggleColor === 'green' ? '🌿' : currentToggleColor === 'blue' ? '💧' : '🔥';
            topCard.style.backgroundColor = COLORS[currentToggleColor];
            topCard.innerHTML = `<div class="card-icon">${icon}</div><div class="card-count">teinte: ${currentToggleColor}</div>`;
            topCard.dataset.isToggled = 'true';
        });

        /* ======================================================= */
        /* === LOGIQUE DE ZOOM === */
        /* ======================================================= */
        const zoomInPill = document.getElementById('zoom-in-pill'); // Reste déclaré, mais n'est plus utilisé
        const zoomModal = document.getElementById('card-zoom-modal');
        const zoomContent = document.getElementById('card-zoom-content');
        const closeZoomBtn = document.getElementById('close-zoom-btn');

        function handleZoomIn() {
            if (!topCard) return;
            const zoomedCard = topCard.cloneNode(true);
            zoomedCard.id = 'zoomed-card-instance';
            zoomedCard.classList.remove('menu-card', 'detached', 'is-dragging', 'highlight-halo');
            zoomedCard.classList.add('zoomed');
            zoomContent.appendChild(zoomedCard);
            zoomModal.classList.add('active');
        }

        function handleZoomOut() {
            const currentZoomedCard = document.getElementById('zoomed-card-instance');
            if (currentZoomedCard) zoomContent.removeChild(currentZoomedCard);
            zoomModal.classList.remove('active');
        }

        document.addEventListener('DOMContentLoaded', () => {
            // if (zoomInPill) zoomInPill.addEventListener('click', handleZoomIn); // Supprimé car la pastille est obsolète
            if (closeZoomBtn) closeZoomBtn.addEventListener('click', handleZoomOut);
            const backdrop = document.getElementById('card-zoom-backdrop');
            if (backdrop) backdrop.addEventListener('click', handleZoomOut);
        });

        window.addEventListener('load', init);
    </script>
</body>
</html>
