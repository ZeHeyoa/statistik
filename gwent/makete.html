<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gwent CSS3D Demo - Style Stacklands (Pan & Zoom)</title>
    <style>
        /* CONSTANTES DE COULEURS POUR LES LIGNES (Simplifiées et vives) */
        
        /* Mêlée : Vert POMME VIF */
        .C_MELEE_COLOR { background-color: #A8E61D; color: #333; } 
        .C_MELEE_DARK { background-color: #618A1D; } 
        
        /* Distance : Jaune VIF */
        .C_RANGE_COLOR { background-color: #FFD700; color: #333; } 
        .C_RANGE_DARK { background-color: #CCAA00; } 
        
        /* Siège : Bleu PÂLE (pour le contraste et l'effet "technologique") */
        .C_SIEGE_COLOR { background-color: #B0E0E6; color: #333; } 
        .C_SIEGE_DARK { background-color: #6A8D93; } 
        
        /* BASE & BACKGROUND */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #C7D8C2; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            perspective: 1000px;
            touch-action: none; 
        }
        
        /* UI SCORE */
        .ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #d1b453;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #7800ff;
            box-shadow: 0 0 10px #7800ff;
        }
        
        /* CARTES (Style Stacklands : Carré et Plat) */
        .card { 
            width: 150px;
            height: 180px; 
            border: 2px solid rgba(0,0,0,0.5); 
            border-radius: 10px; 
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3); 
            display: flex;
            flex-direction: column;
            justify-content: space-between; 
            align-items: center;
            font-size: 40px; 
            font-weight: bold;
            text-shadow: none;
            cursor: pointer;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            position: relative;
            overflow: hidden;
            transition: opacity 0.3s ease;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
        }

        /* Effet de brillance au survol (Stacklands) */
        .card:hover {
            transform: translateZ(15px);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 2px 2px 4px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        /* Contenu de la carte */
        .card-power {
            font-size: 60px;
            line-height: 1;
            margin-bottom: 5px;
            z-index: 2;
        }

        .card-type-label {
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
            z-index: 2;
        }

        /* Application des couleurs de LIGNE (Fonds de carte) */
        .card.melee { background-color: #A8E61D; } 
        .card.range { background-color: #FFD700; } 
        .card.siege { background-color: #B0E0E6; } 

        .card.melee .card-power, .card.range .card-power, .card.siege .card-power {
            color: #333; 
            text-shadow: 1px 1px 0 rgba(255,255,255,0.3);
        }

        .card.off-board {
            opacity: 0.2;
            filter: grayscale(80%);
            border-color: #333333;
            box-shadow: none;
        }
        
        /* PROGRESS BAR UI */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 200px; 
            height: 4px; 
            background: rgba(120, 0, 255, 0.3);
            border-radius: 4px; 
            z-index: 100;
        }
        .progress-fill {
            height: 50%;
            background: #00ffff;
            border-radius: 4px;
            transition: height 1s ease;
        }
        
        /* Style pour la zone totale du plateau (fond bleu) */
        .board-area {
            background: #AEEA9C; 
            overflow: auto;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.1); 
            opacity: 1;
        }
        
        /* Style pour la zone de remplissage du score A */
        .score-fill-A {
            /* IMPORTANT : Retrait de tout style de positionnement CSS */
            /* La position est gérée entièrement par Three.js */
        }
    </style>
</head>
<body>
    <div class="ui">
        <div>Joueur A: <span id="scoreA">0</span></div>
        <div>Joueur B: <span id="scoreB">0</span></div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script>
        // Constantes
        const cardWidth = 150; 
        const cardHeight = 180; 
        const halfCardHeight = cardHeight / 2;
        const gap = 10; 
        const PLATEAU_Z = 0;
        
        let scene, camera, renderer;
        let boardGroup, progressBar3D, boardArea, scoreFillA, boardBorder;
        let a_cards = [];
        let b_cards = [];
        let scoreA = 0;
        let scoreB = 0;
        let a_card_positions = [];
        let b_card_positions = [];
        let time = 0;
        
        let currentBarY = 0; 
        
        const cardTypes = ['melee', 'range', 'siege'];
        
        const BOARD_TOTAL_HEIGHT = 4400; 
        let boardWidth = 7200; 
        
        const bottomY = -BOARD_TOTAL_HEIGHT / 2; 
        const topY = BOARD_TOTAL_HEIGHT / 2;     
        const margin = 100; 
        
        // PARAMÈTRES DE LA CAMÉRA (Fixe et centrée)
        const defaultCameraDistance = 2000; 
        const minCameraDistance = 1000;
        const maxCameraDistance = 3000;
        let cameraDistance = defaultCameraDistance;
        
        // COULEUR POUR L'EFFET LUMINEUX DANS LA BARRE (MAINTENANT GRIS/NOIR)
        const FOUNDATION_COLOR_LIGHT = '#444444'; 
        
        const SCORE_FILL_COLOR_A = 'rgba(0, 0, 0, 0.2)'; 

        const ENTRY_OFFSET = 2000; 
        const STACK_FACTOR = 0.5; 

        // --- VARIABLES DE TRANSLATION (PANNING) ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let panFactor = 1; 

        // Variables pour le zoom tactile (pinch)
        let initialPinchDistance = null;
        
        function init() {
            scene = new THREE.Scene();
            
            currentBarY = 0; 

            camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 10000);
            
            camera.position.set(0, 0, cameraDistance); 
            camera.lookAt(0, 0, 0); 
            
            renderer = new THREE.CSS3DRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = 0;
            document.body.appendChild(renderer.domElement);

            boardGroup = new THREE.Group();
            scene.add(boardGroup);

            // 1. --- Zone de Bordure (La plus éloignée) ---
            const borderDiv = document.createElement('div');
            borderDiv.className = 'border-area';
            borderDiv.style.width = `${boardWidth}px`;
            borderDiv.style.height = `${BOARD_TOTAL_HEIGHT}px`;
            borderDiv.style.backgroundColor = 'transparent'; 
            borderDiv.style.border = '30px solid rgba(50, 50, 50, 0.8)'; 
            
            boardBorder = new THREE.CSS3DObject(borderDiv);
            boardBorder.position.set(0, -500, -50); 
            boardGroup.add(boardBorder);

            // 2. --- Plateau Total (Fond) ---
            const areaDiv = document.createElement('div');
            areaDiv.className = 'board-area';
            areaDiv.style.width = `${boardWidth}px`;
            areaDiv.style.height = `${BOARD_TOTAL_HEIGHT}px`;
            
            boardArea = new THREE.CSS3DObject(areaDiv);
            boardArea.position.set(0, 0, -50); 
            boardGroup.add(boardArea);
            
            // 3. --- Zone de remplissage du Score A (Blanc - Masque le fond) ---
            const scoreFillDivA = document.createElement('div');
            scoreFillDivA.className = 'score-fill-A';
            scoreFillDivA.style.width = `${boardWidth}px`;
            scoreFillDivA.style.backgroundColor = SCORE_FILL_COLOR_A;
            scoreFillDivA.style.boxShadow = `none`; 
            scoreFillDivA.style.opacity = '0'; 
            
            scoreFillA = new THREE.CSS3DObject(scoreFillDivA);
            scoreFillA.position.set(0, 0, 0); 
            boardGroup.add(scoreFillA);


            // 4. --- Barre de progression 3D (La plus proche) ---
            const barDiv = document.createElement('div');
            barDiv.style.width = `${boardWidth}px`;
            barDiv.style.height = '22px'; 
            barDiv.style.background = `linear-gradient(90deg, #333333, #666666, #333333)`; 
            barDiv.style.borderRadius = '16px';
            barDiv.style.boxShadow = `0 0 60px ${FOUNDATION_COLOR_LIGHT}, inset 0 0 20px rgba(255,255,255,0.1)`;
            barDiv.style.opacity = '0'; 
            progressBar3D = new THREE.CSS3DObject(barDiv);
            progressBar3D.position.set(0, 0, 20); 
            boardGroup.add(progressBar3D);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // --- AJOUT DES GESTIONNAIRES D'ÉVÉNEMENTS POUR LE PANNING ---
            renderer.domElement.addEventListener('mousedown', handleMouseDown, false);
            renderer.domElement.addEventListener('mousemove', handleMouseMove, false);
            window.addEventListener('mouseup', handleMouseUp, false); 
            
            renderer.domElement.addEventListener('touchstart', handleTouchStartPan, false);
            renderer.domElement.addEventListener('touchmove', handleTouchMovePan, false);
            renderer.domElement.addEventListener('touchend', handleTouchEndPan, false);
            
            // Gestionnaire de zoom (wheel)
            window.addEventListener('wheel', handleMouseWheel, { passive: false });
            
            // Gestionnaire de zoom (pinch)
            window.addEventListener('touchstart', handleTouchStartPinch, { passive: false });
            window.addEventListener('touchmove', handleTouchMovePinch, { passive: false });
            window.addEventListener('touchend', handleTouchEndPinch, { passive: false });
            
            updatePanFactor(); 
            
            updateBar(currentBarY, false);
            animate();
            startGame();
        }

        // --- UTILS POUR LA CONVERSION DE PIXELS EN UNITÉS 3D ---
        function updatePanFactor() {
            const vFOV = camera.fov * Math.PI / 180;
            const height = 2 * Math.tan(vFOV / 2) * camera.position.z;
            panFactor = height / window.innerHeight;
        }

        function panCamera(deltaX, deltaY) {
            camera.position.x -= deltaX * panFactor;
            camera.position.y += deltaY * panFactor;
            
            camera.lookAt(camera.position.x, camera.position.y, 0);
        }

        // --- GESTIONNAIRES DE PANNING (SOURIS) ---
        function handleMouseDown(event) {
            if (event.button === 0) { 
                isDragging = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
                event.preventDefault(); 
            }
        }

        function handleMouseMove(event) {
            if (!isDragging) return;
            
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            panCamera(deltaX, deltaY);

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function handleMouseUp() {
            isDragging = false;
        }
        
        // --- GESTIONNAIRES DE PANNING (TOUCHER) ---
        function handleTouchStartPan(event) {
            if (event.touches.length === 1) {
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function handleTouchMovePan(event) {
            if (isDragging && event.touches.length === 1) {
                event.preventDefault();
                
                const deltaX = event.touches[0].clientX - previousMousePosition.x;
                const deltaY = event.touches[0].clientY - previousMousePosition.y;

                panCamera(deltaX, deltaY);

                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function handleTouchEndPan() {
            if (event.touches.length === 0) {
                 isDragging = false;
            }
        }
        // -------------------------------------


        // --- GESTIONNAIRES DE ZOOM (WHEEL/PINCH) ---
        function handleMouseWheel(event) {
            event.preventDefault(); 
            
            const zoomSpeed = 200; 
            const zoomAmount = event.deltaY > 0 ? zoomSpeed : -zoomSpeed;
            
            updateCameraDistance(camera.position.z + zoomAmount);
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function handleTouchStartPinch(event) {
            if (event.touches.length === 2) {
                initialPinchDistance = getPinchDistance(event.touches);
            }
            isDragging = false; 
        }

        function handleTouchMovePinch(event) {
            if (event.touches.length === 2) {
                event.preventDefault(); 
                const currentPinchDistance = getPinchDistance(event.touches);
                
                if (initialPinchDistance) {
                    const delta = currentPinchDistance - initialPinchDistance;
                    const zoomFactor = -delta * 5; 
                    
                    updateCameraDistance(camera.position.z + zoomFactor);
                    
                    initialPinchDistance = currentPinchDistance; 
                }
            }
        }
        
        function handleTouchEndPinch(event) {
            initialPinchDistance = null;
            if (event.touches.length === 1) {
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function updateCameraDistance(newZ) {
            const clampedZ = Math.max(minCameraDistance, Math.min(maxCameraDistance, newZ));
            camera.position.z = clampedZ;
            cameraDistance = clampedZ; 
            
            updatePanFactor();
        }
        // -------------------------------------


        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function createCard(player) {
            const power = Math.floor(Math.random() * 10) + 1;
            const type = cardTypes[Math.floor(Math.random() * cardTypes.length)];
            
            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${player} ${type}`; 
            
            let typeLabel;
            switch(type) {
                case 'melee': typeLabel = 'Mêlée'; break;
                case 'range': typeLabel = 'Distance'; break;
                case 'siege': typeLabel = 'Siège'; break;
                default: typeLabel = '';
            }
            
            cardDiv.innerHTML = `
                <div class="card-type-label">${typeLabel}</div>
                <div class="card-power">${power}</div>
            `;
            cardDiv.style.transform = 'translateZ(10px)'; 
            cardDiv.style.opacity = '0';
            
            const cardObj = new THREE.CSS3DObject(cardDiv);
            cardObj.position.set(0, 0, PLATEAU_Z);
            cardObj.scale.set(0.1, 0.1, 0.1);
            
            return { obj: cardObj, power, type, element: cardDiv };
        }

        function getNextAvailableX(teamPositions) {
            let attempts = 0;
            const maxAttempts = 300;
            
            while (attempts < maxAttempts) {
                const x = (Math.random() - 0.5) * boardWidth * 0.8;
                
                const halfCardWidth = cardWidth / 2 + margin;
                const occupied = teamPositions.some(posX => 
                    Math.abs(x - posX) < halfCardWidth * 2
                );
                
                if (!occupied) {
                    return x;
                }
                attempts++;
            }
            
            return (Math.random() - 0.5) * boardWidth * 0.8; 
        }

        function updateCardsVerticalPositions(barY) {
            const cardTargets = [];
            
            const verticalOffset = STACK_FACTOR * (cardHeight + gap);
            const halfCardHeightWithGap = halfCardHeight + gap;
            
            const jitterRange = 30; 

            // --- Joueur A (descend à partir de la barre) ---
            let base_Y_A = barY - halfCardHeightWithGap;
            a_cards.forEach((card, i) => {
                const baseTargetY = base_Y_A - (i * verticalOffset);
                
                const jitterY = Math.random() * jitterRange - (jitterRange / 2); 
                const targetY = baseTargetY + jitterY; 
                
                const isOnBoard = targetY - halfCardHeight > bottomY;
                
                cardTargets.push({ card: card.obj.position, y: targetY });
                
                card.obj.position.x = a_card_positions[i];
                card.obj.position.z = PLATEAU_Z + i * 5; 
                card.element.classList[isOnBoard ? 'remove' : 'add']('off-board');
            });

            // --- Joueur B (monte à partir de la barre) ---
            let base_Y_B = barY + halfCardHeightWithGap;
            b_cards.forEach((card, i) => {
                const baseTargetY = base_Y_B + (i * verticalOffset);
                
                const jitterY = Math.random() * jitterRange - (jitterRange / 2); 
                const targetY = baseTargetY + jitterY;
                
                const isOnBoard = targetY + halfCardHeight < topY;

                cardTargets.push({ card: card.obj.position, y: targetY });

                card.obj.position.x = b_card_positions[i];
                card.obj.position.z = PLATEAU_Z + i * 5;
                card.element.classList[isOnBoard ? 'remove' : 'add']('off-board');
            });
            
            return cardTargets;
        }

        function updateBar(barY, animate = true) {
            currentBarY = barY;
            
            const duration = animate ? 1 : 0;
            
            // Bar 3D (Le plus en avant)
            gsap.to(progressBar3D.position, { y: barY, duration: duration, ease: "power2.out" });
            
            // Mise à jour du Plateau (Bordure, Fond)
            gsap.to(boardBorder.element.style, { 
                width: `${boardWidth}px`,
                height: `${BOARD_TOTAL_HEIGHT}px`,
                duration: duration, 
                ease: "power2.out"
            });
            boardBorder.position.set(0, 0, -50); 

            gsap.to(boardArea.element.style, { 
                width: `${boardWidth}px`,
                height: `${BOARD_TOTAL_HEIGHT}px`,
                duration: duration, 
                ease: "power2.out"
            });
            boardArea.position.set(0, 0, -45); 
            
            // --- Mouvement de la zone de score A (Blanc) (Z: -1) ---
            const heightA = barY - bottomY;
            // Le centre vertical de la zone A (hauteur heightA) doit être positionné par rapport au centre de la scène (Y=0)
            // CentreA = BottomY + (HeightA / 2)
            const centerA = bottomY + (heightA / 2); 
            
            gsap.to(scoreFillA.element.style, { 
                height: `${heightA}px`, 
                duration: duration, 
                ease: "power2.out"
            });

            // Positionnement Y centré
            gsap.to(scoreFillA.position, {
                y: centerA,
                duration: duration, 
                ease: "power2.out"
            });
            
            if (animate || heightA > 0) {
                gsap.to(scoreFillA.element.style, { opacity: 1, duration: 0.5 }, 0); 
            } else {
                gsap.to(scoreFillA.element.style, { opacity: 0, duration: 0.5 });
            }
            
            // Mise à jour des scores UI
            const total = scoreA + scoreB || 1;
            const progressPercent = (scoreA / total) * 100;
            gsap.to('#progressFill', { height: `${progressPercent}%`, duration: 1 });
            document.getElementById('scoreA').textContent = scoreA;
            document.getElementById('scoreB').textContent = scoreB;
        }
        
        async function addTurn(turn) {
            
            const isPlayerA = turn % 2 === 0;
            const player = isPlayerA ? 'A' : 'B';
            const newCard = createCard(player);
            const teamPositions = isPlayerA ? a_card_positions : b_card_positions;
            const newX = getNextAvailableX(teamPositions);
            
            if (isPlayerA) {
                a_card_positions.push(newX);
                a_cards.push(newCard);
                scoreA += newCard.power;
            } else {
                b_card_positions.push(newX);
                b_cards.push(newCard);
                scoreB += newCard.power;
            }

            const total = scoreA + scoreB;
            const newBarY = bottomY + (scoreA / total) * BOARD_TOTAL_HEIGHT; 

            const entryY = isPlayerA ? newBarY - ENTRY_OFFSET : newBarY + ENTRY_OFFSET;
            
            const newCardIndex = (isPlayerA ? a_cards.length : b_cards.length) - 1;
            newCard.obj.position.set(newX, entryY, PLATEAU_Z + newCardIndex * 5); 

            boardGroup.add(newCard.obj);
            
            const cardTargets = updateCardsVerticalPositions(newBarY); 

            const mainTimeline = gsap.timeline();
            const cardDuration = 1.2; 
            const barDuration = 1;
            const oldCardsStartTime = 0.1; 
            
            if (turn === 1) {
                const overflowBarY = topY; 
                updateBar(overflowBarY, false); 
                currentBarY = overflowBarY;     
                progressBar3D.element.style.opacity = '1';
                scoreFillA.element.style.opacity = '1';
            }

            updateBar(newBarY, true); 

            const newCardTarget = cardTargets.find(t => t.card === newCard.obj.position);
            mainTimeline.to(newCard.obj.position, { 
                y: newCardTarget.y, 
                duration: cardDuration, 
                ease: "power2.out" 
            }, 0); 

            mainTimeline.fromTo(newCard.obj.scale, 
                { x: 0.1, y: 0.1, z: 0.1 },
                { x: 1, y: 1, z: 1, duration: cardDuration, ease: "back.out(1.7)" }, 0
            );
            mainTimeline.to(newCard.element, { opacity: 1, duration: 0.8 }, 0.4);

            const oldCardTargets = cardTargets.filter(t => t.card !== newCard.obj.position);
            
            oldCardTargets.forEach(target => {
                 mainTimeline.to(target.card, { 
                    y: target.y, 
                    duration: barDuration,
                    ease: "power2.out"
                }, oldCardsStartTime);
            });

            await new Promise(resolve => mainTimeline.eventCallback("onComplete", resolve));
            await new Promise(resolve => setTimeout(resolve, 200)); 
        }

        async function startGame() {
            // Création de la première carte (logique inchangée)
            const firstCard = createCard('A');
            const firstX = 0;
            a_card_positions.push(firstX);
            firstCard.obj.scale.set(0.1, 0.1, 0.1);
            firstCard.element.style.opacity = '0';
            a_cards.push(firstCard);
            scoreA += firstCard.power;
            
            const initialBarY = topY; 
            const entryY = initialBarY - ENTRY_OFFSET; 
            
            firstCard.obj.position.set(firstX, entryY, PLATEAU_Z);
            boardGroup.add(firstCard.obj);
            
            const cardTargets = updateCardsVerticalPositions(initialBarY);
            const firstCardTarget = cardTargets.find(t => t.card === firstCard.obj.position);
            
            const initialTimeline = gsap.timeline();
            const initialDuration = 1.2;

            updateBar(initialBarY, true);

            firstCard.obj.position.y = entryY; 

            initialTimeline.to(firstCard.obj.position, {
                y: firstCardTarget.y, 
                duration: initialDuration, 
                ease: "power2.out"
            }, 0);

            initialTimeline.fromTo(firstCard.obj.scale, 
                { x: 0.1, y: 0.1, z: 0.1 },
                { x: 1, y: 1, z: 1, duration: initialDuration, ease: "back.out(1.7)" }, 0
            );
            initialTimeline.to(firstCard.element, { opacity: 1, duration: 0.8 }, 0.4);

            const total = scoreA + scoreB || 1;
            const progressPercent = (scoreA / total) * 100;
            gsap.to('#progressFill', { height: `${progressPercent}%`, duration: initialDuration });
            document.getElementById('scoreA').textContent = scoreA;
            document.getElementById('scoreB').textContent = scoreB;
            
            await new Promise(resolve => initialTimeline.eventCallback("onComplete", resolve));


            await new Promise(resolve => setTimeout(resolve, 1000));

            for (let turn = 1; turn < 20; turn++) {
                await addTurn(turn);
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            boardArea.element.style.width = `${boardWidth}px`;
            boardBorder.element.style.width = `${boardWidth}px`;
            progressBar3D.element.style.width = `${boardWidth}px`;
            scoreFillA.element.style.width = `${boardWidth}px`; 
            
            updateBar(currentBarY, false);
            updateCardsVerticalPositions(currentBarY);
            
            updatePanFactor();
        });

        init();
    </script>
</body>
</html>
