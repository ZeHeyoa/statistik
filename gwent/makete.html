<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gwent CSS3D Demo - Fusion avec Pile de Cartes</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        /* ======================================================= */
        /* === STYLES DU PLATEAU 3D (makete.html) === */
        /* ======================================================= */
        
        /* CONSTANTES DE COULEURS POUR LES LIGNES */
        .C_MELEE_COLOR { background-color: #A8E61D; color: #333; } 
        .C_RANGE_COLOR { background-color: #FFD700; color: #333; } 
        .C_SIEGE_COLOR { background-color: #B0E0E6; color: #333; } 
        
        /* BASE & BACKGROUND */
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #C7D8C2; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            perspective: 1000px;
            touch-action: none; 
        }
        
        /* UI SCORE */
        .ui {
            /* Gardé en 'fixed' car le score DOIT rester en overlay 2D standard */
            position: fixed;
            /* REMONTÉE VISUELLE */
            top: 5px;
            left: 10px;
            color: #d1b453;
            z-index: 1000; /* Augmenté pour être au-dessus du plateau et de la pile */
            background: rgba(0,0,0,0.7);
            /* Resserrement du padding */
            padding: 5px 8px;
            border-radius: 5px;
            border: 1px solid #7800ff;
            box-shadow: 0 0 10px #7800ff;
        }
        
        /* CARTES PLATEAU */
        .card.A, .card.B { 
            width: 150px;
            height: 180px; 
            border: 2px solid rgba(0,0,0,0.5); 
            border-radius: 10px; 
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3); 
            display: flex;
            flex-direction: column;
            justify-content: space-between; 
            align-items: center;
            font-size: 40px; 
            font-weight: bold;
            text-shadow: none;
            cursor: pointer;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            position: relative;
            overflow: hidden;
            transition: opacity 0.3s ease;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
        }

        .card.A:hover, .card.B:hover {
            transform: translateZ(15px);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 2px 2px 4px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        /* Contenu de la carte Plateau */
        .card-power {
            font-size: 60px;
            line-height: 1;
            margin-bottom: 5px;
            z-index: 2;
        }

        .card-type-label {
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
            z-index: 2;
        }

        /* Application des couleurs de LIGNE */
        .card.melee { background-color: #A8E61D; } 
        .card.range { background-color: #FFD700; } 
        .card.siege { background-color: #B0E0E6; } 

        .card.melee .card-power, .card.range .card-power, .card.siege .card-power {
            color: #333; 
            text-shadow: 1px 1px 0 rgba(255,255,255,0.3);
        }

        .card.off-board {
            opacity: 0.2;
            filter: grayscale(80%);
            border-color: #333333;
            box-shadow: none;
        }
        
        /* PROGRESS BAR UI */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 200px; 
            height: 4px; 
            background: rgba(120, 0, 255, 0.3);
            border-radius: 4px; 
            z-index: 1000;
        }
        .progress-fill {
            height: 50%;
            background: #00ffff;
            border-radius: 4px;
            transition: height 1s ease;
        }
        
        /* Style pour la zone totale du plateau (fond bleu) */
        .board-area {
            background: #AEEA9C; 
            overflow: auto;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.1); 
            opacity: 1;
        }

        /* ======================================================= */
        /* === STYLES DE LA PILE (menu.html) === */
        /* ======================================================= */
        :root {
            --card-width-menu: 100px;
            --card-height-menu: 140px;
            --z-gap: 1px;
            --bg-green: #bff5bf;
            --bg-blue: #c9e5ff;
            --bg-orange: #ffe5b0;
            --bg-white: #ffffff;
            --bg-darkgrey: #777777;
            --border-dark: #333;
            --counter-bg: #e67e22;
            --text-dark: #333;
        }

        /* Positionnement géré par THREE.js */
        .scene-menu { 
            position: absolute; 
            width: 300px;     
            height: 400px;    
            pointer-events: none; 
        }
        
        .scene-menu > * {
            pointer-events: auto; 
        }
        
        .card-counter {
            position: absolute;
            bottom: 70%; 
            /* Décalage interne conservé */
            left: 55%; 
            transform: translateX(-50%);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--counter-bg);
            border: 3px solid var(--border-dark);
            color: white;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }

        .toggle-indicator {
            position: absolute;
            top: 80%; 
            /* Décalage interne conservé */
            left: 55%; 
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 5px solid #444;
            display: none; 
            cursor: pointer;
            transition: transform 0.2s ease, background 0.3s ease;
            z-index: 500;
        }
        .toggle-indicator:hover {
            transform: translateX(-50%) scale(1.1);
        }

        .card-stack {
            position: absolute; 
            width: var(--card-width-menu);
            height: var(--card-height-menu);
            transform-style: preserve-3d;
            top: 50%; /* Centré dans le conteneur scene-menu */
            left: 50%; 
            transition: transform 0.2s ease-out; 
            transform: translate(-50%, -50%) rotateX(10deg);
        }

        /* Classes de rebond */
        .card-stack.bounce-x {
            transform: translate(calc(-50% + 5px), -50%) rotateX(10deg); 
            transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .card-stack.bounce-y {
            transform: translate(-50%, calc(-50% + 5px)) rotateX(10deg); 
            transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .card-stack:not(.bounce-x):not(.bounce-y) {
            transition: transform 0.25s ease-out;
        }

        /* Cartes de la pile (Distinction des cartes Plateau) */
        .card.menu-card {
            position: absolute;
            width: var(--card-width-menu);
            height: var(--card-height-menu);
            border: 2px solid var(--border-dark);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            font-size: 30px;
            font-weight: bold;
            color: var(--text-dark);
            cursor: grab;
            user-select: none;
            touch-action: none;
            transition: transform 0.25s ease-out, box-shadow 0.25s ease-out, background-color 0.3s ease;
            box-shadow: 0 3px 4px rgba(0,0,0,0.25);
            font-family: 'Fredoka One', cursive, Arial, sans-serif;
        }
        .card.menu-card .card-count {
            font-size: 16px;
            background: rgba(255,255,255,0.7);
            border-radius: 5px;
            padding: 2px 8px;
            border: 1px solid var(--border-dark);
        }

        .card.menu-card.is-dragging {
            box-shadow: 6px 6px 15px rgba(0,0,0,0.5);
        }

        /* HALO FIN, FLUO ET ESPACÉ */
        .card.menu-card.highlight-halo {
            box-shadow: 
                0 0 0 5px rgba(0, 0, 0, 0), 
                0 0 5px 6px currentColor,  
                0 0 10px 8px currentColor, 
                0 4px 8px rgba(0,0,0,0.4); 
        }

        .card.menu-card.cycle-out {
            z-index: -1;
            transition: transform 0.25s cubic-bezier(0.68,-0.55,0.265,1.55);
            transform: translateZ(-200px) translateY(-100px) scale(0.8);
        }
        .card.menu-card.remove-left, .card.menu-card.remove-right {
            z-index: 100;
            transition: transform 0.3s cubic-bezier(0.68,-0.55,0.265,1.55), opacity 0.3s ease-in;
            opacity: 0; pointer-events: none;
        }
        .card.menu-card.remove-left { transform: translateX(-400px) rotateZ(-15deg) translateZ(-50px); }
        .card.menu-card.remove-right { transform: translateX(400px) rotateZ(15deg) translateZ(-50px); }
    </style>
</head>
<body>
    <div class="ui">
        <div>Joueur A: <span id="scoreA">0</span></div>
        <div>Joueur B: <span id="scoreB">0</span></div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>
    
    <div class="scene-menu">
        <div class="card-counter">0</div>
        <div class="card-stack"></div>
        <div class="toggle-indicator" id="colorToggle"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script>
        /* ======================================================= */
        /* === LOGIQUE THREE.JS (makete.html) === */
        /* ======================================================= */
        const cardWidth = 150; 
        const cardHeight = 180; 
        const halfCardHeight = cardHeight / 2;
        const gap = 10; 
        const PLATEAU_Z = 0;
        
        let scene, camera, renderer;
        let boardGroup, progressBar3D, boardArea, scoreFillA, boardBorder;
        let a_cards = [];
        let b_cards = [];
        let scoreA = 0;
        let scoreB = 0;
        let a_card_positions = [];
        let b_card_positions = [];
        let menuObject; 
        
        let currentBarY = 0; 
        
        const cardTypes = ['melee', 'range', 'siege'];
        
        const BOARD_TOTAL_HEIGHT = 4400; 
        let boardWidth = 7200; 
        
        const bottomY = -BOARD_TOTAL_HEIGHT / 2; 
        const topY = BOARD_TOTAL_HEIGHT / 2;     
        const margin = 100; 
        
        const defaultCameraDistance = 2000; 
        const minCameraDistance = 1000;
        const maxCameraDistance = 3000;
        let cameraDistance = defaultCameraDistance;
        
        const FOUNDATION_COLOR_LIGHT = '#444444'; 
        const SCORE_FILL_COLOR_A = 'rgba(0, 0, 0, 0.2)'; 

        const ENTRY_OFFSET = 2000; 
        const STACK_FACTOR = 0.5; 
        
        // PARAMÈTRES DE LA PILE
        const MENU_CONTAINER_WIDTH = 300; 
        const MENU_CONTAINER_HEIGHT = 400; 
        // CHANGEMENT : 4.5 * 2 = 9.0 (Augmentation totale à 400% de la taille initiale)
        const MENU_SCALE = 9.0;         
        // MODIFIÉ : Changé de -0.20 à -0.10 pour décaler l'ensemble de la pile 10% plus à droite
        const LEFT_OFFSET_PERCENT = -0.10; 
        
        // NOUVEAU PARAMÈTRE : Alignement vertical à 50% du haut de la fenêtre.
        const TOP_ALIGNMENT_PERCENTAGE = 0.5; 

        // Variables de panning/zoom
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let panFactor = 1; 
        let initialPinchDistance = null;
        
        /**
         * Calcule la position X dans l'espace 3D pour que le bord gauche du menu 
         * soit à 1% du bord gauche de la fenêtre.
         */
        function getMenuXPosition() {
            // Calculer la largeur de la vue 3D à la distance de la caméra
            const aspect = window.innerWidth / window.innerHeight;
            const vFOV = camera.fov * Math.PI / 180;
            const viewHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;
            const viewWidth = viewHeight * aspect;
            
            // Largeur de l'objet .scene-menu dans l'espace 3D
            const menuWidth3D = MENU_CONTAINER_WIDTH * MENU_SCALE;
            
            // La position X du bord gauche de la vue 3D
            const viewLeftEdge = camera.position.x - (viewWidth / 2);
            
            // Application du décalage (maintenant possiblement négatif)
            const targetXOffset = viewWidth * LEFT_OFFSET_PERCENT;
            
            // Position X du centre du menu pour que son bord gauche soit à viewLeftEdge + targetXOffset
            const targetCenterX = viewLeftEdge + targetXOffset + (menuWidth3D / 2);
            
            return targetCenterX;
        }

        /**
         * Calcule la position Y dans l'espace 3D pour aligner verticalement le centre de la pile
         * avec 50% du haut de la fenêtre.
         */
        function getMenuYPosition() {
            // Facteur de conversion des pixels écran en unités 3D à la distance de la caméra
            const vFOV = camera.fov * Math.PI / 180;
            const viewHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;
            const unitsPerPixel = viewHeight / window.innerHeight;

            // Décalage en unités 3D correspondant à 50% de la hauteur de l'écran
            const targetTopOffset3D = (window.innerHeight * TOP_ALIGNMENT_PERCENTAGE) * unitsPerPixel;

            // Hauteur de l'objet .scene-menu dans l'espace 3D
            const menuHeight3D = MENU_CONTAINER_HEIGHT * MENU_SCALE;
            
            // La position Y du bord supérieur de la vue 3D
            const viewTopEdge = camera.position.y + (viewHeight / 2);
            
            // Le centre de la pile doit être placé pour que son centre soit à viewTopEdge - targetTopOffset3D.
            // (La position Y de l'objet est son centre)
            const targetCenterY = viewTopEdge - targetTopOffset3D;
            
            return targetCenterY;
        }

        /**
         * Met à jour la position du menu Object (X et Y) dans la scène 3D.
         */
        function updateMenuPosition() {
            if (!menuObject) return;
            
            const targetX = getMenuXPosition();
            const targetY = getMenuYPosition();
            
            // La position Z reste 0 pour que la pile soit toujours visible au niveau de la caméra.
            menuObject.position.set(targetX, targetY, 0); 
            menuObject.scale.set(MENU_SCALE, MENU_SCALE, MENU_SCALE);
        }
        
        function init() {
            scene = new THREE.Scene();
            currentBarY = 0; 

            camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 0, cameraDistance); 
            camera.lookAt(0, 0, 0); 
            
            renderer = new THREE.CSS3DRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = 0;
            document.body.appendChild(renderer.domElement);

            boardGroup = new THREE.Group();
            scene.add(boardGroup);

            // ... (Ajout des éléments du plateau comme avant)
            const borderDiv = document.createElement('div');
            borderDiv.className = 'border-area';
            borderDiv.style.width = `${boardWidth}px`;
            borderDiv.style.height = `${BOARD_TOTAL_HEIGHT}px`;
            borderDiv.style.backgroundColor = 'transparent'; 
            borderDiv.style.border = '30px solid rgba(50, 50, 50, 0.8)'; 
            boardBorder = new THREE.CSS3DObject(borderDiv);
            boardBorder.position.set(0, -500, -50); 
            boardGroup.add(boardBorder);

            const areaDiv = document.createElement('div');
            areaDiv.className = 'board-area';
            areaDiv.style.width = `${boardWidth}px`;
            areaDiv.style.height = `${BOARD_TOTAL_HEIGHT}px`;
            boardArea = new THREE.CSS3DObject(areaDiv);
            boardArea.position.set(0, 0, -45); 
            boardGroup.add(boardArea);
            
            const scoreFillDivA = document.createElement('div');
            scoreFillDivA.className = 'score-fill-A';
            scoreFillDivA.style.width = `${boardWidth}px`;
            scoreFillDivA.style.backgroundColor = SCORE_FILL_COLOR_A;
            scoreFillDivA.style.boxShadow = `none`; 
            scoreFillDivA.style.opacity = '0'; 
            scoreFillA = new THREE.CSS3DObject(scoreFillDivA);
            scoreFillA.position.set(0, 0, -40); 
            boardGroup.add(scoreFillA);

            const barDiv = document.createElement('div');
            barDiv.style.width = `${boardWidth}px`;
            barDiv.style.height = '22px'; 
            barDiv.style.background = `linear-gradient(90deg, #333333, #666666, #333333)`; 
            barDiv.style.borderRadius = '16px';
            barDiv.style.boxShadow = `0 0 60px ${FOUNDATION_COLOR_LIGHT}, inset 0 0 20px rgba(255,255,255,0.1)`;
            barDiv.style.opacity = '0'; 
            progressBar3D = new THREE.CSS3DObject(barDiv);
            progressBar3D.position.set(0, 0, 20); 
            boardGroup.add(progressBar3D);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            
            // -------------------------------------
            // === INTÉGRATION DE LA PILE (SCENE MENU) DANS CSS3DRenderer ===
            // -------------------------------------
            const menuEl = document.querySelector('.scene-menu');
            menuObject = new THREE.CSS3DObject(menuEl);
            // La pile est ajoutée à la scene, PAS au boardGroup, ce qui la rend HUD.
            scene.add(menuObject);
            
            // Positionnement dynamique
            updateMenuPosition(); 
            
            // Événements (inchangés)
            renderer.domElement.addEventListener('mousedown', handleMouseDown, false);
            renderer.domElement.addEventListener('mousemove', handleMouseMove, false);
            window.addEventListener('mouseup', handleMouseUp, false); 
            renderer.domElement.addEventListener('touchstart', handleTouchStartPan, false);
            renderer.domElement.addEventListener('touchmove', handleTouchMovePan, false);
            renderer.domElement.addEventListener('touchend', handleTouchEndPan, false);
            window.addEventListener('wheel', handleMouseWheel, { passive: false });
            window.addEventListener('touchstart', handleTouchStartPinch, { passive: false });
            window.addEventListener('touchmove', handleTouchMovePinch, { passive: false });
            window.addEventListener('touchend', handleTouchEndPinch, { passive: false });
            
            updatePanFactor(); 
            updateBar(currentBarY, false);
            
            initializeMenu(); 
            
            animate();
            startGame();
        }

        // ... (Fonctions de Panning/Zoom, Animate, CreateCard, etc.)

        function updatePanFactor() {
            const vFOV = camera.fov * Math.PI / 180;
            const height = 2 * Math.tan(vFOV / 2) * camera.position.z;
            panFactor = height / window.innerHeight;
        }

        function panCamera(deltaX, deltaY) {
            camera.position.x -= deltaX * panFactor;
            camera.position.y += deltaY * panFactor;
            camera.lookAt(camera.position.x, camera.position.y, 0);
            
            // Mise à jour de la pile lors du pan pour qu'elle reste dans la vue (HUD)
            updateMenuPosition(); 
        }

        function handleMouseDown(event) {
            if (event.button === 0 && !isDraggingMenu) { 
                isDragging = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
                event.preventDefault(); 
            }
        }

        function handleMouseMove(event) {
            if (!isDragging || isDraggingMenu) return;
            
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            panCamera(deltaX, deltaY);

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function handleMouseUp() {
            isDragging = false;
        }
        
        function handleTouchStartPan(event) {
            if (event.touches.length === 1 && !isDraggingMenu) {
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function handleTouchMovePan(event) {
            if (isDragging && event.touches.length === 1 && !isDraggingMenu) {
                event.preventDefault();
                
                const deltaX = event.touches[0].clientX - previousMousePosition.x;
                const deltaY = event.touches[0].clientY - previousMousePosition.y;

                panCamera(deltaX, deltaY);

                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function handleTouchEndPan() {
            if (event.touches.length === 0) {
                 isDragging = false;
            }
        }

        function handleMouseWheel(event) {
            event.preventDefault(); 
            const zoomSpeed = 200; 
            const zoomAmount = event.deltaY > 0 ? zoomSpeed : -zoomSpeed;
            updateCameraDistance(camera.position.z + zoomAmount);
        }

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function handleTouchStartPinch(event) {
            if (event.touches.length === 2 && !isDraggingMenu) {
                initialPinchDistance = getPinchDistance(event.touches);
            }
            isDragging = false; 
        }

        function handleTouchMovePinch(event) {
            if (event.touches.length === 2 && !isDraggingMenu) {
                event.preventDefault(); 
                const currentPinchDistance = getPinchDistance(event.touches);
                
                if (initialPinchDistance) {
                    const delta = currentPinchDistance - initialPinchDistance;
                    const zoomFactor = -delta * 5; 
                    updateCameraDistance(camera.position.z + zoomFactor);
                    initialPinchDistance = currentPinchDistance; 
                }
            }
        }
        
        function handleTouchEndPinch(event) {
            initialPinchDistance = null;
            if (event.touches.length === 1 && !isDraggingMenu) {
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function updateCameraDistance(newZ) {
            const clampedZ = Math.max(minCameraDistance, Math.min(maxCameraDistance, newZ));
            camera.position.z = clampedZ;
            cameraDistance = clampedZ; 
            updatePanFactor();
            
            // Mise à jour de la pile lors du zoom pour qu'elle garde sa position relative
            updateMenuPosition(); 
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function createCard(player) {
            const power = Math.floor(Math.random() * 10) + 1;
            const type = cardTypes[Math.floor(Math.random() * cardTypes.length)];
            
            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${player} ${type}`; 
            
            let typeLabel;
            switch(type) {
                case 'melee': typeLabel = 'Mêlée'; break;
                case 'range': typeLabel = 'Distance'; break;
                case 'siege': typeLabel = 'Siège'; break;
                default: typeLabel = '';
            }
            
            cardDiv.innerHTML = `
                <div class="card-type-label">${typeLabel}</div>
                <div class="card-power">${power}</div>
            `;
            cardDiv.style.transform = 'translateZ(10px)'; 
            cardDiv.style.opacity = '0';
            
            const cardObj = new THREE.CSS3DObject(cardDiv);
            cardObj.position.set(0, 0, PLATEAU_Z);
            cardObj.scale.set(0.1, 0.1, 0.1);
            
            return { obj: cardObj, power, type, element: cardDiv };
        }

        function getNextAvailableX(teamPositions) {
            let attempts = 0;
            const maxAttempts = 300;
            
            while (attempts < maxAttempts) {
                const x = (Math.random() - 0.5) * boardWidth * 0.8;
                
                const halfCardWidth = cardWidth / 2 + margin;
                const occupied = teamPositions.some(posX => 
                    Math.abs(x - posX) < halfCardWidth * 2
                );
                
                if (!occupied) {
                    return x;
                }
                attempts++;
            }
            
            return (Math.random() - 0.5) * boardWidth * 0.8; 
        }

        function updateCardsVerticalPositions(barY) {
            const cardTargets = [];
            
            const verticalOffset = STACK_FACTOR * (cardHeight + gap);
            const halfCardHeightWithGap = halfCardHeight + gap;
            
            const jitterRange = 30; 

            // --- Joueur A (descend à partir de la barre) ---
            let base_Y_A = barY - halfCardHeightWithGap;
            a_cards.forEach((card, i) => {
                const baseTargetY = base_Y_A - (i * verticalOffset);
                
                const jitterY = Math.random() * jitterRange - (jitterRange / 2); 
                const targetY = baseTargetY + jitterY; 
                
                const isOnBoard = targetY - halfCardHeight > bottomY;
                
                cardTargets.push({ card: card.obj.position, y: targetY });
                
                card.obj.position.x = a_card_positions[i];
                card.obj.position.z = PLATEAU_Z + i * 5; 
                card.element.classList[isOnBoard ? 'remove' : 'add']('off-board');
            });

            // --- Joueur B (monte à partir de la barre) ---
            let base_Y_B = barY + halfCardHeightWithGap;
            b_cards.forEach((card, i) => {
                const baseTargetY = base_Y_B + (i * verticalOffset);
                
                const jitterY = Math.random() * jitterRange - (jitterRange / 2); 
                const targetY = baseTargetY + jitterY;
                
                const isOnBoard = targetY + halfCardHeight < topY;

                cardTargets.push({ card: card.obj.position, y: targetY });

                card.obj.position.x = b_card_positions[i];
                card.obj.position.z = PLATEAU_Z + i * 5;
                card.element.classList[isOnBoard ? 'remove' : 'add']('off-board');
            });
            
            return cardTargets;
        }

        function updateBar(barY, animate = true) {
            currentBarY = barY;
            
            const duration = animate ? 1 : 0;
            
            gsap.to(progressBar3D.position, { y: barY, duration: duration, ease: "power2.out" });
            
            gsap.to(boardBorder.element.style, { width: `${boardWidth}px`, height: `${BOARD_TOTAL_HEIGHT}px`, duration: duration, ease: "power2.out" });
            boardBorder.position.set(0, 0, -50); 

            gsap.to(boardArea.element.style, { width: `${boardWidth}px`, height: `${BOARD_TOTAL_HEIGHT}px`, duration: duration, ease: "power2.out" });
            boardArea.position.set(0, 0, -45); 
            
            const heightA = barY - bottomY;
            const centerA = bottomY + (heightA / 2); 
            
            gsap.to(scoreFillA.element.style, { height: `${heightA}px`, duration: duration, ease: "power2.out" });
            gsap.to(scoreFillA.position, { y: centerA, duration: duration, ease: "power2.out" });
            
            if (animate || heightA > 0) {
                gsap.to(scoreFillA.element.style, { opacity: 1, duration: 0.5 }, 0); 
            } else {
                gsap.to(scoreFillA.element.style, { opacity: 0, duration: 0.5 });
            }
            
            // Mise à jour des scores UI
            const total = scoreA + scoreB || 1;
            const progressPercent = (scoreA / total) * 100;
            gsap.to('#progressFill', { height: `${progressPercent}%`, duration: 1 });
            document.getElementById('scoreA').textContent = scoreA;
            document.getElementById('scoreB').textContent = scoreB;
        }
        
        async function addTurn(turn) {
            
            const isPlayerA = turn % 2 === 0;
            const player = isPlayerA ? 'A' : 'B';
            const newCard = createCard(player);
            const teamPositions = isPlayerA ? a_card_positions : b_card_positions;
            const newX = getNextAvailableX(teamPositions);
            
            if (isPlayerA) {
                a_card_positions.push(newX);
                a_cards.push(newCard);
                scoreA += newCard.power;
            } else {
                b_card_positions.push(newX);
                b_cards.push(newCard);
                scoreB += newCard.power;
            }

            const total = scoreA + scoreB;
            const newBarY = bottomY + (scoreA / total) * BOARD_TOTAL_HEIGHT; 

            const entryY = isPlayerA ? newBarY - ENTRY_OFFSET : newBarY + ENTRY_OFFSET;
            
            const newCardIndex = (isPlayerA ? a_cards.length : b_cards.length) - 1;
            newCard.obj.position.set(newX, entryY, PLATEAU_Z + newCardIndex * 5); 

            boardGroup.add(newCard.obj);
            
            const cardTargets = updateCardsVerticalPositions(newBarY); 

            const mainTimeline = gsap.timeline();
            const cardDuration = 1.2; 
            const barDuration = 1;
            const oldCardsStartTime = 0.1; 
            
            if (turn === 1) {
                const overflowBarY = topY; 
                updateBar(overflowBarY, false); 
                currentBarY = overflowBarY;     
                progressBar3D.element.style.opacity = '1';
                scoreFillA.element.style.opacity = '1';
            }

            updateBar(newBarY, true); 

            const newCardTarget = cardTargets.find(t => t.card === newCard.obj.position);
            mainTimeline.to(newCard.obj.position, { y: newCardTarget.y, duration: cardDuration, ease: "power2.out" }, 0); 

            mainTimeline.fromTo(newCard.obj.scale, 
                { x: 0.1, y: 0.1, z: 0.1 },
                { x: 1, y: 1, z: 1, duration: cardDuration, ease: "back.out(1.7)" }, 0
            );
            mainTimeline.to(newCard.element, { opacity: 1, duration: 0.8 }, 0.4);

            const oldCardTargets = cardTargets.filter(t => t.card !== newCard.obj.position);
            
            oldCardTargets.forEach(target => {
                 mainTimeline.to(target.card, { y: target.y, duration: barDuration, ease: "power2.out"}, oldCardsStartTime);
            });

            await new Promise(resolve => mainTimeline.eventCallback("onComplete", resolve));
            await new Promise(resolve => setTimeout(resolve, 200)); 
        }

        async function startGame() {
            const firstCard = createCard('A');
            const firstX = 0;
            a_card_positions.push(firstX);
            firstCard.obj.scale.set(0.1, 0.1, 0.1);
            firstCard.element.style.opacity = '0';
            a_cards.push(firstCard);
            scoreA += firstCard.power;
            
            const initialBarY = topY; 
            const entryY = initialBarY - ENTRY_OFFSET; 
            
            firstCard.obj.position.set(firstX, entryY, PLATEAU_Z);
            boardGroup.add(firstCard.obj);
            
            const cardTargets = updateCardsVerticalPositions(initialBarY);
            const firstCardTarget = cardTargets.find(t => t.card === firstCard.obj.position);
            
            const initialTimeline = gsap.timeline();
            const initialDuration = 1.2;

            updateBar(initialBarY, true);

            firstCard.obj.position.y = entryY; 

            initialTimeline.to(firstCard.obj.position, { y: firstCardTarget.y, duration: initialDuration, ease: "power2.out" }, 0);

            initialTimeline.fromTo(firstCard.obj.scale, 
                { x: 0.1, y: 0.1, z: 0.1 },
                { x: 1, y: 1, z: 1, duration: initialDuration, ease: "back.out(1.7)" }, 0
            );
            initialTimeline.to(firstCard.element, { opacity: 1, duration: 0.8 }, 0.4);

            const total = scoreA + scoreB || 1;
            const progressPercent = (scoreA / total) * 100;
            gsap.to('#progressFill', { height: `${progressPercent}%`, duration: initialDuration });
            document.getElementById('scoreA').textContent = scoreA;
            document.getElementById('scoreB').textContent = scoreB;
            
            await new Promise(resolve => initialTimeline.eventCallback("onComplete", resolve));


            await new Promise(resolve => setTimeout(resolve, 1000));

            for (let turn = 1; turn < 20; turn++) {
                await addTurn(turn);
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            boardArea.element.style.width = `${boardWidth}px`;
            boardBorder.element.style.width = `${boardWidth}px`;
            progressBar3D.element.style.width = `${boardWidth}px`;
            scoreFillA.element.style.width = `${boardWidth}px`; 
            
            updateBar(currentBarY, false);
            updateCardsVerticalPositions(currentBarY);
            
            updatePanFactor();
            // Mise à jour du menu lors du resize et du pan
            updateMenuPosition(); 
        });

        /* ======================================================= */
        /* === LOGIQUE DE PILE (menu.html) === */
        /* ======================================================= */
        const stackEl = document.querySelector('.card-stack');
        const counterEl = document.querySelector('.card-counter');
        const toggleEl = document.getElementById('colorToggle');

        const COLORS = {
            green: '#bff5bf',
            blue: '#c9e5ff',
            orange: '#ffe5b0',
            white: '#ffffff',
            darkgrey: '#777777'
        };

        const CARD_COUNT_MENU = 12; 
        const Z_GAP = 1;
        const SWIPE_THRESHOLD = 80;

        let topCard = null;
        let isDraggingMenu = false; 
        let startX = 0, startY = 0, currentX = 0, currentY = 0;
        let currentToggleColor = null;
        let togglePair = null; 

        function randomColorGroup(i) {
            const groups = ['green','blue','orange','white','darkgrey'];
            return groups[i % groups.length];
        }

        function initializeMenu() {
            stackEl.innerHTML = '';
            for (let i = 0; i < CARD_COUNT_MENU; i++) {
                const group = randomColorGroup(i);
                const card = document.createElement('div');
                card.className = 'card menu-card'; 
                card.dataset.group = group;
                card.style.backgroundColor = COLORS[group];
                card.innerHTML = `
                    <div class="card-icon">${group === 'orange' ? '🔥' : group === 'blue' ? '💧' : group === 'green' ? '🌿' : group === 'darkgrey' ? '⬛' : '⚪'}</div>
                    <div class="card-count">${group}</div>
                `;
                stackEl.appendChild(card);
            }
            updateTopCardReference();
            updateCardIndices();
            updateCounter();
        }

        function updateTopCardReference() {
            if (topCard) {
                topCard.removeEventListener('mousedown', startDragMenu);
                topCard.removeEventListener('touchstart', startDragMenu);
                topCard.classList.remove('highlight-halo'); 
            }
            topCard = stackEl.firstElementChild;
            if (!topCard) {
                 toggleEl.style.display = 'none';
                 return;
            }

            if (topCard.dataset.group !== 'white' && topCard.dataset.group !== 'darkgrey') {
                topCard.removeAttribute('data-is-toggled');
            }

            topCard.addEventListener('mousedown', startDragMenu);
            topCard.addEventListener('touchstart', startDragMenu);

            if (topCard.dataset.group === 'white') {
                currentToggleColor = null; 
                togglePair = { left: 'green', right: 'blue' };
                showToggle();
            } else if (topCard.dataset.group === 'darkgrey') {
                currentToggleColor = null; 
                togglePair = { left: 'green', right: 'orange' };
                showToggle();
            } else {
                toggleEl.style.display = 'none';
                togglePair = null;
            }
        }

        function showToggle() {
            toggleEl.style.display = 'flex';
            toggleEl.style.background = `linear-gradient(90deg, ${COLORS[togglePair.left]} 50%, ${COLORS[togglePair.right]} 50%)`;
        }

        function updateCounter() {
            counterEl.textContent = stackEl.children.length;
        }

        function updateCardIndices() {
            const cards = Array.from(stackEl.children);
            cards.forEach((card, index) => {
                const zPos = -index * Z_GAP;
                card.style.transform = `translateZ(${zPos}px)`;
                card.style.color = 'var(--text-dark)'; 
            });
        }

        function bounceStack(axis = 'x') {
            const className = `bounce-${axis}`;
            stackEl.classList.add(className);
            
            setTimeout(() => {
                stackEl.classList.remove(className);
                stackEl.style.transform = 'translate(-50%, -50%) rotateX(10deg)'; 
            }, 250); 
        }

        function startDragMenu(e) {
            if (!topCard || isDraggingMenu) return;
            isDraggingMenu = true;
            const client = e.touches ? e.touches[0] : e;
            startX = client.clientX;
            startY = client.clientY;
            topCard.classList.add('is-dragging');
            document.addEventListener('mousemove', dragMenu);
            document.addEventListener('mouseup', endDragMenu);
            document.addEventListener('touchmove', dragMenu, { passive: false });
            document.addEventListener('touchend', endDragMenu);
        }

        function dragMenu(e) {
            if (!isDraggingMenu) return;
            const client = e.touches ? e.touches[0] : e;
            currentX = client.clientX - startX;
            currentY = client.clientY - startY;
            const rotation = currentX / 20;
            
            const cards = Array.from(stackEl.children);

            cards.forEach((card, index) => {
                const zPos = -index * Z_GAP;
                const scaleFactor = Math.pow(0.5, index);
                const translateX = currentX * scaleFactor;
                const translateY = currentY * scaleFactor;
                const rotateZ = rotation * scaleFactor * 0.3; 

                card.style.transform = `translateX(${translateX}px) translateY(${translateY}px) rotateZ(${rotateZ}deg) translateZ(${zPos}px)`;
            });

            const absX = Math.abs(currentX);
            const absY = Math.abs(currentY);
            const cardGroup = topCard.dataset.group;
            const isSpecialCard = cardGroup === 'white' || cardGroup === 'darkgrey';
            const isToggledToNewColor = isSpecialCard && topCard.dataset.isToggled === 'true';

            const isPotentialRemoval = absX > SWIPE_THRESHOLD && absX > absY && (!isSpecialCard || isToggledToNewColor);

            if (isPotentialRemoval) {
                topCard.style.color = topCard.style.backgroundColor;
                topCard.classList.add('highlight-halo');
            } else {
                topCard.classList.remove('highlight-halo');
                topCard.style.color = 'var(--text-dark)'; 
            }

            if (e.cancelable) e.preventDefault();
        }

        function endDragMenu() {
            if (!isDraggingMenu) return;
            isDraggingMenu = false;
            topCard.classList.remove('is-dragging');
            topCard.classList.remove('highlight-halo'); 
            topCard.style.color = 'var(--text-dark)'; 
            
            const absX = Math.abs(currentX);
            const absY = Math.abs(currentY);
            const cardGroup = topCard.dataset.group;

            const isSpecialCard = cardGroup === 'white' || cardGroup === 'darkgrey';
            const isToggledToNewColor = isSpecialCard && topCard.dataset.isToggled === 'true'; 

            let actionTaken = false;

            if (absX > SWIPE_THRESHOLD && absX > absY) {
                if (isSpecialCard && !isToggledToNewColor) { 
                    handleCycle(true); // Rebond X
                    actionTaken = true;
                } else {
                    handleRemoval(currentX > 0 ? 'right' : 'left');
                    actionTaken = true;
                }
            } else if (absY > SWIPE_THRESHOLD && absY > absX) {
                handleCycle(false, true); // Rebond Y
                actionTaken = true;
            }

            if (!actionTaken) {
                if (absX > absY) bounceStack('x');
                else bounceStack('y');
                handleReset();
            }

            document.removeEventListener('mousemove', dragMenu);
            document.removeEventListener('mouseup', endDragMenu);
            document.removeEventListener('touchmove', dragMenu);
            document.removeEventListener('touchend', endDragMenu);
        }

        function handleReset() {
            currentX = currentY = 0;
            updateCardIndices(); 
        }

        function handleCycle(bounceX = false, bounceY = false) {
            topCard.style.transform = `translateZ(0px)`;
            topCard.classList.remove('highlight-halo'); 
            topCard.style.color = 'var(--text-dark)'; 
            topCard.classList.add('cycle-out');

            if (bounceX) bounceStack('x');
            if (bounceY) bounceStack('y');
            
            setTimeout(() => {
                topCard.classList.remove('cycle-out');
                stackEl.removeChild(topCard);
                
                if (topCard.dataset.group === 'white' || topCard.dataset.group === 'darkgrey') {
                    topCard.style.backgroundColor = COLORS[topCard.dataset.group];
                    topCard.innerHTML = `<div class="card-icon">${topCard.dataset.group === 'white' ? '⚪' : '⬛'}</div><div class="card-count">${topCard.dataset.group}</div>`;
                    topCard.removeAttribute('data-is-toggled'); 
                }
                
                stackEl.appendChild(topCard);
                updateCardIndices();
                updateTopCardReference();
            }, 250);
        }

        function handleRemoval(direction) {
            topCard.classList.remove('highlight-halo'); 
            topCard.style.color = 'var(--text-dark)'; 

            topCard.classList.add(`remove-${direction}`);
            
            if (direction === 'left') bounceStack('x');
            else bounceStack('x');

            setTimeout(() => {
                stackEl.removeChild(topCard);
                updateCardIndices();
                updateCounter();
                updateTopCardReference();
                if (stackEl.children.length === 0) setTimeout(initializeMenu, 500);
            }, 300);
        }

        // Clique sur pastille => change la teinte
        toggleEl.addEventListener('click', () => {
            if (!topCard || !togglePair) return;

            currentToggleColor = (currentToggleColor === togglePair.left) ? togglePair.right : togglePair.left;
            const chosenColor = COLORS[currentToggleColor];
            const chosenText = `teinte: ${currentToggleColor}`;
            const icon = currentToggleColor === 'green' ? '🌿' :
                         currentToggleColor === 'blue' ? '💧' : '🔥';
            
            topCard.style.backgroundColor = chosenColor;
            topCard.innerHTML = `
                <div class="card-icon">${icon}</div>
                <div class="card-count">${chosenText}</div>
            `;
            
            topCard.dataset.isToggled = 'true'; 
        });


        // Lancement de l'initialisation de Three.js
        window.addEventListener('load', init); 
    </script>
</body>
</html>
